{"version":3,"file":"index.js","sources":["../../../common/temp/node_modules/.pnpm/@skype+tsregistrar@2024.14.0-1.56-h89a1c/node_modules/@skype/tsregistrar/lib/webpack:/webpack/universalModuleDefinition","../../../common/temp/node_modules/.pnpm/@skype+tsregistrar@2024.14.0-1.56-h89a1c/node_modules/@skype/tsregistrar/lib/webpack:/webpack/bootstrap 6b13a4ac2afc10e0dd9d","../../../common/temp/node_modules/.pnpm/@skype+tsregistrar@2024.14.0-1.56-h89a1c/node_modules/@skype/tsregistrar/lib/webpack:/tsregistrar.js","../../../common/temp/node_modules/.pnpm/@skype+tsregistrar@2024.14.0-1.56-h89a1c/node_modules/@skype/tsregistrar/lib/webpack:/lib_temp/Common.ts","../../../common/temp/node_modules/.pnpm/@skype+tsregistrar@2024.14.0-1.56-h89a1c/node_modules/@skype/tsregistrar/lib/webpack:/lib_temp/RegistrarClient.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/webpack/universalModuleDefinition","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/webpack/bootstrap b8d066f6f21edf895ca2","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/tstrouter.js","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/Logger.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/Constants.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/Interfaces.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/Common.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/InternalInterfaces.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/ProtocolAdapters.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/TrouterFsm.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/TrouterConnection.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/MessageHandler.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/SkypeTokenProviderWithCache.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/TrouterManager.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/TrouterUrlPromise.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/socket.io.js","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/(webpack)/buildin/global.js","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/(webpack)/buildin/module.js","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/ConnectionTracker.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/DisconnectReason.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/ExponentialBackoff.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/RegistrationEnforcer.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/TrouterManagerFsm.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/lib_temp/TsTrouter.ts","../../../common/temp/node_modules/.pnpm/@skype+tstrouter@2024.14.0-1.56-h89a1c/node_modules/@skype/tstrouter/lib/webpack:/external \"@skype/tsregistrar\"","../dist-esm/src/constants.js","../dist-esm/src/TrouterUtils.js","../dist-esm/src/TrouterConfigClient.js","../dist-esm/src/TrouterSettings.js","../dist-esm/src/SignalingClient.js","../dist-esm/src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"@skype/tsregistrar\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@skype/tsregistrar\"] = factory();\n\telse\n\t\troot[\"@skype/tsregistrar\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6b13a4ac2afc10e0dd9d","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"@skype/tsregistrar\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@skype/tsregistrar\"] = factory();\n\telse\n\t\troot[\"@skype/tsregistrar\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Timespan = exports.toJson = exports.fetchWithTimeout = void 0;\n/** Wrapper to send request with specified timeout */\nfunction fetchWithTimeout(request, timeoutMs) {\n    var timeoutId;\n    var fetchPromise = new Promise(function (resolve, reject) {\n        fetch(request).then(function (response) {\n            if (timeoutId !== undefined) {\n                clearTimeout(timeoutId);\n            }\n            resolve(response);\n        }).catch(function (error) {\n            if (timeoutId !== undefined) {\n                clearTimeout(timeoutId);\n            }\n            reject(error);\n        });\n    });\n    if (timeoutMs !== 0) {\n        var timeoutPromise = new Promise(function (resolve, reject) {\n            timeoutId = setTimeout(reject, timeoutMs, new Error(\"Fetch for '\".concat(request.url, \"' timed out\")));\n        });\n        return Promise.race([fetchPromise, timeoutPromise]);\n    }\n    return fetchPromise;\n}\nexports.fetchWithTimeout = fetchWithTimeout;\nfunction toJson(obj) {\n    try {\n        return JSON.stringify(obj);\n    }\n    catch (error) {\n        return \"Unable to serialize object of type \".concat(typeof obj);\n    }\n}\nexports.toJson = toJson;\n/**\n * Simplify calculation of time intervals\n */\nvar Timespan = /** @class */ (function () {\n    function Timespan() {\n        this.start = Date.now();\n    }\n    Object.defineProperty(Timespan.prototype, \"duration\", {\n        /**\n         * Returns number of milliseconds from start\n         */\n        get: function () {\n            return Date.now() - this.start;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Timespan.prototype, \"startTime\", {\n        /**\n         * Returns start time\n         */\n        get: function () {\n            return this.start;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Reset start of interval to current timestamp\n     */\n    Timespan.prototype.reset = function () {\n        this.start = Date.now();\n    };\n    return Timespan;\n}());\nexports.Timespan = Timespan;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createRegistrarClient = exports.RegistrarClient = void 0;\nvar Common_1 = __webpack_require__(0);\nvar SUPPORTED_TOKEN_TYPES = ['skype', 'aad', 'cae'];\n/**\n * Thrown when retry process was cancelled\n */\nvar CancelationError = /** @class */ (function (_super) {\n    __extends(CancelationError, _super);\n    function CancelationError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = 'CancelationError';\n        return _this;\n    }\n    return CancelationError;\n}(Error));\n/**\n * Randomized exponential delay used for retries\n */\nvar ExponentialDelay = /** @class */ (function () {\n    function ExponentialDelay(logger, maxBackoffInMs, initialDelay) {\n        this.logger = logger;\n        this.maxBackoffInMs = maxBackoffInMs;\n        this.initialDelay = initialDelay;\n        this.backoffCount = 0;\n        this.id = ++ExponentialDelay.idCounter;\n    }\n    ExponentialDelay.prototype.delay = function (taskName) {\n        var _this = this;\n        if (this.timerHandle !== undefined) {\n            throw new Error('Retry sequence logical failure');\n        }\n        if (this.backoffCount === -1) {\n            return new Promise(function (resolve, reject) { reject(new CancelationError('Cancelled')); });\n        }\n        var backoffMs = this.calculateNextBackoffMs();\n        this.backoffCount++;\n        this.logger.info(\"[RegistrarClient] Backing off \".concat(taskName, \" for \").concat(backoffMs, \" milliseconds with ID \").concat(this.id));\n        return new Promise(function (resolve, reject) {\n            _this.cancelFunc = reject;\n            _this.timerHandle = setTimeout(function () {\n                _this.logger.info(\"[RegistrarClient] Back off for \".concat(taskName, \" with ID \").concat(_this.id, \" complete\"));\n                _this.timerHandle = undefined;\n                resolve();\n            }, backoffMs);\n        });\n    };\n    ExponentialDelay.prototype.cancel = function () {\n        if (this.timerHandle !== undefined) {\n            this.logger.debug('Resetting back off');\n            clearTimeout(this.timerHandle);\n            if (this.cancelFunc !== undefined) {\n                this.cancelFunc(new CancelationError('Cancelled'));\n            }\n        }\n        this.backoffCount = -1;\n    };\n    ExponentialDelay.prototype.calculateNextBackoffMs = function () {\n        var fudge = 1 + (Math.random() - 0.5) * 0.4; // +/- 20%\n        var backoff = this.initialDelay * Math.pow(2, this.backoffCount) * fudge;\n        backoff = Math.round(backoff);\n        return Math.min(this.maxBackoffInMs, backoff);\n    };\n    ExponentialDelay.idCounter = 0;\n    return ExponentialDelay;\n}());\n/**\n * Registrar client implementation\n */\nvar RegistrarClient = /** @class */ (function () {\n    function RegistrarClient(logger, tokenProvider, options) {\n        var _a;\n        this.logger = logger;\n        this.tokenProvider = tokenProvider;\n        this.options = options;\n        this.DEFAULT_MAX_RETRIES_FOR_GET_TOKEN = 15;\n        // Default value for maximum backoff between retries\n        this.DEFAULT_MAX_BACKOFF_TIME_IN_MS = 300000; // 5 minutes\n        this.backoffs = {};\n        this.maxBackOffTime =\n            this.options.maxRetryDelayMs > 0\n                ? this.options.maxRetryDelayMs\n                : this.DEFAULT_MAX_BACKOFF_TIME_IN_MS;\n        this.maxRetriesForGetToken =\n            options.maxRetriesForGetToken === undefined ||\n                options.maxRetriesForGetToken === null\n                ? this.DEFAULT_MAX_RETRIES_FOR_GET_TOKEN\n                : options.maxRetriesForGetToken;\n        this.proxyUrlRewrite = (_a = options.proxyUrlRewrite) !== null && _a !== void 0 ? _a : (function (url) { return url; });\n    }\n    RegistrarClient.prototype.setTelemetryLogger = function (eventLogger) {\n        this.eventLogger = eventLogger;\n    };\n    RegistrarClient.prototype.register = function (client, transports) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.performRegistration(client, transports, 'pr_set_registration')];\n                    case 1:\n                        _a.sent();\n                        this.cachedRegistrationParams = [client, transports];\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    RegistrarClient.prototype.unregister = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var unregisterRequest;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.logger.info('[RegistrarClient] sending unregister request');\n                        unregisterRequest = new Request(this.proxyUrlRewrite(\"\".concat(this.options.registrarUrl, \"/\").concat(this.options.registrationId)), {\n                            method: 'DELETE',\n                            mode: 'cors',\n                            headers: new Headers(__assign(__assign({}, this.options.extraRegistrationHeaders), { accept: 'application/json, text/javascript' }))\n                        });\n                        return [4 /*yield*/, this.callRegistrar(unregisterRequest, 'pr_delete_registration')];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    RegistrarClient.prototype.cancelPendingRequests = function () {\n        var _this = this;\n        Object.keys(this.backoffs).forEach(function (id) {\n            _this.backoffs[id].cancel();\n        });\n        this.backoffs = {};\n    };\n    RegistrarClient.prototype.resendRegistration = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.cachedRegistrationParams) {\n                            throw new Error('Re-registration failed because there is no registration parameters cached');\n                        }\n                        return [4 /*yield*/, this.performRegistration(this.cachedRegistrationParams[0], this.cachedRegistrationParams[1], 'pr_resend_registration')];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    RegistrarClient.prototype.performRegistration = function (client, transports, eventName) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, registerRequest;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.logger.info('[RegistrarClient] Sending register request');\n                        payload = {\n                            clientDescription: client,\n                            registrationId: this.options.registrationId,\n                            nodeId: '',\n                            transports: transports\n                        };\n                        registerRequest = new Request(this.proxyUrlRewrite(this.options.registrarUrl), {\n                            method: 'POST',\n                            mode: 'cors',\n                            headers: new Headers(__assign(__assign({}, this.options.extraRegistrationHeaders), { 'content-type': 'application/json', accept: 'application/json, text/javascript' })),\n                            body: (0, Common_1.toJson)(payload)\n                        });\n                        return [4 /*yield*/, this.callRegistrar(registerRequest, eventName)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    RegistrarClient.prototype.startBackoff = function () {\n        var backoff = new ExponentialDelay(this.logger, this.maxBackOffTime, this.options.initialRetryDelayMs);\n        this.backoffs[backoff.id] = backoff;\n        return backoff;\n    };\n    RegistrarClient.prototype.stopBackoff = function (backoff) {\n        backoff.cancel();\n        delete this.backoffs[backoff.id];\n    };\n    RegistrarClient.prototype.getToken = function (claimsChallenge) {\n        return __awaiter(this, void 0, void 0, function () {\n            var backoff, retryCount, token, error_1, stringfiedError, err, cancelError_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        backoff = this.startBackoff();\n                        retryCount = 0;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 8]);\n                        this.logger.info('[RegistrarClient] Asking for a new token');\n                        return [4 /*yield*/, this.tokenProvider({\n                                needFresh: true,\n                                supportedTokenTypes: SUPPORTED_TOKEN_TYPES,\n                                wwwAuthenticateHeader: claimsChallenge,\n                                purpose: 'registrar'\n                            })];\n                    case 2:\n                        token = _a.sent();\n                        this.stopBackoff(backoff);\n                        return [2 /*return*/, token];\n                    case 3:\n                        error_1 = _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        _a.trys.push([4, 6, , 7]);\n                        retryCount++;\n                        stringfiedError = JSON.stringify(error_1);\n                        if (retryCount > this.maxRetriesForGetToken) {\n                            err = \"[RegistrarClient] getToken retry limit hit. Will not retry now. Error: \".concat(stringfiedError);\n                            this.logger.error(err);\n                            this.stopBackoff(backoff);\n                            return [2 /*return*/, Promise.reject(err)];\n                        }\n                        this.logger.warn(\"[RegistrarClient] Retrying for a new token. Retry Count: \".concat(retryCount, \" Error: \").concat(stringfiedError));\n                        return [4 /*yield*/, backoff.delay('Fetching a new token')];\n                    case 5:\n                        _a.sent();\n                        return [3 /*break*/, 8];\n                    case 6:\n                        cancelError_1 = _a.sent();\n                        this.stopBackoff(backoff);\n                        throw cancelError_1;\n                    case 7: return [3 /*break*/, 8];\n                    case 8: return [3 /*break*/, 1];\n                    case 9: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    RegistrarClient.prototype.callRegistrar = function (request, eventName) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function () {\n            var backoff, cachedToken, stopwatch, retryCount, response, req, err, claimsChallenge, _d, _e, error_2, canceledError_1, details, _f, _g, error_3, message;\n            return __generator(this, function (_h) {\n                switch (_h.label) {\n                    case 0:\n                        backoff = this.startBackoff();\n                        return [4 /*yield*/, this.tokenProvider({\n                                needFresh: false,\n                                supportedTokenTypes: SUPPORTED_TOKEN_TYPES,\n                                wwwAuthenticateHeader: undefined,\n                                purpose: 'registrar'\n                            })];\n                    case 1:\n                        cachedToken = _h.sent();\n                        this.setTokenHeader(request, cachedToken);\n                        stopwatch = new Common_1.Timespan();\n                        retryCount = 0;\n                        _h.label = 2;\n                    case 2:\n                        response = void 0;\n                        _h.label = 3;\n                    case 3:\n                        _h.trys.push([3, 10, 15, 16]);\n                        req = request.clone();\n                        return [4 /*yield*/, (0, Common_1.fetchWithTimeout)(req, this.options.requestTimeoutMs)];\n                    case 4:\n                        response = _h.sent();\n                        if (!(response.status === 401)) return [3 /*break*/, 8];\n                        retryCount++;\n                        if (retryCount > this.maxRetriesForGetToken) {\n                            err = \"[RegistrarClient] getSkypeToken retry limit hit. Will not retry now. Request '\".concat(request.url, \"' failed with \").concat(response.status, \" \").concat(response.statusText);\n                            this.logger.error(err);\n                            this.stopBackoff(backoff);\n                            return [2 /*return*/, Promise.reject(err)];\n                        }\n                        this.logger.warn(\"[RegistrarClient] Retry Count \".concat(retryCount, \". Request '\").concat(request.url, \"' failed with \").concat(response.status, \" \").concat(response.statusText));\n                        claimsChallenge = (_b = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get('www-authenticate')) !== null && _b !== void 0 ? _b : undefined;\n                        _d = this.setTokenHeader;\n                        _e = [request];\n                        return [4 /*yield*/, this.getToken(claimsChallenge)];\n                    case 5:\n                        _d.apply(this, _e.concat([_h.sent()]));\n                        if (!(retryCount > 1)) return [3 /*break*/, 7];\n                        // for later retries, e.g. with token revocation, wait until SEAL knows the token was revoked,\n                        // so that proper claims challenges are sent, see https://skype.visualstudio.com/SCC/_workitems/edit/3337904/\n                        return [4 /*yield*/, backoff.delay('Registrar call retry after 401')];\n                    case 6:\n                        // for later retries, e.g. with token revocation, wait until SEAL knows the token was revoked,\n                        // so that proper claims challenges are sent, see https://skype.visualstudio.com/SCC/_workitems/edit/3337904/\n                        _h.sent();\n                        _h.label = 7;\n                    case 7: return [3 /*break*/, 22];\n                    case 8:\n                        if (response.status >= 500 && response.status < 600) {\n                            // throw and retry after in the catch section\n                            throw new Error(\"Fetch for '\".concat(request.url, \"' failed with \").concat(response.status, \" \").concat(response.statusText));\n                        }\n                        _h.label = 9;\n                    case 9: return [3 /*break*/, 16];\n                    case 10:\n                        error_2 = _h.sent();\n                        this.logger.error(\"[RegistrarClient] Request failed with \".concat(error_2));\n                        _h.label = 11;\n                    case 11:\n                        _h.trys.push([11, 13, , 14]);\n                        // retry on network errors (thrown by fetch) and retryable codes\n                        return [4 /*yield*/, backoff.delay('Registrar call retry')];\n                    case 12:\n                        // retry on network errors (thrown by fetch) and retryable codes\n                        _h.sent();\n                        return [3 /*break*/, 22];\n                    case 13:\n                        canceledError_1 = _h.sent();\n                        this.logger.error('[RegistrarClient] Request cancelled');\n                        this.stopBackoff(backoff);\n                        throw canceledError_1;\n                    case 14: return [3 /*break*/, 16];\n                    case 15:\n                        this.sendTelemetryEvent(eventName, request, response, stopwatch);\n                        return [7 /*endfinally*/];\n                    case 16:\n                        this.stopBackoff(backoff);\n                        if (!response.ok) return [3 /*break*/, 17];\n                        return [2 /*return*/, response];\n                    case 17:\n                        details = void 0;\n                        _h.label = 18;\n                    case 18:\n                        _h.trys.push([18, 20, , 21]);\n                        _g = (_f = JSON).stringify;\n                        return [4 /*yield*/, response.json()];\n                    case 19:\n                        details = _g.apply(_f, [_h.sent()]);\n                        return [3 /*break*/, 21];\n                    case 20:\n                        error_3 = _h.sent();\n                        details = 'no details';\n                        return [3 /*break*/, 21];\n                    case 21:\n                        message = \"Fetch for '\".concat(request.url, \"' failed with \").concat(response.status, \" \").concat(response.statusText, \" (\").concat(details, \", MS-CV: \").concat((_c = response.headers) === null || _c === void 0 ? void 0 : _c.get('MS-CV'), \")\");\n                        this.logger.error(\"[RegistrarClient] \".concat(message));\n                        throw new Error(message);\n                    case 22: return [3 /*break*/, 2];\n                    case 23: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    RegistrarClient.prototype.setTokenHeader = function (request, token) {\n        // Because a request object is cloned on 401 retries, we need to reset the state to baseline\n        request.headers.delete('X-Skypetoken');\n        request.headers.delete('Authorization');\n        request.headers.delete('X-MS-Migration');\n        switch (token.tokenType.toLowerCase()) {\n            case 'skype':\n                request.headers.set('X-Skypetoken', token.token);\n                break;\n            case 'aad':\n            case 'cae':\n                request.headers.set('Authorization', \"Bearer \".concat(token.token));\n                break;\n            default:\n                throw new Error(\"unsupported token type: \".concat(token.tokenType));\n        }\n        if (this.options.usingLegacyTokenApi === false) {\n            request.headers.set('X-MS-Migration', 'True');\n        }\n    };\n    RegistrarClient.prototype.sendTelemetryEvent = function (eventName, request, response, stopwatch) {\n        if (this.eventLogger === undefined) {\n            return;\n        }\n        var clientEvent = {\n            name: eventName,\n            properties: {\n                url: { value: request.url },\n                result_code: { value: response !== undefined ? response.status : 0 },\n                begin_timestamp: { value: stopwatch.startTime },\n                elapsed: { value: stopwatch.duration }\n            }\n        };\n        this.eventLogger.logEvent(clientEvent);\n    };\n    return RegistrarClient;\n}());\nexports.RegistrarClient = RegistrarClient;\nfunction createRegistrarClient(logProvider, tokenProvider, options) {\n    return new RegistrarClient(logProvider, tokenProvider, options);\n}\nexports.createRegistrarClient = createRegistrarClient;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// tsregistrar.js","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\n/** Wrapper to send request with specified timeout */\r\nexport function fetchWithTimeout(request: Request, timeoutMs: number): Promise<Response> {\r\n    let timeoutId: Timeout | undefined;\r\n    const fetchPromise = new Promise<Response>((resolve, reject) => {\r\n        fetch(request).then((response) => {\r\n            if (timeoutId !== undefined) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            resolve(response);\r\n        }).catch((error) => {\r\n            if (timeoutId !== undefined) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            reject(error);\r\n        });\r\n    });\r\n    if (timeoutMs !== 0) {\r\n        const timeoutPromise = new Promise<Response>((resolve, reject) => {\r\n            timeoutId = setTimeout(reject, timeoutMs, new Error(`Fetch for '${request.url}' timed out`));\r\n          });\r\n\r\n        return Promise.race([fetchPromise, timeoutPromise]);\r\n    }\r\n\r\n    return fetchPromise;\r\n}\r\n\r\nexport function toJson(obj: unknown): string {\r\n    try {\r\n        return JSON.stringify(obj);\r\n    } catch (error) {\r\n        return `Unable to serialize object of type ${typeof obj}`;\r\n    }\r\n}\r\n\r\n/**\r\n * Simplify calculation of time intervals\r\n */\r\nexport class Timespan {\r\n    private start: number;\r\n\r\n    constructor() {\r\n        this.start = Date.now();\r\n    }\r\n\r\n    /**\r\n     * Returns number of milliseconds from start\r\n     */\r\n    public get duration(): number {\r\n        return Date.now() - this.start;\r\n    }\r\n\r\n    /**\r\n     * Returns start time\r\n     */\r\n    public get startTime() {\r\n        return this.start;\r\n    }\r\n\r\n    /**\r\n     * Reset start of interval to current timestamp\r\n     */\r\n    public reset() {\r\n        this.start = Date.now();\r\n    }\r\n}\r\n\r\n// Browser vs. @types/node compatibility - browser (where the client is mainly used) uses `number` as return type of setTimeout,\r\n// node.js (where the tests run) uses its own type.\r\nexport type Timeout = ReturnType<typeof setTimeout>;\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/Common.ts","import { fetchWithTimeout, Timeout, Timespan, toJson } from './Common';\r\nimport { AuthTokenProvider, IClientDescription, IRegistrarClient, IRegistrarClientOptions, ITelemetrySender,\r\n         ITransports, IUrlRewrite, LogProvider, TelemetryEvent, TokenResult } from './Interfaces';\r\n\r\nconst SUPPORTED_TOKEN_TYPES = <const>['skype', 'aad', 'cae'];\r\n\r\n/**\r\n * Thrown when retry process was cancelled\r\n */\r\nclass CancelationError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = 'CancelationError';\r\n    }\r\n}\r\n\r\n/**\r\n * Randomized exponential delay used for retries\r\n */\r\nclass ExponentialDelay {\r\n    private static idCounter: number = 0;\r\n\r\n    public readonly id: number;\r\n\r\n    private backoffCount: number = 0;\r\n    private timerHandle?: Timeout;\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    private cancelFunc: ((err?: any) => void) | undefined;\r\n\r\n    public constructor(\r\n        private logger: LogProvider,\r\n        private maxBackoffInMs: number,\r\n        private initialDelay: number\r\n    ) {\r\n        this.id = ++ExponentialDelay.idCounter;\r\n    }\r\n\r\n    public delay(taskName: string): Promise<void> {\r\n        if (this.timerHandle !== undefined) {\r\n            throw new Error('Retry sequence logical failure');\r\n        }\r\n\r\n        if (this.backoffCount === -1) {\r\n            return new Promise((resolve, reject) => { reject(new CancelationError('Cancelled')); });\r\n        }\r\n\r\n        const backoffMs = this.calculateNextBackoffMs();\r\n        this.backoffCount++;\r\n        this.logger.info(`[RegistrarClient] Backing off ${taskName} for ${backoffMs} milliseconds with ID ${this.id}`);\r\n\r\n        return new Promise( (resolve, reject) => {\r\n            this.cancelFunc = reject;\r\n            this.timerHandle = setTimeout(() => {\r\n                this.logger.info(`[RegistrarClient] Back off for ${taskName} with ID ${this.id} complete`);\r\n                this.timerHandle = undefined;\r\n                resolve();\r\n            }, backoffMs);\r\n        });\r\n    }\r\n\r\n    public cancel(): void {\r\n        if (this.timerHandle !== undefined) {\r\n            this.logger.debug('Resetting back off');\r\n            clearTimeout(this.timerHandle);\r\n            if (this.cancelFunc !== undefined) {\r\n                this.cancelFunc(new CancelationError('Cancelled'));\r\n            }\r\n        }\r\n        this.backoffCount = -1;\r\n    }\r\n\r\n    private calculateNextBackoffMs(): number {\r\n        const fudge = 1 + (Math.random() - 0.5) * 0.4; // +/- 20%\r\n        let backoff = this.initialDelay * Math.pow(2, this.backoffCount) * fudge;\r\n        backoff = Math.round(backoff);\r\n\r\n        return Math.min(this.maxBackoffInMs, backoff);\r\n    }\r\n}\r\n\r\n/**\r\n * Registrar client implementation\r\n */\r\nexport class RegistrarClient implements IRegistrarClient {\r\n    private backoffs: { [id: string]: ExponentialDelay };\r\n    private eventLogger?: ITelemetrySender;\r\n    private cachedRegistrationParams?: [IClientDescription, ITransports];\r\n    private maxBackOffTime: number;\r\n    private maxRetriesForGetToken: number;\r\n    private readonly DEFAULT_MAX_RETRIES_FOR_GET_TOKEN = 15;\r\n    private readonly proxyUrlRewrite: IUrlRewrite;\r\n\r\n    // Default value for maximum backoff between retries\r\n    private readonly DEFAULT_MAX_BACKOFF_TIME_IN_MS = 300000; // 5 minutes\r\n\r\n    constructor(\r\n        private logger: LogProvider,\r\n        private tokenProvider: AuthTokenProvider,\r\n        private options: IRegistrarClientOptions\r\n    ) {\r\n        this.backoffs = {};\r\n        this.maxBackOffTime =\r\n          this.options.maxRetryDelayMs > 0\r\n            ? this.options.maxRetryDelayMs\r\n            : this.DEFAULT_MAX_BACKOFF_TIME_IN_MS;\r\n        this.maxRetriesForGetToken =\r\n          options.maxRetriesForGetToken === undefined ||\r\n          options.maxRetriesForGetToken === null\r\n            ? this.DEFAULT_MAX_RETRIES_FOR_GET_TOKEN\r\n            : options.maxRetriesForGetToken;\r\n        this.proxyUrlRewrite = options.proxyUrlRewrite ?? (url => url);\r\n    }\r\n\r\n    public setTelemetryLogger(eventLogger: ITelemetrySender) {\r\n        this.eventLogger = eventLogger;\r\n    }\r\n\r\n    public async register(client: IClientDescription, transports: ITransports): Promise<void> {\r\n        await this.performRegistration(client, transports, 'pr_set_registration');\r\n        this.cachedRegistrationParams = [client, transports];\r\n    }\r\n\r\n    public async unregister(): Promise<void> {\r\n        this.logger.info('[RegistrarClient] sending unregister request');\r\n\r\n        const unregisterRequest = new Request(\r\n            this.proxyUrlRewrite(`${this.options.registrarUrl}/${this.options.registrationId}`),\r\n            {\r\n                method: 'DELETE',\r\n                mode: 'cors',\r\n                headers: new Headers({\r\n                    ...this.options.extraRegistrationHeaders,\r\n                    accept: 'application/json, text/javascript'\r\n                })\r\n            });\r\n\r\n            await this.callRegistrar(unregisterRequest, 'pr_delete_registration');\r\n    }\r\n\r\n    public cancelPendingRequests() {\r\n        Object.keys(this.backoffs).forEach((id: string) => {\r\n            this.backoffs[id].cancel();\r\n        });\r\n        this.backoffs = {};\r\n    }\r\n\r\n    public async resendRegistration(): Promise<void> {\r\n        if (!this.cachedRegistrationParams) {\r\n            throw new Error('Re-registration failed because there is no registration parameters cached');\r\n        }\r\n\r\n        await this.performRegistration(this.cachedRegistrationParams[0], this.cachedRegistrationParams[1], 'pr_resend_registration');\r\n    }\r\n\r\n    private async performRegistration(client: IClientDescription, transports: ITransports, eventName: string) {\r\n        this.logger.info('[RegistrarClient] Sending register request');\r\n        const payload = {\r\n            clientDescription: client,\r\n            registrationId: this.options.registrationId,\r\n            nodeId: '',\r\n            transports: transports\r\n        };\r\n        const registerRequest = new Request(this.proxyUrlRewrite(this.options.registrarUrl), {\r\n            method: 'POST',\r\n            mode: 'cors',\r\n            headers: new Headers({\r\n                ...this.options.extraRegistrationHeaders,\r\n                'content-type': 'application/json',\r\n                accept: 'application/json, text/javascript'\r\n            }),\r\n            body: toJson(payload)\r\n        });\r\n        await this.callRegistrar(registerRequest, eventName);\r\n    }\r\n\r\n    private startBackoff() {\r\n        const backoff = new ExponentialDelay(\r\n          this.logger,\r\n          this.maxBackOffTime,\r\n          this.options.initialRetryDelayMs\r\n        );\r\n        this.backoffs[backoff.id] = backoff;\r\n\r\n        return backoff;\r\n    }\r\n\r\n    private stopBackoff(backoff: ExponentialDelay) {\r\n        backoff.cancel();\r\n        delete this.backoffs[backoff.id];\r\n    }\r\n\r\n    private async getToken(claimsChallenge: string|undefined): Promise<TokenResult> {\r\n        const backoff = this.startBackoff();\r\n        let retryCount = 0;\r\n        for (;;) {\r\n            try {\r\n                this.logger.info('[RegistrarClient] Asking for a new token');\r\n                const token = await this.tokenProvider({\r\n                    needFresh: true,\r\n                    supportedTokenTypes: SUPPORTED_TOKEN_TYPES,\r\n                    wwwAuthenticateHeader: claimsChallenge,\r\n                    purpose: 'registrar'\r\n                });\r\n                this.stopBackoff(backoff);\r\n\r\n                return token;\r\n            } catch (error) {\r\n                try {\r\n                    retryCount++;\r\n                    const stringfiedError = JSON.stringify(error);\r\n                    if (retryCount > this.maxRetriesForGetToken) {\r\n                        const err = `[RegistrarClient] getToken retry limit hit. Will not retry now. Error: ${stringfiedError}`;\r\n                        this.logger.error(err);\r\n                        this.stopBackoff(backoff);\r\n\r\n                        return Promise.reject(err);\r\n                    }\r\n\r\n                    this.logger.warn(`[RegistrarClient] Retrying for a new token. Retry Count: ${retryCount} Error: ${stringfiedError}`);\r\n                    await backoff.delay('Fetching a new token');\r\n                    continue;\r\n                } catch (cancelError) {\r\n                    this.stopBackoff(backoff);\r\n                    throw cancelError;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private async callRegistrar(request: Request, eventName: string): Promise<Response> {\r\n        const backoff = this.startBackoff();\r\n\r\n        const cachedToken = await this.tokenProvider({\r\n            needFresh: false,\r\n            supportedTokenTypes: SUPPORTED_TOKEN_TYPES,\r\n            wwwAuthenticateHeader: undefined,\r\n            purpose: 'registrar'\r\n        });\r\n        this.setTokenHeader(request, cachedToken);\r\n\r\n        const stopwatch = new Timespan();\r\n        let retryCount = 0;\r\n\r\n        for (;;) {\r\n            let response: Response | undefined;\r\n            try {\r\n                // Make a clone in case we need to retry, one Request cannot be used twice with fetch()\r\n                const req = request.clone();\r\n                response = await fetchWithTimeout(req, this.options.requestTimeoutMs);\r\n                if (response.status === 401) {\r\n                    retryCount++;\r\n                    if (retryCount > this.maxRetriesForGetToken) {\r\n                        const err = `[RegistrarClient] getSkypeToken retry limit hit. Will not retry now. Request '${request.url}' failed with ${response.status} ${response.statusText}`;\r\n                        this.logger.error(err);\r\n                        this.stopBackoff(backoff);\r\n\r\n                        return Promise.reject(err);\r\n                    }\r\n\r\n                    this.logger.warn(`[RegistrarClient] Retry Count ${retryCount}. Request '${request.url}' failed with ${response.status} ${response.statusText}`);\r\n                    const claimsChallenge = response.headers?.get('www-authenticate') ?? undefined;\r\n                    this.setTokenHeader(request, await this.getToken(claimsChallenge));\r\n                    // do not wait the first time - quick reaction to e.g. expired token\r\n                    if (retryCount > 1) {\r\n                        // for later retries, e.g. with token revocation, wait until SEAL knows the token was revoked,\r\n                        // so that proper claims challenges are sent, see https://skype.visualstudio.com/SCC/_workitems/edit/3337904/\r\n                        await backoff.delay('Registrar call retry after 401');\r\n                    }\r\n                    continue;\r\n                } else if (response.status >= 500 && response.status < 600) {\r\n                    // throw and retry after in the catch section\r\n                    throw new Error(`Fetch for '${request.url}' failed with ${response.status} ${response.statusText}`);\r\n                }\r\n            } catch (error) {\r\n                this.logger.error(`[RegistrarClient] Request failed with ${error}`);\r\n                try {\r\n                    // retry on network errors (thrown by fetch) and retryable codes\r\n                    await backoff.delay('Registrar call retry');\r\n                    continue;\r\n                } catch (canceledError) {\r\n                    this.logger.error('[RegistrarClient] Request cancelled');\r\n                    this.stopBackoff(backoff);\r\n                    throw canceledError;\r\n                }\r\n            } finally {\r\n                this.sendTelemetryEvent(eventName, request, response, stopwatch);\r\n            }\r\n\r\n            this.stopBackoff(backoff);\r\n            if (response.ok) {\r\n                return response;\r\n            } else  {\r\n                let details: string;\r\n                try {\r\n                    details = JSON.stringify(await response.json());\r\n                } catch (error) {\r\n                    details = 'no details';\r\n                }\r\n                // Note MS-CV will be null until Registrar service CORS fix\r\n                // https://dev.azure.com/skype/SCC/_workitems/edit/2353812\r\n                const message = `Fetch for '${request.url}' failed with ${response.status} ${response.statusText} (${details}, MS-CV: ${response.headers?.get('MS-CV')})`;\r\n                this.logger.error(`[RegistrarClient] ${message}`);\r\n                throw new Error(message);\r\n            }\r\n        }\r\n    }\r\n\r\n    private setTokenHeader(request: Request, token: TokenResult) {\r\n        // Because a request object is cloned on 401 retries, we need to reset the state to baseline\r\n        request.headers.delete('X-Skypetoken');\r\n        request.headers.delete('Authorization');\r\n        request.headers.delete('X-MS-Migration');\r\n\r\n        switch (token.tokenType.toLowerCase()) {\r\n            case 'skype':\r\n                request.headers.set('X-Skypetoken', token.token);\r\n                break;\r\n\r\n            case 'aad':\r\n            case 'cae':\r\n                request.headers.set('Authorization', `Bearer ${token.token}`);\r\n                break;\r\n\r\n            default:\r\n                throw new Error(`unsupported token type: ${token.tokenType}`);\r\n        }\r\n        if (this.options.usingLegacyTokenApi === false) {\r\n            request.headers.set('X-MS-Migration', 'True');\r\n        }\r\n    }\r\n\r\n    private sendTelemetryEvent(eventName: string, request: Request, response: Response | undefined, stopwatch: Timespan) {\r\n        if (this.eventLogger === undefined) {\r\n            return;\r\n        }\r\n\r\n        const clientEvent: TelemetryEvent = {\r\n            name: eventName,\r\n            properties: {\r\n                url: { value: request.url },\r\n                result_code: { value: response !== undefined ? response.status : 0 },\r\n                begin_timestamp: { value: stopwatch.startTime },\r\n                elapsed: { value: stopwatch.duration }\r\n            }\r\n        };\r\n\r\n        this.eventLogger.logEvent(clientEvent);\r\n    }\r\n}\r\n\r\nexport function createRegistrarClient(\r\n    logProvider: LogProvider,\r\n    tokenProvider: AuthTokenProvider,\r\n    options: IRegistrarClientOptions\r\n): IRegistrarClient {\r\n    return new RegistrarClient(logProvider, tokenProvider, options);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/RegistrarClient.ts","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@skype/tsregistrar\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"@skype/tstrouter\", [\"@skype/tsregistrar\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@skype/tstrouter\"] = factory(require(\"@skype/tsregistrar\"));\n\telse\n\t\troot[\"@skype/tstrouter\"] = factory(root[\"@skype/tsregistrar\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_21__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 20);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b8d066f6f21edf895ca2","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@skype/tsregistrar\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"@skype/tstrouter\", [\"@skype/tsregistrar\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@skype/tstrouter\"] = factory(require(\"@skype/tsregistrar\"));\n\telse\n\t\troot[\"@skype/tstrouter\"] = factory(root[\"@skype/tsregistrar\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_21__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 20);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Logger = void 0;\n/**\n * Simple logger\n */\nvar Logger = /** @class */ (function () {\n    function Logger(name, logger) {\n        this.name = name;\n        this.logger = logger;\n    }\n    Logger.prototype.debug = function (message) {\n        this.logger.debug(\"[\".concat(this.name, \"] \").concat(message));\n    };\n    Logger.prototype.info = function (message) {\n        this.logger.info(\"[\".concat(this.name, \"] \").concat(message));\n    };\n    Logger.prototype.warn = function (message) {\n        this.logger.warn(\"[\".concat(this.name, \"] \").concat(message));\n    };\n    Logger.prototype.error = function (message) {\n        this.logger.error(\"[\".concat(this.name, \"] \").concat(message));\n    };\n    return Logger;\n}());\nexports.Logger = Logger;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.USER_AUTHENTICATE_EVENT_NAME = exports.SUPPORTED_TOKEN_TYPES = exports.FAILED_MESSAGE_ACK = exports.UNHANDLED_MESSAGE_ACK = exports.HANDLED_MESSAGE_ACK = exports.CLIENT_VERSION = exports.constants = void 0;\nexports.constants = {\n    TROUTER_INIT: 'trouterinit',\n    TROUTER_READY_EVENT: 'trouterReadyEvent',\n    TROUTER_READY_TIMEOUT: 'trouterReadyTimeout',\n    TROUTER_TOKEN_REQUEST: 'trouterTokenRequest',\n    TROUTER_TOKEN_GET_SUCCEEDED: 'trouterTokenGetSucceeded',\n    TROUTER_TOKEN_GET_FAILED: 'trouterTokenGetFailed',\n    TROUTER_RECONNECTING: 'trouterReconnecting',\n    RENEWAL: 'renewal',\n    NEW_CONNECTION: 'newConnection',\n    ENDPOINT_REGISTRATION_FAILED: 'endpointRegistrationFailed'\n};\nexports.CLIENT_VERSION = '2024.14.01.55';\nexports.HANDLED_MESSAGE_ACK = 200;\nexports.UNHANDLED_MESSAGE_ACK = 404;\nexports.FAILED_MESSAGE_ACK = 500;\nexports.SUPPORTED_TOKEN_TYPES = ['skype', 'aad', 'cae'];\nexports.USER_AUTHENTICATE_EVENT_NAME = 'user.authenticate';\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n * Type definitions for Trouter JavaScript Client 2024.14.01.55\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrouterState = exports.UserActivityState = void 0;\n/**\n * States that a user can reach\n *\n * Use with the `setUserActivityState()` method.\n */\nvar UserActivityState;\n(function (UserActivityState) {\n    UserActivityState[UserActivityState[\"Unknown\"] = 0] = \"Unknown\";\n    UserActivityState[UserActivityState[\"Active\"] = 1] = \"Active\";\n    UserActivityState[UserActivityState[\"Inactive\"] = 2] = \"Inactive\"; /// User is not active according to the application\n})(UserActivityState || (exports.UserActivityState = UserActivityState = {}));\nvar TrouterState;\n(function (TrouterState) {\n    /** Initial state */\n    TrouterState[TrouterState[\"Unknown\"] = 0] = \"Unknown\";\n    /** ready to work */\n    TrouterState[TrouterState[\"Connected\"] = 2] = \"Connected\";\n    /**\n     * waiting for 'connected' event\n     * Might also be in Terminal State. Users should call `isInTerminalState` to check.\n     * For legacy reasons, we cannot change the TrouterState enum any longer.\n     */\n    TrouterState[TrouterState[\"Disconnected\"] = 3] = \"Disconnected\";\n    /** waiting for 'register' from second connection */\n    TrouterState[TrouterState[\"Switching\"] = 9] = \"Switching\";\n})(TrouterState || (exports.TrouterState = TrouterState = {}));\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Timespan = exports.CorrelationVector = exports.fetchWithTimeout = exports.calculateExpireTsInSec = exports.calculateTtlInSec = exports.toJson = void 0;\nfunction toJson(obj) {\n    try {\n        return JSON.stringify(obj);\n    }\n    catch (error) {\n        return \"Unable to serialize object of type \".concat(typeof obj);\n    }\n}\nexports.toJson = toJson;\nfunction calculateTtlInSec(expirationTsInSec) {\n    var now = Math.round(new Date().getTime() / 1000);\n    return expirationTsInSec !== undefined && expirationTsInSec > now\n        ? expirationTsInSec - now\n        : 0;\n}\nexports.calculateTtlInSec = calculateTtlInSec;\nfunction calculateExpireTsInSec(ttlInSec) {\n    return Math.round(new Date().getTime() / 1000) + ttlInSec;\n}\nexports.calculateExpireTsInSec = calculateExpireTsInSec;\n/** Wrapper to send request with specified timeout */\nfunction fetchWithTimeout(request, timeoutMs) {\n    return __awaiter(this, void 0, void 0, function () {\n        var timeoutId, fetchPromise, timeoutPromise;\n        return __generator(this, function (_a) {\n            fetchPromise = new Promise(function (resolve, reject) {\n                fetch(request).then(function (response) {\n                    clearTimeout(timeoutId);\n                    resolve(response);\n                }).catch(function (error) {\n                    clearTimeout(timeoutId);\n                    reject(error);\n                });\n            });\n            if (timeoutMs !== 0) {\n                timeoutPromise = new Promise(function (resolve, reject) {\n                    // We make a compromise on how much information to show in the error message.\n                    // Having the URL there is useful, but including any query parameters is both\n                    // cumbersome (millions of different errors in telemetry) and unsafe (secret\n                    // fields that would need to be redacted). \"Origin\" and \"pathname\" achieve that.\n                    var url = new URL(request.url);\n                    var error = new Error(\"\".concat(request.method, \" \").concat(url.origin).concat(url.pathname, \" timed out\"));\n                    timeoutId = setTimeout(reject, timeoutMs, error);\n                });\n                return [2 /*return*/, Promise.race([fetchPromise, timeoutPromise])];\n            }\n            return [2 /*return*/, fetchPromise];\n        });\n    });\n}\nexports.fetchWithTimeout = fetchWithTimeout;\n/***\n * Correlation vector\n */\nvar CorrelationVector = /** @class */ (function () {\n    function CorrelationVector(correlationVector) {\n        this.base = (correlationVector !== undefined) ? correlationVector : this.createCorrelationVectorBase();\n        this.extension = 0;\n    }\n    CorrelationVector.extend = function (correlationVector) {\n        return new CorrelationVector(correlationVector);\n    };\n    CorrelationVector.prototype.increase = function () {\n        this.extension++;\n    };\n    CorrelationVector.prototype.value = function () {\n        return \"\".concat(this.base, \".\").concat(this.extension);\n    };\n    CorrelationVector.prototype.createCorrelationVectorBase = function () {\n        var length = 21;\n        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0987654321/+';\n        var endChars = 'AQgw';\n        var result = '';\n        for (var i = 0; i < length; i++) {\n            result += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        result += endChars.charAt(Math.floor(Math.random() * endChars.length));\n        return result;\n    };\n    return CorrelationVector;\n}());\nexports.CorrelationVector = CorrelationVector;\n/**\n * Simplify calculation of time intervals\n */\nvar Timespan = /** @class */ (function () {\n    function Timespan() {\n        this.start = Date.now();\n    }\n    Object.defineProperty(Timespan.prototype, \"duration\", {\n        /**\n         * Returns number of milliseconds from start\n         */\n        get: function () {\n            return Date.now() - this.start;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Timespan.prototype, \"startTime\", {\n        /**\n         * Returns start time\n         */\n        get: function () {\n            return this.start;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Reset start of interval to current timestamp\n     */\n    Timespan.prototype.reset = function () {\n        this.start = Date.now();\n    };\n    return Timespan;\n}());\nexports.Timespan = Timespan;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n * Internal type definitions for Trouter JavaScript Client\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrouterManagerState = exports.UserActivityEventReason = exports.ServerState = void 0;\nvar Common_1 = __webpack_require__(3);\n/**\n * Information about server connection\n */\nvar ServerState = /** @class */ (function () {\n    function ServerState(\n    /** Trouter client connection ID */\n    connectionId, \n    /** Trouter client connected client ID */\n    connectedClientId, \n    /** window.location.hostname */\n    domId, \n    /** Unsecure Trouter url at which client can be reached */\n    unsecureUrl, \n    /** Secure Trouter url at which client can be reached */\n    url, \n    /** URL base to use for client-to-client requests */\n    c2cUrlBase, \n    /** expiration timestamp for connection in seconds */\n    expirationTsSec) {\n        this.connectionId = connectionId;\n        this.connectedClientId = connectedClientId;\n        this.domId = domId;\n        this.unsecureUrl = unsecureUrl;\n        this.url = url;\n        this.c2cUrlBase = c2cUrlBase;\n        this.expirationTsSec = expirationTsSec;\n    }\n    /** Return connection TTL, i.e. number of seconds till expiration */\n    ServerState.prototype.getRemainingTtlInSec = function () {\n        return (0, Common_1.calculateTtlInSec)(this.expirationTsSec);\n    };\n    return ServerState;\n}());\nexports.ServerState = ServerState;\nvar UserActivityEventReason;\n(function (UserActivityEventReason) {\n    UserActivityEventReason[UserActivityEventReason[\"Unknown\"] = 0] = \"Unknown\";\n    UserActivityEventReason[UserActivityEventReason[\"Modified\"] = 1] = \"Modified\";\n    UserActivityEventReason[UserActivityEventReason[\"Snapshot\"] = 2] = \"Snapshot\";\n    UserActivityEventReason[UserActivityEventReason[\"Connected\"] = 3] = \"Connected\";\n})(UserActivityEventReason || (exports.UserActivityEventReason = UserActivityEventReason = {}));\n/**\n * Duplicating TrouterState since too many parts of SCC depend on it for us to change it internally.\n * Don't expose this to the outside world, to avoid another repeat of this issue.\n */\nvar TrouterManagerState;\n(function (TrouterManagerState) {\n    /** Initial state */\n    TrouterManagerState[TrouterManagerState[\"Unknown\"] = 0] = \"Unknown\";\n    /** ready to work */\n    TrouterManagerState[TrouterManagerState[\"Connected\"] = 2] = \"Connected\";\n    /** waiting for 'connected' event */\n    TrouterManagerState[TrouterManagerState[\"Disconnected\"] = 3] = \"Disconnected\";\n    /** waiting for 'register' from second connection */\n    TrouterManagerState[TrouterManagerState[\"Switching\"] = 9] = \"Switching\";\n    /** Unable to continue, in final state. */\n    TrouterManagerState[TrouterManagerState[\"TerminalError\"] = 10] = \"TerminalError\";\n})(TrouterManagerState || (exports.TrouterManagerState = TrouterManagerState = {}));\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.redirectUrlIfPresent = exports.ensureNumber = exports.reconnectParamsWithoutUrls = exports.adaptUrl = exports.isV4ConnectEvent = exports.usedProtocolAfterFallback = exports.usedProtocol = void 0;\nfunction usedProtocol(tokenType, reconnectParams) {\n    return (tokenType === 'skype' && safeToString(reconnectParams === null || reconnectParams === void 0 ? void 0 : reconnectParams.scae) !== '1') ? 'v4a' : 'v4c';\n}\nexports.usedProtocol = usedProtocol;\nfunction safeToString(value) {\n    if (typeof value === 'string') {\n        return value;\n    }\n    else if (typeof value === 'number') {\n        return value.toString();\n    }\n    return undefined;\n}\nfunction usedProtocolAfterFallback(protocol, fallbackReason) {\n    if ((fallbackReason === null || fallbackReason === void 0 ? void 0 : fallbackReason.kind) === 'v4c-websocket-failure') {\n        return 'v4a';\n    }\n    return protocol;\n}\nexports.usedProtocolAfterFallback = usedProtocolAfterFallback;\nfunction isV4ConnectEvent(args) {\n    return Object.prototype.hasOwnProperty.call(args, 'connectparams');\n}\nexports.isV4ConnectEvent = isV4ConnectEvent;\n/**\n * Needed because we want to have cache with reconnectUrl, serviceUrl working\n * independent of protocol (see IReconnectParameters and its uses)\n */\nfunction adaptUrl(url, protocol) {\n    if (protocol === 'v4a') {\n        // The insecure (http://, ws://) versions would only ever be used by a test application,\n        // the connection URL is normally determined by the consumer of the library.\n        // eslint-disable-next-line @microsoft/sdl/no-insecure-url\n        return url.replace(/\\/v4\\/c\\b/, '/v4/a').replace('wss://', 'https://').replace('ws://', 'http://');\n    }\n    else {\n        // eslint-disable-next-line @microsoft/sdl/no-insecure-url\n        return url.replace(/\\/v4\\/a\\b/, '/v4/c').replace('https://', 'wss://').replace('http://', 'ws://');\n    }\n}\nexports.adaptUrl = adaptUrl;\n/**\n * Unfortunately the pre-existing cache format doesn't separate connectparams into its own property so it could be easily sent back,\n * instead it manually removes `reconnectUrl` and `serviceUrl` and send everything else, so we need to do the same here\n */\nfunction reconnectParamsWithoutUrls(reconnectParams) {\n    if (reconnectParams === undefined) {\n        return undefined;\n    }\n    return __assign(__assign({}, reconnectParams), { reconnectUrl: undefined, serviceUrl: undefined });\n}\nexports.reconnectParamsWithoutUrls = reconnectParamsWithoutUrls;\nfunction ensureNumber(value) {\n    return typeof value === 'string' ? parseInt(value, 10) : value;\n}\nexports.ensureNumber = ensureNumber;\nfunction redirectUrlIfPresent(reason) {\n    if ((reason === null || reason === void 0 ? void 0 : reason.kind) !== 'redirect' || reason.host === undefined) {\n        return undefined;\n    }\n    var redirectHost = reason.host;\n    if (redirectHost.endsWith('/')) {\n        redirectHost = redirectHost.substring(0, redirectHost.length - 1);\n    }\n    if (!redirectHost.endsWith('/v4/c') && !redirectHost.endsWith('/v4/a')) {\n        redirectHost += '/v4/c';\n    }\n    return redirectHost;\n}\nexports.redirectUrlIfPresent = redirectUrlIfPresent;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrouterFsm = exports.State = void 0;\nvar InternalInterfaces_1 = __webpack_require__(4);\nvar Logger_1 = __webpack_require__(0);\nvar ProtocolAdapters_1 = __webpack_require__(5);\nvar State;\n(function (State) {\n    State[State[\"Initial\"] = 0] = \"Initial\";\n    /** waiting for token from User */\n    State[State[\"RetrievingToken\"] = 1] = \"RetrievingToken\";\n    /** waiting for allocation response from service */\n    State[State[\"Allocating\"] = 2] = \"Allocating\";\n    /**\n     * waiting for Socket.IO handshake to be finished. After that Socket.IO will\n     * start to try transports and send 'connecting' event\n     */\n    State[State[\"Handshaking\"] = 3] = \"Handshaking\";\n    /**\n     * waiting for 'connected' event - socket.io is trying different transports.\n     * onSocketError event should be ignored, as it's expected event. So, only ConnectFailed or\n     * connection timeout meas failed connection\n     */\n    State[State[\"Connecting\"] = 4] = \"Connecting\";\n    /**\n     * connecting to a websocket /v4/c URL\n     *\n     * this is the equivalent of the \"Allocating -> Handshaking -> Connecting\" chain\n     * from the /v4/a protocol\n     */\n    State[State[\"AnonymousConnecting\"] = 5] = \"AnonymousConnecting\";\n    /**\n     * connected to a websocket /v4/c URL, sending the authentication message,\n     * and waiting to receive a `trouter.connected` event back\n     */\n    State[State[\"WebsocketAuthenticating\"] = 6] = \"WebsocketAuthenticating\";\n    /** ready to work */\n    State[State[\"Connected\"] = 7] = \"Connected\";\n    /** waiting for a successful 'unregister' response */\n    State[State[\"Unregistering\"] = 8] = \"Unregistering\";\n    /**\n     * Unrecoverable state\n     * Trouter cannot start once in this state\n     */\n    State[State[\"TerminalError\"] = 9] = \"TerminalError\";\n})(State || (exports.State = State = {}));\nvar RegistrationState;\n(function (RegistrationState) {\n    RegistrationState[RegistrationState[\"Initial\"] = 0] = \"Initial\";\n    /** Waiting for a successful 'register' response */\n    RegistrationState[RegistrationState[\"Registering\"] = 1] = \"Registering\";\n    /** like the above, but another registration must happen when done because of resendRegistration() */\n    RegistrationState[RegistrationState[\"RegisteringButResendPending\"] = 2] = \"RegisteringButResendPending\";\n    /** Registration failed, waiting to retry */\n    RegistrationState[RegistrationState[\"Retrying\"] = 3] = \"Retrying\";\n    /** Registration succeeded */\n    RegistrationState[RegistrationState[\"Registered\"] = 4] = \"Registered\";\n    /** Registration is skipped */\n    RegistrationState[RegistrationState[\"RegistrationDisabled\"] = 5] = \"RegistrationDisabled\";\n})(RegistrationState || (RegistrationState = {}));\n/**\n * State machine for trouter\n */\nvar TrouterFsm = /** @class */ (function () {\n    function TrouterFsm(logfunc, worker, incallModeEnabled, protocolSelector) {\n        this.worker = worker;\n        this.incallModeEnabled = incallModeEnabled;\n        this.protocolSelector = protocolSelector;\n        this.state = State.Initial;\n        this.autoReconnect = true;\n        this.logger = new Logger_1.Logger('ConnectionFsm', logfunc);\n        this.registrationState = RegistrationState.Initial;\n    }\n    /** Returns current state */\n    TrouterFsm.prototype.getState = function () {\n        return this.state;\n    };\n    TrouterFsm.prototype.isActive = function () {\n        return this.state === State.Allocating\n            || this.state === State.Connected\n            || this.state === State.Handshaking\n            || this.state === State.Connecting\n            || this.state === State.RetrievingToken\n            || this.state === State.AnonymousConnecting\n            || this.state === State.WebsocketAuthenticating;\n    };\n    TrouterFsm.prototype.isConnecting = function () {\n        return this.state === State.Allocating\n            || this.state === State.Handshaking\n            || this.state === State.Connecting\n            || this.state === State.AnonymousConnecting;\n    };\n    //////////// Events ////////////\n    /**\n     * Start trouter\n     */\n    TrouterFsm.prototype.start = function () {\n        if (this.state === State.Initial) {\n            this.setState(State.RetrievingToken);\n            this.worker.getToken(true, false, undefined);\n            return true;\n        }\n        else {\n            this.showIgnored('start');\n            return false;\n        }\n    };\n    /**\n     * Stop trouter\n     * @param dontUnregister    if true, FSM will not unregister. It's needed in case of two simultaneous\n     *                          connections, to replace first connection with second - registrar just updates\n     *                          the existing record for the user, by registrationId (see their API docs),\n     *                          that id does not change during the lifetime of a TrouterService instance.\n     * @param isTerminalError   if true, FSM will transition into the terminal state\n     */\n    TrouterFsm.prototype.stop = function (dontUnregister, isTerminalError) {\n        if (dontUnregister) {\n            this.registrationState = RegistrationState.Initial;\n        }\n        if (this.worker.isIncallMode()) {\n            this.worker.exitIncallMode();\n        }\n        this.worker.resetTokenBackoff();\n        this.worker.cancelPendingRegistrationRequests();\n        this.worker.stopConnectionTimer();\n        this.worker.stopPingTimer();\n        this.worker.clearSentEventTimers();\n        this.worker.stopRegistrationTimer();\n        this.worker.stopSocketIo();\n        if (this.state === State.Connected) {\n            this.worker.sendDisconnectTelemetryEvent('connection stopped');\n        }\n        // Stop can happen in any state - the only difference is if registration exists or not.\n        // It can be also called a second time, just to stop a stuck unregistration.\n        if ((this.registrationState === RegistrationState.Registered\n            || this.registrationState === RegistrationState.Registering\n            || this.registrationState === RegistrationState.RegisteringButResendPending)\n            && this.state !== State.Unregistering) {\n            this.registrationState = RegistrationState.Initial;\n            this.setState(State.Unregistering);\n            this.worker.sendUnregisterRequest();\n        }\n        else {\n            if (isTerminalError) {\n                this.setState(State.TerminalError);\n                this.worker.dispatchTerminalError();\n            }\n            else {\n                this.setState(State.Initial);\n                this.worker.dispatchDisconnected();\n            }\n        }\n    };\n    TrouterFsm.prototype.onTokenReceived = function (token, reason, reconnectParams) {\n        if (this.state === State.RetrievingToken) {\n            if ((0, ProtocolAdapters_1.usedProtocolAfterFallback)(this.protocolSelector(token.tokenType, reconnectParams), reason) === 'v4c') {\n                this.setState(State.AnonymousConnecting);\n                this.worker.startConnectionTimer();\n                this.worker.connectV4c(token, reason);\n            }\n            else {\n                this.setState(State.Allocating);\n                this.worker.startConnectionTimer();\n                this.worker.sendAllocateRequest(token);\n            }\n        }\n        else {\n            this.showIgnored('onTokenReceived');\n        }\n    };\n    /**\n     * if disconnectDetected - need to send ping to check if connection is really dead,\n     * otherwise - network is available\n     */\n    TrouterFsm.prototype.checkConnection = function (disconnectDetected) {\n        if (disconnectDetected) {\n            this.onPingInterval();\n        }\n    };\n    /** Allocation request succeed with 200 */\n    TrouterFsm.prototype.onAllocationSucceed = function (token) {\n        // Call to dispatchUnregistered a little bit earlier takes into account the case when the state\n        // of the state machine can change inside the callback, for example if Trouter.stop() is called inside the callback.\n        if (this.state === State.Allocating && this.registrationState === RegistrationState.Registered) {\n            this.worker.dispatchUnregistered();\n        }\n        if (this.state === State.Allocating) {\n            this.setState(State.Handshaking);\n            this.registrationState = RegistrationState.Initial;\n            this.worker.startSocketIo(token);\n            return true;\n        }\n        else {\n            this.showIgnored('onAllocationSucceed');\n            return false;\n        }\n    };\n    /** Allocation request failed */\n    TrouterFsm.prototype.onAllocationFailed = function (unauthorized, claimsChallenge) {\n        if (this.state === State.Allocating) {\n            this.cleanUpAndInitiateReconnect({ backoff: true, allowCachedToken: !unauthorized, claimsChallenge: claimsChallenge });\n        }\n        else {\n            this.showIgnored('onAllocationFailed');\n        }\n    };\n    TrouterFsm.prototype.onV4cException = function () {\n        if (this.state === State.AnonymousConnecting || this.state === State.WebsocketAuthenticating) {\n            this.logger.error('v4c exception, falling back to longpoll');\n            this.cleanUpAndInitiateReconnect({ backoff: true, allowCachedToken: true, fallbackReason: { kind: 'v4c-websocket-failure' } });\n        }\n    };\n    /** Connection didn't succeed in given timeout */\n    TrouterFsm.prototype.onConnectingTimeout = function () {\n        // implementation note: this also called from onConnectingFailed\n        if (this.state === State.Allocating\n            || this.state === State.Connecting\n            || this.state === State.Handshaking\n            || this.state === State.AnonymousConnecting\n            || this.state === State.WebsocketAuthenticating) {\n            this.cleanUpAndInitiateReconnect({ backoff: false, allowCachedToken: true });\n        }\n        else {\n            this.showIgnored('onConnectingTimeout');\n        }\n    };\n    /** socket.io handshake succeed and socket.io is trying next transport */\n    TrouterFsm.prototype.onConnecting = function () {\n        if (this.state === State.Handshaking) {\n            this.setState(State.Connecting);\n        }\n        else {\n            this.showIgnored('onConnecting');\n        }\n    };\n    /** socket.io connected (1::), but trouter.connected event has not arrived yet */\n    TrouterFsm.prototype.onSocketConnect = function (token) {\n        if (this.state === State.AnonymousConnecting) {\n            this.setState(State.WebsocketAuthenticating);\n            this.worker.sendV4cAuthenticationEvent(token);\n        }\n        else {\n            this.showIgnored('onSocketConnect');\n        }\n    };\n    /** Socket.io connection wasn't established */\n    TrouterFsm.prototype.onConnectingFailed = function () {\n        // This callback will be called when all transports failed to connect, i.e. socket.io can't proceed\n        if (this.state === State.Connecting) {\n            this.onConnectingTimeout();\n        }\n        else if (this.state === State.Handshaking) {\n            // It should never happen, because socket.io should try at least one transport\n            this.logger.error('Unexpected error in Socket.io - no valid transports');\n            this.onConnectingTimeout();\n        }\n        else if (this.state === State.AnonymousConnecting || this.state === State.WebsocketAuthenticating) {\n            this.logger.info('/v4/c falling back to longpoll');\n            this.cleanUpAndInitiateReconnect({ backoff: true, allowCachedToken: true, fallbackReason: { kind: 'v4c-websocket-failure' } });\n        }\n        else {\n            this.showIgnored('onConnectingFailed');\n        }\n    };\n    /** Socket.io error (or disconnect) */\n    TrouterFsm.prototype.onSocketDisconnect = function (disconnectReason) {\n        if (this.state === State.Handshaking || this.state === State.Connected || this.state === State.WebsocketAuthenticating) {\n            if (this.state === State.Connected) {\n                this.worker.sendDisconnectTelemetryEvent(disconnectReason === null || disconnectReason === void 0 ? void 0 : disconnectReason.toTelemetryString());\n            }\n            if (this.state === State.WebsocketAuthenticating) {\n                this.worker.countDisconnectBeforeConnectionEstablishment();\n            }\n            if ((disconnectReason === null || disconnectReason === void 0 ? void 0 : disconnectReason.reason) === 'skypetoken-deprecated') {\n                this.logger.error('Skypetoken deprecated response, not retrying any further');\n                this.onTerminalError();\n            }\n            else {\n                this.cleanUpAndInitiateReconnect({\n                    // If client was already successfully connected, no backoff is needed (we want to reconnect quickly).\n                    // If however connection failed before the `trouter.connected` event arrived,\n                    // that means some sort of error where we don't want to retry immediately.\n                    backoff: this.state !== State.Connected && (disconnectReason === null || disconnectReason === void 0 ? void 0 : disconnectReason.reason) !== 'dup',\n                    allowCachedToken: (disconnectReason === null || disconnectReason === void 0 ? void 0 : disconnectReason.reason) !== 'unauthorized',\n                    claimsChallenge: disconnectReason === null || disconnectReason === void 0 ? void 0 : disconnectReason.claims\n                });\n            }\n        }\n        else {\n            // Disconnect can be called because of an error.\n            // Such error can happen in Connecting state, which means that\n            // websocket transport failed to establish connection\n            this.showIgnored('onSocketDisconnect');\n        }\n    };\n    /** Received 'trouter.connected' event from service */\n    TrouterFsm.prototype.onTrouterConnected = function () {\n        if (this.state === State.Connecting || this.state === State.WebsocketAuthenticating) {\n            this.setState(State.Connected);\n            this.worker.resetTokenBackoff();\n            this.worker.stopConnectionTimer();\n            this.worker.sendUserActivityState(InternalInterfaces_1.UserActivityEventReason.Connected, true);\n            this.worker.startPingTimer();\n            this.worker.dispatchConnected();\n            if (this.worker.shouldSkipRegistration()) {\n                this.registrationState = RegistrationState.RegistrationDisabled;\n                this.worker.dispatchRegistered();\n            }\n            else {\n                this.registrationState = RegistrationState.Registering;\n                this.worker.sendRegisterRequest();\n            }\n        }\n        else {\n            this.showIgnored('onTrouterConnected');\n        }\n    };\n    /**\n     * Received 'trouter.reconnect' event from service, or URL in configuration has changed,\n     * need to establish a new connection\n     */\n    TrouterFsm.prototype.onReconnectRequired = function (useConnectParamsFromCache, reason, eventArgs) {\n        if (this.state === State.AnonymousConnecting || this.state === State.WebsocketAuthenticating) {\n            if (eventArgs === undefined || eventArgs.target !== 'host' || eventArgs.url === undefined || eventArgs.url === '') {\n                this.logger.error(\"unexpected reconnect arguments: \".concat(eventArgs === null || eventArgs === void 0 ? void 0 : eventArgs.target, \" \").concat(eventArgs === null || eventArgs === void 0 ? void 0 : eventArgs.url, \", reconnecting without cache\"));\n                this.cleanUpAndInitiateReconnect({ backoff: true, allowCachedToken: true, fallbackReason: { kind: 'redirect-no-host' } });\n            }\n            else {\n                this.cleanUpAndInitiateReconnect({ backoff: true, allowCachedToken: true, fallbackReason: { kind: 'redirect', host: eventArgs.url } });\n            }\n        }\n        else {\n            this.worker.dispatchReconnectIsRequired(useConnectParamsFromCache, reason);\n        }\n    };\n    TrouterFsm.prototype.disableAutoReconnect = function () {\n        this.autoReconnect = false;\n    };\n    /** Request from downstream is received */\n    TrouterFsm.prototype.onDownstreamRequest = function (request) {\n        if (this.state === State.Connected) {\n            this.switchToIncallModeIfEnabled();\n            this.worker.dispatchDownstreamRequest(request);\n        }\n        else {\n            this.showIgnored('onDownstreamRequest');\n        }\n    };\n    TrouterFsm.prototype.onTrouterMessageLost = function (messageLossIndicators) {\n        if (this.state === State.Connected) {\n            this.worker.dispatchTrouterMessageLost(messageLossIndicators);\n        }\n        else {\n            this.showIgnored('onTrouterMessageLost');\n        }\n    };\n    /** Timer for ping request fired */\n    TrouterFsm.prototype.onPingInterval = function () {\n        if (this.state === State.Connected) {\n            this.worker.sendPingRequest();\n        }\n        else {\n            this.showIgnored('onPingInterval');\n        }\n    };\n    /** No pong response from service within timeout */\n    TrouterFsm.prototype.onPingResponseTimeout = function () {\n        this.onMissedResponse('onPingResponseTimeout');\n    };\n    /** Pong response */\n    TrouterFsm.prototype.onPingResponse = function () {\n        if (this.state === State.Connected) {\n            // do nothing\n        }\n        else {\n            this.showIgnored('onPingResponse');\n        }\n    };\n    TrouterFsm.prototype.onRegistrationFailed = function () {\n        if (this.state === State.Connected && this.registrationState === RegistrationState.Registering) {\n            this.worker.dispatchUnregistered();\n            this.registrationState = RegistrationState.Retrying;\n            this.worker.startRegistrationRetryTimer();\n        }\n        else if (this.state === State.Connected && this.registrationState === RegistrationState.RegisteringButResendPending) {\n            this.registrationState = RegistrationState.Registering;\n            this.worker.sendRegisterRequest();\n        }\n        else {\n            this.showIgnored('onRegistrationFailed');\n        }\n    };\n    TrouterFsm.prototype.onRetryRegistration = function () {\n        if (this.state === State.Connected && this.registrationState === RegistrationState.Retrying) {\n            this.registrationState = RegistrationState.Registering;\n            this.worker.sendRegisterRequest();\n        }\n        else {\n            this.showIgnored('onRetryRegistration');\n        }\n    };\n    TrouterFsm.prototype.onRegistrationSucceeded = function () {\n        if (this.state === State.Connected && this.registrationState === RegistrationState.Registering) {\n            this.registrationState = RegistrationState.Registered;\n            this.worker.dispatchRegistered();\n            this.worker.startRegistrationTimer();\n        }\n        else if (this.state === State.Connected && this.registrationState === RegistrationState.RegisteringButResendPending) {\n            this.registrationState = RegistrationState.Registering;\n            this.worker.sendRegisterRequest();\n        }\n        else {\n            this.showIgnored('onRegistrationSucceeded');\n        }\n    };\n    /** Registration TTL is about to expire */\n    TrouterFsm.prototype.onRegistrationNearExpiry = function () {\n        if (this.state === State.Connected && this.registrationState === RegistrationState.Registered) {\n            this.registrationState = RegistrationState.Registering;\n            this.worker.sendRegisterRequest();\n        }\n        else {\n            this.showIgnored('onRegistrationNearExpiry');\n        }\n    };\n    TrouterFsm.prototype.onUnregistrationDone = function () {\n        if (this.state === State.Unregistering) {\n            this.setState(State.Initial);\n            this.worker.dispatchUnregistered();\n            this.worker.dispatchDisconnected(); // TODO: only sending \"disconneted\" upon unregistration makes no sense\n        }\n        else {\n            this.showIgnored('onUnregistrationDone');\n        }\n    };\n    TrouterFsm.prototype.onResendRegistration = function () {\n        this.worker.dispatchUnregistered();\n        if (this.state === State.Connected && this.registrationState === RegistrationState.Registered) {\n            this.registrationState = RegistrationState.Registering;\n            this.worker.stopRegistrationTimer();\n            this.worker.sendRegisterRequest();\n        }\n        else if (this.state === State.Connected && this.registrationState === RegistrationState.Registering) {\n            this.registrationState = RegistrationState.RegisteringButResendPending;\n        }\n    };\n    TrouterFsm.prototype.onIncallModeTimer = function () {\n        this.worker.exitIncallMode();\n        if (this.state === State.Connected) {\n            this.worker.stopPingTimer();\n            this.worker.startPingTimer();\n        }\n        else {\n            this.showIgnored('onIncallModeTimer');\n        }\n    };\n    TrouterFsm.prototype.onSetNewUserActivityState = function () {\n        this.worker.sendUserActivityState(InternalInterfaces_1.UserActivityEventReason.Modified, this.state === State.Connected);\n    };\n    TrouterFsm.prototype.onActivityStateResponseTimeout = function () {\n        this.onMissedResponse('onActivityStateResponseTimeout');\n    };\n    TrouterFsm.prototype.forceReconnect = function (reason) {\n        if (this.state === State.Connected) {\n            this.worker.sendDisconnectTelemetryEvent(reason);\n        }\n        this.worker.resetTokenBackoff();\n        this.cleanUpAndInitiateReconnect({ backoff: false, allowCachedToken: true });\n    };\n    TrouterFsm.prototype.onTerminalError = function () {\n        this.logger.error(\"Cannot proceed, reached terminal state. Switching from state '\".concat(State[this.state], \"' to \").concat(State[State.TerminalError]));\n        this.stop(\n        /* dontUnregister */ true, \n        /* isTerminalError */ true);\n        this.setState(State.TerminalError);\n    };\n    TrouterFsm.prototype.onMissedResponse = function (onResponseHandlerName) {\n        if (this.state === State.Connected) {\n            this.worker.sendDisconnectTelemetryEvent(onResponseHandlerName);\n            this.cleanUpAndInitiateReconnect({ backoff: false, allowCachedToken: true });\n        }\n        else {\n            this.showIgnored(onResponseHandlerName);\n        }\n    };\n    TrouterFsm.prototype.showIgnored = function (event) {\n        this.logger.debug(\"Ignoring event '\".concat(event, \"' in state '\").concat(State[this.state], \"'\"));\n    };\n    TrouterFsm.prototype.setState = function (state) {\n        this.logger.info(\"Switching from state '\".concat(State[this.state], \"' to state '\").concat(State[state], \"'\"));\n        if (this.state === state) {\n            this.logger.error(\"Attempt to switch to the current state '\".concat(State[state], \"'\"));\n            return;\n        }\n        this.state = state;\n    };\n    TrouterFsm.prototype.switchToIncallModeIfEnabled = function () {\n        if (this.incallModeEnabled) {\n            if (!this.worker.isIncallMode()) {\n                this.worker.enterIncallMode();\n                this.worker.stopPingTimer();\n                this.worker.startPingTimer();\n            }\n            this.worker.restartIncallModeTimer();\n        }\n    };\n    TrouterFsm.prototype.cleanUpAndInitiateReconnect = function (options) {\n        if (!this.autoReconnect) {\n            this.logger.info('Automatic reconnect is disabled, stopping this connection');\n            this.stop(true);\n            return;\n        }\n        this.worker.cancelPendingRegistrationRequests();\n        this.worker.stopConnectionTimer();\n        this.worker.stopPingTimer();\n        this.worker.clearSentEventTimers();\n        this.worker.stopRegistrationTimer();\n        this.worker.stopSocketIo();\n        this.setState(State.RetrievingToken);\n        this.worker.dispatchReconnecting();\n        this.worker.getToken(options.allowCachedToken, options.backoff, options.claimsChallenge, options.fallbackReason);\n    };\n    return TrouterFsm;\n}());\nexports.TrouterFsm = TrouterFsm;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrouterConnection = exports.ReconnectReason = void 0;\nvar tsregistrar_1 = __webpack_require__(21);\nvar Common_1 = __webpack_require__(3);\nvar ConnectionTracker_1 = __webpack_require__(15);\nvar Constants_1 = __webpack_require__(1);\nvar DisconnectReason_1 = __webpack_require__(16);\nvar ExponentialBackoff_1 = __webpack_require__(17);\nvar Interfaces_1 = __webpack_require__(2);\nvar InternalInterfaces_1 = __webpack_require__(4);\nvar Logger_1 = __webpack_require__(0);\nvar ProtocolAdapters_1 = __webpack_require__(5);\nvar TrouterFsm_1 = __webpack_require__(6);\n// This is the current API version\nvar VERSION = 'v4';\n// Default value for registration timeout\nvar DEFAULT_REGISTRATION_TIMEOUT_SEC = 3600;\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\nvar io = __webpack_require__(12);\n/**\n * Stub for IClientInfo\n */\nvar ClientInfo = /** @class */ (function () {\n    function ClientInfo() {\n        this.cv = Constants_1.CLIENT_VERSION;\n        this.ua = '';\n        this.hr = '';\n        this.v = '';\n    }\n    return ClientInfo;\n}());\n/**\n * Stub for ISocketIoOptions\n */\nvar SocketIoOptions = /** @class */ (function () {\n    function SocketIoOptions() {\n        this['force new connection'] = true;\n        this['reconnect'] = false;\n        this['query'] = '';\n        this.ackTimeoutMs = 5000;\n    }\n    SocketIoOptions.prototype.rewriteUrlForProxy = function (url) { return url; };\n    return SocketIoOptions;\n}());\nvar cvHeader = 'MS-CV';\n/**\n * Request from downstream service\n */\nvar TrouterRequest = /** @class */ (function () {\n    function TrouterRequest(requestJson, logger) {\n        this.logger = logger;\n        this.cvCounter = 0;\n        var json = JSON.parse(requestJson);\n        this.startTS = this.safeJsonNumber(json, 'startTS', 0);\n        this.url = this.safeJsonString(json, 'url', '');\n        this.shortUrl = this.safeJsonString(json, 'shortUrl', '');\n        this.body = this.safeJsonString(json, 'body', '');\n        this.headers = this.safeJsonRecord(json, 'headers', {});\n        this.id = this.safeJsonNumber(json, 'id', -1);\n        this.method = this.safeJsonString(json, 'method', '');\n        this.replied = false;\n        this.timedout = false;\n        this.receivedCv = this.headers[cvHeader];\n        this.updateCvHeader();\n    }\n    Object.defineProperty(TrouterRequest.prototype, \"correlationVector\", {\n        get: function () {\n            return this.receivedCv ? \"\".concat(this.receivedCv, \".\").concat(this.cvCounter) : '';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    TrouterRequest.prototype.on = function (target, targetCallback) {\n        if (target === 'data') {\n            this.dataCallback = targetCallback;\n        }\n        else if (target === 'end') {\n            if (typeof this.dataCallback === 'function') {\n                this.dataCallback(this.body);\n            }\n            targetCallback();\n        }\n    };\n    TrouterRequest.prototype.incrementCorrelationVector = function () {\n        ++this.cvCounter;\n        this.updateCvHeader();\n    };\n    TrouterRequest.prototype.updateCvHeader = function () {\n        var cv = this.correlationVector;\n        if (cv) {\n            this.headers[cvHeader] = cv;\n        }\n    };\n    TrouterRequest.prototype.safeJsonNumber = function (json, property, defaultValue) {\n        var _a;\n        if (json !== null && json !== undefined && Object.prototype.hasOwnProperty.call(json, property)) {\n            var jsonRecord = json;\n            if (typeof jsonRecord[property] === 'number') {\n                return (jsonRecord[property]);\n            }\n            else if (typeof jsonRecord[property] === 'string') {\n                return parseFloat((jsonRecord[property]));\n            }\n            else {\n                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(\"unexpected type of '\".concat(property, \"': \").concat(typeof jsonRecord[property]));\n            }\n        }\n        return defaultValue;\n    };\n    TrouterRequest.prototype.safeJsonString = function (json, property, defaultValue) {\n        var _a;\n        if (json !== null && json !== undefined && Object.prototype.hasOwnProperty.call(json, property)) {\n            var jsonRecord = json;\n            if (typeof jsonRecord[property] === 'string') {\n                return (jsonRecord[property]);\n            }\n            else {\n                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(\"unexpected type of '\".concat(property, \"': \").concat(typeof jsonRecord[property]));\n            }\n        }\n        return defaultValue;\n    };\n    TrouterRequest.prototype.safeJsonRecord = function (json, property, defaultValue) {\n        var _a;\n        if (json !== null && json !== undefined && Object.prototype.hasOwnProperty.call(json, property)) {\n            var jsonRecord = json;\n            if (typeof jsonRecord[property] === 'object') {\n                return (jsonRecord[property]);\n            }\n            else {\n                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(\"unexpected type of '\".concat(property, \"': \").concat(typeof jsonRecord[property]));\n            }\n        }\n        return defaultValue;\n    };\n    return TrouterRequest;\n}());\n/**\n * Response to downstream service\n */\nvar TrouterResponse = /** @class */ (function () {\n    function TrouterResponse(request, responseData, sendResponse) {\n        this.request = request;\n        this.responseData = responseData;\n        this.sendResponse = sendResponse;\n    }\n    TrouterResponse.prototype.writeHead = function (status, headers) {\n        this.responseData.status = status;\n        this.responseData.headers = headers;\n    };\n    TrouterResponse.prototype.write = function (chunk) {\n        this.responseData.body += chunk;\n    };\n    TrouterResponse.prototype.end = function (chunk) {\n        if (chunk) {\n            this.responseData.body += chunk;\n        }\n        return this.sendResponse(this.request, this.responseData);\n    };\n    return TrouterResponse;\n}());\n/**\n * An client-initiated event that is to be sent to trouter.\n */\nvar DownstreamEvent = /** @class */ (function () {\n    function DownstreamEvent(name) {\n        this.name = name;\n        this.args = {};\n        this.timeoutTimerId = 0;\n    }\n    return DownstreamEvent;\n}());\n/**\n * Reason why a connection switch is happening.\n */\nvar ReconnectReason;\n(function (ReconnectReason) {\n    /** Configuration change coming from ECS, containing different URL */\n    ReconnectReason[ReconnectReason[\"Configuration\"] = 0] = \"Configuration\";\n    /** In response to a `trouter.reconnect` socket.io event */\n    ReconnectReason[ReconnectReason[\"ServerInitiated\"] = 1] = \"ServerInitiated\";\n})(ReconnectReason || (exports.ReconnectReason = ReconnectReason = {}));\n/**\n * Trouter + registration flow implementation\n */\nvar TrouterConnection = /** @class */ (function () {\n    function TrouterConnection(logProvider, options, manager, tokenProvider, usingLegacyTokenApi, initialUserActivityState, protocolSelector, audienceSubscriptionState) {\n        var _this = this;\n        var _a;\n        this.options = options;\n        this.manager = manager;\n        this.tokenProvider = tokenProvider;\n        this.usingLegacyTokenApi = usingLegacyTokenApi;\n        this.protocolSelector = protocolSelector;\n        this.audienceSubscriptionState = audienceSubscriptionState;\n        this.WEBSOCKET_TRANSPORT_NAME = 'websocket';\n        this.XHR_POLLING_TRANSPORT_NAME = 'xhr-polling';\n        this.AUDIENCE_SUBSCRIPTION_RESULT_ERROR = 'Error';\n        this.AUDIENCE_SUBSCRIPTION_RESULT_UNSUBSCRIBED = 'Unsubscribed';\n        this.AUDIENCE_SUBSCRIPTION_RESULT_TIMEOUT = 'Timeout';\n        this.AUDIENCE_SUBSCRIPTION_RESULT_BAD_REQUEST = \"BadRequest\";\n        this.AUDIENCE_SUBSCRIPTION_STATE_QUERY_PARAM_REGEX = /&audienceSubscriptionState=[^&]*|^audienceSubscriptionState=[^&]*&?/;\n        this.connectionId = '';\n        this.inIncallMode = false;\n        this.connectionAttempt = 0;\n        this.connectedClientId = '';\n        this.isNavigatorOnline = true;\n        this.onNavigatorOnlineStatusUpdateBound = this.onNavigatorOnlineStatusUpdate.bind(this); // Bound to allow removing the listener\n        this.c2cUrlBase = '';\n        this.connectingErrorsInRow = 0;\n        /** Keeps track of 401s */\n        this.unauthorizedErrorCount = 0;\n        this.pendingSentEventTimers = {};\n        this.lastDisconnectReason = '';\n        this.UNKNOWN_TRANSPORT = 'unknown_transport';\n        this.connectingErrorsThreshold = 3;\n        // this variable represents and ongoing audience subscription operation that has been initiated by user\n        // if the operation value exists it means that user requested a subscription but there has not been an answer from server yet\n        // valid only for longpoll \n        this.pendingAudienceSubscription = undefined;\n        this.logger = new Logger_1.Logger('Connection', logProvider);\n        this.timeoutOptions = this.options.timeoutOptions;\n        this.tokenBackoff = new ExponentialBackoff_1.ExponentialBackoff(this.logger, this.timeoutOptions.maxBackoffMs);\n        this.clientID = Date.now();\n        if ((typeof window !== 'undefined') && window.location) {\n            this.domId = window.location.hostname;\n        }\n        var clientInfo = new ClientInfo();\n        clientInfo.cv = Constants_1.CLIENT_VERSION;\n        clientInfo.ua = '';\n        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.clientInfo) {\n            clientInfo.ua = this.safeString(this.options.clientInfo.ua);\n            clientInfo.v = this.safeString(this.options.clientInfo.v);\n        }\n        this.clientInfo = clientInfo;\n        this.connectionTracker = new ConnectionTracker_1.ConnectionTracker(logProvider, this.clientID, this.clientInfo, function () { return _this.getServerState(); }, this.options.endpointId, this.options.clientCorrelationID, this.options.environment);\n        this.applyConnectionTrackerOptions(options);\n        var useIncallMode = this.options.incallModeTimeoutMs > 0;\n        this.fsm = new TrouterFsm_1.TrouterFsm(logProvider, this, useIncallMode, this.protocolSelector);\n        if (options.registration) {\n            var registrarOptions = {\n                registrarUrl: options.registration.registrarUrl,\n                proxyUrlRewrite: options.rewriteUrlForProxy,\n                registrationId: options.registration.registrationId,\n                requestTimeoutMs: options.timeoutOptions.fetchTimeoutMs,\n                initialRetryDelayMs: 1000,\n                maxRetryDelayMs: options.timeoutOptions.maxBackoffMs,\n                usingLegacyTokenApi: this.usingLegacyTokenApi,\n                maxRetriesForGetToken: options.retryLimitOnTokenFetch,\n                extraRegistrationHeaders: options.extraConnectionHeaders\n            };\n            this.registrarClient = (0, tsregistrar_1.createRegistrarClient)(logProvider, this.tokenProvider, registrarOptions);\n        }\n        this.userActivityState = initialUserActivityState;\n    }\n    TrouterConnection.prototype.start = function (externalConnectParams) {\n        this.logger.info('Starting');\n        this.reconnectParams = externalConnectParams;\n        if (typeof window !== 'undefined' && window.navigator && window.addEventListener) {\n            this.isNavigatorOnline = window.navigator.onLine;\n            window.addEventListener('online', this.onNavigatorOnlineStatusUpdateBound);\n            window.addEventListener('offline', this.onNavigatorOnlineStatusUpdateBound);\n            this.logger.debug(\"Registered for browser online notifications - current state: \".concat(this.isNavigatorOnline));\n        }\n        else {\n            this.isNavigatorOnline = true; // Assume always online if the API is not available\n        }\n        this.fsm.start();\n    };\n    TrouterConnection.prototype.stop = function (dontUnregister) {\n        this.logger.info('Stopping');\n        if (typeof window !== 'undefined' && window.navigator) {\n            window.removeEventListener('online', this.onNavigatorOnlineStatusUpdateBound);\n            window.removeEventListener('offline', this.onNavigatorOnlineStatusUpdateBound);\n        }\n        this.fsm.stop(dontUnregister);\n        this.connectionTracker.close();\n    };\n    TrouterConnection.prototype.configure = function (options) {\n        // Currently only baseUrl and telemetrySettings options are supported for reconfiguration\n        var urlChanged = this.options.trouterUrl !== options.trouterUrl;\n        this.options = options;\n        this.applyConnectionTrackerOptions(options);\n        if (urlChanged) {\n            this.logger.info('Configuration changed. Reconnection required.');\n            this.fsm.onReconnectRequired(false, ReconnectReason.Configuration);\n        }\n    };\n    TrouterConnection.prototype.checkConnection = function (disconnectDetected) {\n        this.logger.info(\"checkConnection called with \".concat(disconnectDetected));\n        this.fsm.checkConnection(disconnectDetected);\n        // Don't send on disconnectDetected === false, because Teams client calls it on timer\n        if (disconnectDetected) {\n            this.connectionTracker.sendTelemetry(ConnectionTracker_1.ClientEventName.CheckConnection, {\n                disconnectDetected: disconnectDetected\n            }, []);\n        }\n    };\n    TrouterConnection.prototype.disableRegistrationsAndAutoReconnect = function () {\n        this.stopRegistrationTimer();\n        this.cancelPendingRegistrationRequests();\n        this.fsm.disableAutoReconnect();\n    };\n    /** Returns info about connection */\n    TrouterConnection.prototype.getServerState = function () {\n        return new InternalInterfaces_1.ServerState(this.connectionId, this.connectedClientId, this.domId ? this.domId : '', this.allocateResult ? this.allocateResult.url : '', this.allocateResult ? this.allocateResult.surl : '', this.c2cUrlBase, this.connectionExpireTimestampInSecs);\n    };\n    TrouterConnection.prototype.getState = function () {\n        return this.fsm.getState();\n    };\n    //////// Implement IWorker ////////\n    TrouterConnection.prototype.getToken = function (useCache, backoff, claimsChallenge, reason, retryCounter) {\n        var _this = this;\n        if (retryCounter === void 0) { retryCounter = 0; }\n        this.logger.info(\"Getting token \".concat(backoff ? 'with backoff' : 'without backoff'));\n        var requestFunction = function () {\n            _this.connectionTracker.trackStart('token');\n            var tokenRequest = {\n                needFresh: !useCache,\n                wwwAuthenticateHeader: claimsChallenge,\n                supportedTokenTypes: Constants_1.SUPPORTED_TOKEN_TYPES,\n                purpose: 'trouter'\n            };\n            _this.logger.info(\"Requesting token: needFresh=\".concat(tokenRequest.needFresh, \" \") +\n                \"types=[\".concat(Constants_1.SUPPORTED_TOKEN_TYPES, \"], \") +\n                \"wwwAuthenticateHeader is \".concat(tokenRequest.wwwAuthenticateHeader ? 'non empty' : 'empty'));\n            _this.tokenProvider(tokenRequest).then(function (token) {\n                _this.logger.debug(\"\".concat(token.tokenType, \" token is received\"));\n                _this.connectionTracker.trackEnd('token');\n                _this.fsm.onTokenReceived(token, reason, _this.reconnectParams);\n            }).catch(function (error) {\n                var msg = (0, Common_1.toJson)(error.stack);\n                _this.logger.error(\"Getting token failed, will retry after timeout. Error: \".concat(msg));\n                _this.connectionTracker.trackError('token', msg);\n                // Can't retry getToken request, which means client would not receive any notifications from trouter.\n                // Unrecoverable error unless client tries to reconnect with Trouter\n                //     - retryCounter tracks internal loop\n                //     - unauthorizedErrorCount tracks external loop (consecutive number of sendAllocationFailures as a result of 401s)\n                if (!_this.canRetryTokenFetchRequest(retryCounter + _this.unauthorizedErrorCount)) {\n                    var errorMessage = 'getToken retry limit hit, reached terminal error state';\n                    _this.connectionTracker.trackError('token', errorMessage);\n                    _this.resetTokenBackoff();\n                    _this.fsm.onTerminalError();\n                    return;\n                }\n                _this.getToken(useCache, true, claimsChallenge, reason, retryCounter + 1);\n            });\n        };\n        if (backoff) {\n            this.tokenBackoff.backoff('getting token', requestFunction);\n        }\n        else {\n            this.resetTokenBackoff();\n            requestFunction();\n        }\n    };\n    TrouterConnection.prototype.startConnectionTimer = function () {\n        var _this = this;\n        this.stopConnectionTimer();\n        this.logger.debug(\"Starting connection timeout for \".concat(this.timeoutOptions.connectionTimeoutMs, \" ms\"));\n        this.connectionTimeoutId = setTimeout(function () {\n            _this.logger.info('Connection timeout is fired');\n            _this.fsm.onConnectingTimeout();\n        }, this.timeoutOptions.connectionTimeoutMs);\n    };\n    TrouterConnection.prototype.stopConnectionTimer = function () {\n        if (this.connectionTimeoutId) {\n            this.logger.debug('Stopping connection timeout');\n            clearTimeout(this.connectionTimeoutId);\n            this.connectionTimeoutId = undefined;\n        }\n    };\n    TrouterConnection.prototype.startPingTimer = function () {\n        var _this = this;\n        if (this.transportTypeName === 'websocket') {\n            this.logger.debug(\"Starting ping timeout for \".concat(this.timeoutOptions.pingTimeoutMs, \" ms\"));\n            this.pingTimerId = setInterval(function () {\n                _this.logger.info('Ping interval fired');\n                _this.fsm.onPingInterval();\n            }, this.timeoutOptions.pingTimeoutMs);\n        }\n        else {\n            this.logger.debug(\"Not starting ping for transport \".concat(this.transportTypeName));\n        }\n    };\n    TrouterConnection.prototype.stopPingTimer = function () {\n        if (this.pingTimerId) {\n            this.logger.debug('Stopping ping timeout');\n            this.clearPingResponseTimer();\n            clearInterval(this.pingTimerId);\n            this.pingTimerId = undefined;\n        }\n    };\n    TrouterConnection.prototype.shouldSkipRegistration = function () {\n        return this.options.registration === undefined;\n    };\n    TrouterConnection.prototype.hasCustomRegistrationTtl = function () {\n        var _a, _b;\n        return ((_a = this.options.registration) === null || _a === void 0 ? void 0 : _a.registrarTtlSec) !== undefined && ((_b = this.options.registration) === null || _b === void 0 ? void 0 : _b.registrarTtlSec) !== 0;\n    };\n    TrouterConnection.prototype.startRegistrationTimer = function () {\n        var _this = this;\n        this.stopRegistrationTimer();\n        var timeForReregistrationSec = 30;\n        var _a = this.getRegistrationTtl(), ttl = _a[0], isTtlReduced = _a[1];\n        if (ttl <= timeForReregistrationSec || !isTtlReduced) {\n            this.logger.debug(\"Starting registration expiration timer (TTL \".concat(ttl, \" sec)\"));\n            this.registrationTimerId = setTimeout(function () {\n                _this.registrationTimerId = undefined;\n                _this.logger.warn('Registration expired but the connection is still alive. Should never happen');\n                _this.dispatchUnregistered();\n            }, ttl * 1000);\n            return;\n        }\n        var delay = ttl - timeForReregistrationSec;\n        this.logger.debug(\"Starting registration extension timer for \".concat(delay, \" sec\"));\n        this.registrationTimerId = setTimeout(function () {\n            _this.logger.info('Registration extension timer fired');\n            _this.registrationTimerId = setTimeout(function () {\n                _this.registrationTimerId = undefined;\n                _this.logger.debug('Registration extension did not happen in time');\n                _this.dispatchUnregistered();\n            }, timeForReregistrationSec * 1000);\n            _this.fsm.onRegistrationNearExpiry();\n        }, delay * 1000);\n    };\n    TrouterConnection.prototype.startRegistrationRetryTimer = function () {\n        var _this = this;\n        this.stopRegistrationTimer();\n        // A simple static delay for now, per discussion in PR 870422.\n        var registrationRetryDelaySec = 123;\n        this.registrationTimerId = setTimeout(function () {\n            _this.registrationTimerId = undefined;\n            _this.fsm.onRetryRegistration();\n        }, registrationRetryDelaySec * 1000);\n    };\n    TrouterConnection.prototype.stopRegistrationTimer = function () {\n        if (this.registrationTimerId) {\n            this.logger.debug('Stopping registration timeout');\n            clearTimeout(this.registrationTimerId);\n            this.registrationTimerId = undefined;\n        }\n    };\n    TrouterConnection.prototype.resendRegistration = function () {\n        if (!this.registrarClient) {\n            throw new Error('Trouter Client not configured to handle registrations');\n        }\n        this.fsm.onResendRegistration();\n        return Promise.resolve();\n    };\n    TrouterConnection.prototype.buildSocketIoUrlParams = function (userActivitySnapshot, audienceSubscriptionSnapshot) {\n        if (!this.allocateResult) {\n            throw new Error('Allocate result is undefined in buildSocketIoUrlParams()');\n        }\n        var urlParams = {};\n        // Copy connection parameters (i.e. signature) from allocation response\n        var signatureData = this.allocateResult.connectparams;\n        for (var _i = 0, _a = Object.keys(signatureData); _i < _a.length; _i++) {\n            var i = _a[_i];\n            if (signatureData[i] !== undefined) {\n                var value = signatureData[i];\n                if (typeof value === 'string' || typeof value === 'number') {\n                    urlParams[i] = value;\n                }\n                else {\n                    this.logger.error(\"signatureData[\".concat(i, \"] has unsupported type \").concat(typeof value));\n                }\n            }\n        }\n        // And add some more fields\n        urlParams.v = VERSION;\n        urlParams.tc = encodeURI((0, Common_1.toJson)(this.clientInfo));\n        urlParams.timeout = this.timeoutOptions.pingTimeoutMs / 1000;\n        urlParams.auth = 'true';\n        if (this.options.endpointId) {\n            urlParams.epid = this.options.endpointId;\n        }\n        if (userActivitySnapshot) {\n            urlParams.userActivity = encodeURI((0, Common_1.toJson)(userActivitySnapshot));\n        }\n        if (audienceSubscriptionSnapshot) {\n            urlParams.audienceSubscriptionState = encodeURIComponent((0, Common_1.toJson)(audienceSubscriptionSnapshot));\n        }\n        return this.appendConnectedClientIds(this.buildQuery(urlParams), true);\n    };\n    TrouterConnection.prototype.startSocketIo = function (token) {\n        var _a, _b;\n        this.logger.debug('Starting socket io');\n        this.connectionTracker.trackStart('connectSocket');\n        if (!this.allocateResult) {\n            throw new Error('Allocate result is undefined in startSocketIo()');\n        }\n        var options = this.options.ioOptions ? __assign({}, this.options.ioOptions) : new SocketIoOptions();\n        // Take user activity snapshot (if a state isn't unknown) to make sure it's consistent between the function calls below.\n        var userActivitySnapshot = this.userActivityState.state !== Interfaces_1.UserActivityState.Unknown\n            ? this.userActivityState.increaseCvAndGetEventObject()\n            : undefined;\n        var audienceSubscriptionStateSnapshot = (_a = this.audienceSubscriptionState) === null || _a === void 0 ? void 0 : _a.increaseCvAndGetEventObject();\n        // Regardless of any passed in socket.io options, force the following settings.\n        options['force new connection'] = true;\n        options.reconnect = false;\n        options.rewriteUrlForProxy = this.options.rewriteUrlForProxy;\n        options.requestHeaders = __assign(__assign({}, this.options.extraConnectionHeaders), headersFromToken(token, this.usingLegacyTokenApi));\n        // Query params to each socket.io request\n        options.query = this.buildSocketIoUrlParams(userActivitySnapshot, audienceSubscriptionStateSnapshot);\n        this.logger.info(\"connecting to \".concat(this.allocateResult.socketio, \"?\").concat(options.query));\n        // msg868 - clear all events and disconnect\n        this.stopSocketIo();\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call\n        this.socket = ((_b = this.options.io) !== null && _b !== void 0 ? _b : io).connect(this.allocateResult.socketio, options);\n        if (this.socket === undefined) {\n            throw new Error('Can\\'t create Socket.io object');\n        }\n        this.attachSocketIoHandlers(this.socket, token, userActivitySnapshot, audienceSubscriptionStateSnapshot);\n    };\n    TrouterConnection.prototype.stopSocketIo = function () {\n        if (this.socket) {\n            this.logger.debug('clearing socket.io');\n            try {\n                for (var _i = 0, _a = [\n                    'connecting', 'connect', 'connect_failed', 'close_during_connecting', 'disconnect', 'reconnect', 'reconnect_failed',\n                    'reconnecting', 'error', 'message', 'trouter.connected', 'trouter.reconnect', 'trouter.message_loss'\n                ]; _i < _a.length; _i++) {\n                    var event_1 = _a[_i];\n                    this.socket.removeAllListeners(event_1);\n                }\n                this.socket.disconnect();\n                this.logger.debug('cleared socket');\n                this.socket = undefined;\n            }\n            catch (error) {\n                this.logger.error(\"exception in disconnecting previous socket. Error: \".concat(errorStackToJson(error)));\n            }\n        }\n    };\n    TrouterConnection.prototype.dispatchConnected = function () {\n        this.logger.info('dispatching connected');\n        this.manager.onConnected(this);\n    };\n    TrouterConnection.prototype.dispatchRegistered = function () {\n        this.logger.info('dispatching registered');\n        this.manager.onRegistered(this);\n    };\n    TrouterConnection.prototype.dispatchUnregistered = function () {\n        this.logger.info('dispatching unregistered');\n        this.manager.onUnregistered(this);\n    };\n    TrouterConnection.prototype.dispatchDownstreamRequest = function (request) {\n        var _this = this;\n        this.logger.debug('dispatching downstream request');\n        try {\n            var response = new TrouterResponse(request, new ConnectionTracker_1.ResponseData(request.id), function (req, responseData) {\n                _this.logger.debug('sending response to downstream');\n                return _this.sendResponse(req, responseData);\n            });\n            this.manager.onDownstreamRequest(this, request, response);\n        }\n        catch (error) {\n            this.logger.error(\"exception in socket.on message. Error : \".concat(errorStackToJson(error)));\n        }\n    };\n    TrouterConnection.prototype.dispatchReconnecting = function () {\n        this.logger.info('dispatching reconnecting');\n        this.manager.onReconnecting(this);\n    };\n    TrouterConnection.prototype.dispatchReconnectIsRequired = function (useConnectParamsFromCache, reason) {\n        this.logger.info('dispatching reconnect is required by server');\n        this.manager.onReconnectIsRequired(this, useConnectParamsFromCache, reason);\n    };\n    TrouterConnection.prototype.dispatchDisconnected = function () {\n        this.logger.info('dispatching disconnected');\n        this.manager.onDisconnected(this);\n    };\n    TrouterConnection.prototype.dispatchTerminalError = function () {\n        this.logger.info('dispatching terminal error');\n        this.manager.onTerminalError(this);\n    };\n    TrouterConnection.prototype.dispatchTrouterMessageLost = function (messageLossIndicators) {\n        this.logger.info('dispatching trouter message lost');\n        this.manager.onTrouterMessageLost(messageLossIndicators);\n    };\n    TrouterConnection.prototype.countDisconnectBeforeConnectionEstablishment = function () {\n        this.logger.warn('counting disconnect before connection was fully established as a connection failure');\n        this.connectingErrorsInRow++;\n        if (this.connectingErrorsInRow >= this.connectingErrorsThreshold) {\n            this.resetReconnectParamsOnErrorThreshold();\n        }\n    };\n    TrouterConnection.prototype.sendProcessedDroppedIndicators = function (messageLossIndicators) {\n        var _this = this;\n        try {\n            this.logger.debug('emitting processed flow tags to the server');\n            var processedMessageLossEvent = new DownstreamEvent('trouter.processed_message_loss');\n            processedMessageLossEvent.args = { droppedIndicators: messageLossIndicators };\n            this.sendDownstreamEvent(processedMessageLossEvent, function () {\n                _this.logger.info('emitted processed flow tags to the server');\n            });\n        }\n        catch (error) {\n            var msg = errorStackToJson(error);\n            this.logger.error(\"unable to send processed message loss event. Error: \".concat(msg));\n            this.connectionTracker.trackError('trouter.processed_message_loss', msg, false);\n        }\n    };\n    TrouterConnection.prototype.sendAllocateRequest = function (token) {\n        var _this = this;\n        this.connectionAttempt++;\n        this.connectionTracker.trackNewConnection();\n        var url = this.options.trouterUrl;\n        var connectParams;\n        var rp = this.reconnectParams;\n        var expiration = typeof (rp === null || rp === void 0 ? void 0 : rp.se) === 'string' ? parseInt(rp.se, 10) : (typeof (rp === null || rp === void 0 ? void 0 : rp.se) === 'number' ? rp.se : undefined);\n        if (expiration && expiration <= Date.now() + 3600000) { // 1 hour\n            this.logger.warn(\"Dropping expired cached connection parameters: \".concat(new Date(expiration)));\n            this.reconnectParams = rp = undefined;\n        }\n        if (rp && rp.serviceUrl !== url) {\n            this.logger.warn(\"Dropping cached connection parameters for a different environment (\".concat(rp.serviceUrl, \", now \").concat(url, \")\"));\n            this.reconnectParams = rp = undefined;\n        }\n        if (rp === null || rp === void 0 ? void 0 : rp.reconnectUrl) {\n            url = rp.reconnectUrl;\n        }\n        if (rp) {\n            // Do not append serviceUrl and reconnectUrl as query parameters\n            connectParams = __assign(__assign({}, rp), { serviceUrl: undefined, reconnectUrl: undefined });\n        }\n        else {\n            connectParams = null;\n        }\n        url = (0, ProtocolAdapters_1.adaptUrl)(url, 'v4a');\n        url = this.appendCorrelationIds(url, false);\n        url = this.appendEndpointId(url, false);\n        if (connectParams) {\n            url += \"&\".concat(this.buildQuery(connectParams));\n            // Currently server doesn't return \"v\" in allocate result, but it\n            // can be changed, so implement it this way just in case\n            if (!connectParams.v) {\n                url += \"&v=\".concat(VERSION);\n            }\n        }\n        url = this.options.rewriteUrlForProxy(url);\n        var allocateRequest = new Request(url, {\n            method: 'POST',\n            mode: 'cors',\n            headers: new Headers(__assign(__assign({ 'Content-Type': 'text/plain' }, this.options.extraConnectionHeaders), headersFromToken(token, this.usingLegacyTokenApi)))\n        });\n        this.logger.info(\"sendAllocateRequest: POST \".concat(url));\n        this.connectionTracker.trackStart('allocation');\n        var startTimestamp = Date.now();\n        var responseStatusCode = -1;\n        var responseClaimsChallenge;\n        var responseSkypetokenDeprecated = false;\n        (0, Common_1.fetchWithTimeout)(allocateRequest, this.timeoutOptions.fetchTimeoutMs).then(function (response) {\n            var _a;\n            responseStatusCode = response.status;\n            if (!response.ok) {\n                responseClaimsChallenge = (_a = response.headers.get('www-authenticate')) !== null && _a !== void 0 ? _a : undefined;\n                responseSkypetokenDeprecated = response.headers.get('x-trouter-skypetoken-deprecated') === '1';\n                _this.logger.warn(\"Allocation request got response status \".concat(response.status, \", www-authenticate header was \").concat(responseClaimsChallenge ? 'not empty' : 'empty'));\n                throw new Error(response.statusText);\n            }\n            var contentType = response.headers.get('content-type');\n            if (!contentType || (contentType !== 'application/json' && !contentType.startsWith('application/json;'))) {\n                throw new Error(\"Content-type '\".concat(contentType, \"' is unexpected\"));\n            }\n            _this.connectionTracker.trackEnd('allocation');\n            return response.json();\n        }).then(function (responseObj) {\n            _this.unauthorizedErrorCount = 0;\n            // We perform no parsing/validation of the response received from server\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            _this.onAllocationResponse(responseObj, token);\n        }).catch(function (error) {\n            _this.connectingErrorsInRow++;\n            var msg = \"\".concat(error).concat(responseStatusCode >= 0 ? \", status code \".concat(responseStatusCode) : '');\n            _this.logger.error(\"\".concat(_this.connectingErrorsInRow, \" failed connecting attempt(s) in a row. \").concat(msg));\n            _this.connectionTracker.trackError('allocation', msg);\n            if (responseSkypetokenDeprecated) {\n                var errorMessage = 'Skypetoken deprecated response, not retrying any further';\n                _this.logger.error(errorMessage);\n                _this.connectionTracker.trackError('allocation', errorMessage);\n                _this.fsm.onTerminalError();\n                return;\n            }\n            if (responseStatusCode === 401) {\n                _this.unauthorizedErrorCount++;\n            }\n            if (!_this.canRetryTokenFetchRequest(_this.unauthorizedErrorCount)) {\n                var errorMessage = 'getToken retry limit hit, reached terminal error state';\n                _this.connectionTracker.trackError('allocation', errorMessage);\n                _this.fsm.onTerminalError();\n                return;\n            }\n            if (responseStatusCode === -1 && !_this.isNavigatorOnline) {\n                _this.logger.info('Expected failure, the browser says it is not online at the moment');\n            }\n            else if (_this.reconnectParams && _this.connectingErrorsInRow >= _this.connectingErrorsThreshold) {\n                if (responseStatusCode >= 400 && responseStatusCode <= 599) {\n                    _this.resetReconnectParamsOnErrorThreshold();\n                }\n                else if (_this.reconnectParams.reconnectUrl && _this.connectingErrorsInRow % 3 === 0) {\n                    _this.logger.warn(\"\".concat(_this.connectingErrorsInRow, \" connection attempts, testing nominal service URL\"));\n                    // Make sure to finish the check before connection timeout passes to avoid unexpected FSM calls\n                    var timeoutMs = Math.min(_this.timeoutOptions.connectionTimeoutMs - (Date.now() - startTimestamp) - 500, _this.timeoutOptions.fetchTimeoutMs);\n                    _this.testNominalUrlConnectivity(timeoutMs)\n                        .then(function (result) {\n                        _this.connectionTracker.trackProgress('nomcheck', result ? 'ok' : 'failed');\n                        if (result) {\n                            _this.logger.warn('Nominal service URL is reachable, erasing cached reconnect URL');\n                            if (_this.reconnectParams) {\n                                delete _this.reconnectParams.reconnectUrl;\n                            }\n                        }\n                        else {\n                            _this.logger.warn('Nominal service URL is not reachable either, keeping cached reconnect URL');\n                        }\n                        _this.fsm.onAllocationFailed(false, undefined);\n                    }, function () {\n                        // Should not happen, but removes no-floating-promises warning\n                        _this.fsm.onAllocationFailed(false, undefined);\n                    });\n                    return;\n                }\n            }\n            _this.fsm.onAllocationFailed(responseStatusCode === 401, responseClaimsChallenge);\n        });\n    };\n    TrouterConnection.prototype.testNominalUrlConnectivity = function (timeoutMs) {\n        var _this = this;\n        if (timeoutMs < 1000) {\n            this.logger.warn(\"There is no time left to reasonably perform the nominal service URL connectivity check (\".concat(timeoutMs, \" ms), falling back to assuming that the connectivity is fine\"));\n            return Promise.resolve(true);\n        }\n        var testRequest;\n        try {\n            var url = new URL(this.options.trouterUrl);\n            // Modify the URL to reach the root page (which returns a plain text string \"Trouter\")\n            url.pathname = '/';\n            // Add a few query parameters for possible classification and troubleshooting\n            url.search = '?' + this.buildQuery({\n                check: Date.now(),\n                cor_id: encodeURIComponent(this.options.clientCorrelationID),\n                epid: encodeURIComponent(this.options.endpointId ? this.options.endpointId : ''),\n                tc: encodeURIComponent((0, Common_1.toJson)(this.clientInfo))\n            });\n            testRequest = new Request(this.options.rewriteUrlForProxy(url.toString()), {\n                method: 'GET',\n                headers: { Accept: 'text/plain' }\n            });\n        }\n        catch (error) {\n            this.logger.warn(\"Nominal service URL connectivity test request could not be created (\".concat(error, \"), falling back to assuming that the connectivity is fine\"));\n            return Promise.resolve(true);\n        }\n        return (0, Common_1.fetchWithTimeout)(testRequest, timeoutMs)\n            .then(function (response) {\n            if (response.status !== 200) {\n                throw new Error(\"Not 200 OK: \".concat(response.status, \" \").concat(response.statusText));\n            }\n            return response.text();\n        })\n            .then(function (body) {\n            if (body !== 'Trouter') {\n                throw new Error(\"Not \\\"Trouter\\\": \".concat(body.substring(0, 16)).concat(body.length > 16 ? '...' : ''));\n            }\n            return true;\n        })\n            .catch(function (error) {\n            _this.logger.error(\"Nominal service URL connectivity test failed: \".concat(error));\n            return false;\n        });\n    };\n    TrouterConnection.prototype.sendPingRequest = function () {\n        var _this = this;\n        if (this.socket && this.pingResponseTimerId === undefined) {\n            try {\n                this.logger.debug('emitting ping event');\n                var timeoutReached_1 = false;\n                this.socket.emit('ping', function () {\n                    if (timeoutReached_1 === true) {\n                        return;\n                    }\n                    _this.onPingResponse();\n                });\n                this.pingResponseTimerId = setTimeout(function () {\n                    _this.logger.error('Ping response timeout is fired');\n                    timeoutReached_1 = true;\n                    _this.clearPingResponseTimer();\n                    _this.fsm.onPingResponseTimeout();\n                }, this.timeoutOptions.pongTimeoutMs);\n            }\n            catch (error) {\n                var msg = errorStackToJson(error);\n                this.logger.error(\"unable to send ping. Error: \".concat(msg));\n                this.connectionTracker.trackError('ping', msg, false);\n            }\n        }\n    };\n    TrouterConnection.prototype.connectV4c = function (token, reason) {\n        var _a, _b, _c, _d, _e, _f;\n        var options = this.options.ioOptions ? __assign({}, this.options.ioOptions) : new SocketIoOptions();\n        // Regardless of any passed in socket.io options, force the following settings.\n        options['force new connection'] = true;\n        options.reconnect = false;\n        if (((_a = this.reconnectParams) === null || _a === void 0 ? void 0 : _a.serviceUrl) &&\n            // previous input URL != current input URL (passed via `start()`)\n            (0, ProtocolAdapters_1.adaptUrl)(this.reconnectParams.serviceUrl, 'v4c') !== (0, ProtocolAdapters_1.adaptUrl)(this.options.trouterUrl, 'v4c')) {\n            this.logger.warn(\"Dropping cached connection parameters for a different environment (\".concat(this.reconnectParams.serviceUrl, \", now \").concat(this.options.trouterUrl, \")\"));\n            this.reconnectParams = undefined;\n        }\n        var inputUrl = (_d = (_b = (0, ProtocolAdapters_1.redirectUrlIfPresent)(reason)) !== null && _b !== void 0 ? _b : ((reason === null || reason === void 0 ? void 0 : reason.kind) !== 'redirect-no-host' ? (_c = this.reconnectParams) === null || _c === void 0 ? void 0 : _c.reconnectUrl : undefined)) !== null && _d !== void 0 ? _d : this.options.trouterUrl;\n        var url = (0, ProtocolAdapters_1.adaptUrl)(inputUrl, 'v4c');\n        options['skipped handshake data'] = {\n            timeout: 70,\n            websocketUrl: url\n        };\n        options.query = this.buildV4cUrlParams();\n        options.rewriteUrlForProxy = this.options.rewriteUrlForProxy;\n        try {\n            this.stopSocketIo();\n            this.transportTypeName = 'websocket';\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-assignment\n            this.socket = ((_e = this.options.io) !== null && _e !== void 0 ? _e : io).connect(this.options.trouterUrl, options);\n            if (this.socket === undefined) {\n                throw new Error('failed to create Socket.io object');\n            }\n            var audienceSubscriptionStateSnapshot = (_f = this.audienceSubscriptionState) === null || _f === void 0 ? void 0 : _f.increaseCvAndGetEventObject();\n            this.attachSocketIoHandlers(this.socket, token, undefined, audienceSubscriptionStateSnapshot);\n        }\n        catch (e) {\n            this.logger.error(\"\".concat(e));\n            this.connectionTracker.trackError('v4c', \"\".concat(e));\n            this.fsm.onV4cException();\n        }\n    };\n    TrouterConnection.prototype.sendV4cAuthenticationEvent = function (token) {\n        var _a;\n        var payload = {\n            headers: __assign(__assign({}, this.options.extraConnectionHeaders), headersFromToken(token, this.usingLegacyTokenApi)),\n            connectparams: (0, ProtocolAdapters_1.reconnectParamsWithoutUrls)(this.reconnectParams)\n        };\n        (_a = this.socket) === null || _a === void 0 ? void 0 : _a.emit(Constants_1.USER_AUTHENTICATE_EVENT_NAME, payload);\n    };\n    TrouterConnection.prototype.setUserActivityState = function (userActivityObject) {\n        var changed = (userActivityObject.state !== this.userActivityState.state);\n        this.userActivityState = userActivityObject;\n        if (changed) {\n            this.logger.info(\"Changing user activity state to '\".concat(userActivityObject.toEventJSON(), \"'\"));\n            this.fsm.onSetNewUserActivityState();\n        }\n        else {\n            this.logger.debug(\"Not changing the same user activity state '\".concat(userActivityObject.toEventJSON(), \"'\"));\n            this.manager.onUserActivityStateAccepted(userActivityObject.correlationVector.value());\n        }\n    };\n    TrouterConnection.prototype.sendUserActivityState = function (reason, connected) {\n        if (this.userActivityState.state === Interfaces_1.UserActivityState.Unknown) {\n            return;\n        }\n        if (this.transportTypeName === 'websocket' && connected) {\n            if (reason === InternalInterfaces_1.UserActivityEventReason.Connected) {\n                this.sendUserActivityStateMultiple(2);\n            }\n            else {\n                this.sendUserActivityStateMultiple(1);\n            }\n        }\n        else if (this.transportTypeName === 'xhr-polling') { // ignoring the connected flag\n            if (reason === InternalInterfaces_1.UserActivityEventReason.Modified) {\n                this.fsm.forceReconnect('user activity/force reconnect');\n            }\n        }\n    };\n    TrouterConnection.prototype.setAudienceSubscriptionsAsync = function (audienceSubscriptionState, timeoutInMs) {\n        var previousAudienceSubscriptionState = this.audienceSubscriptionState;\n        this.audienceSubscriptionState = audienceSubscriptionState;\n        if (this.transportTypeName === this.WEBSOCKET_TRANSPORT_NAME) {\n            return this.setAudienceSubscriptionsInternalAsync(audienceSubscriptionState.increaseCvAndGetEventObject(), timeoutInMs);\n        }\n        if (this.transportTypeName === this.XHR_POLLING_TRANSPORT_NAME) {\n            var setAudienceSubscriptionsPromise = this.setAudienceSubscriptionsLongpollInternalAsync(audienceSubscriptionState.increaseCvAndGetEventObject(), timeoutInMs, previousAudienceSubscriptionState);\n            this.fsm.forceReconnect('set audience subscription force reconnect');\n            return setAudienceSubscriptionsPromise;\n        }\n        throw new Error('set audience subscription executed on an unknown transport');\n    };\n    TrouterConnection.prototype.setAudienceSubscriptionsUnsafeAsync = function (audienceSubscriptionSnapshot) {\n        if (!audienceSubscriptionSnapshot) {\n            return undefined;\n        }\n        if (this.transportTypeName === this.WEBSOCKET_TRANSPORT_NAME) {\n            return this.setAudienceSubscriptionsInternalAsync(audienceSubscriptionSnapshot, 15000);\n        }\n    };\n    TrouterConnection.prototype.setAudienceSubscriptionsInternalAsync = function (audienceSubscriptionSnapshot, timeoutInMs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var audienceSubscriptionEvent, result;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.logger.info('[WebSocket] Audience subscription set requested.');\n                        audienceSubscriptionEvent = new DownstreamEvent('audience.subscribe');\n                        audienceSubscriptionEvent.args = audienceSubscriptionSnapshot;\n                        return [4 /*yield*/, new Promise(function (resolve) {\n                                var hasTimedOut = false;\n                                var timeoutId = setTimeout(function () {\n                                    hasTimedOut = true;\n                                    return resolve(_this.buildAudienceSubscriptionsTimeoutResponse(audienceSubscriptionSnapshot));\n                                }, timeoutInMs);\n                                _this.sendDownstreamEvent(audienceSubscriptionEvent, function (_, args) {\n                                    if (hasTimedOut) {\n                                        return;\n                                    }\n                                    clearTimeout(timeoutId);\n                                    _this.logger.debug(\"[Websocket] Audience subscription response: \".concat(args));\n                                    if (_this.pendingAudienceSubscription) {\n                                        _this.onAudienceSubscriptionResult(args);\n                                    }\n                                    resolve(args);\n                                });\n                            })];\n                    case 1:\n                        result = _a.sent();\n                        this.manager.onAudiencesSetResolved(result, audienceSubscriptionSnapshot.cv);\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    TrouterConnection.prototype.setAudienceSubscriptionsLongpollInternalAsync = function (audienceSubscriptionSnapshot, timeoutInMs, previousSubscriptionState) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var result, currentResponse, currentAudienceResponse, subscribesToDifferentAudience, synthResponses;\n            var _b;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        this.logger.info('[XHR Polling] Audience subscription set requested.');\n                        if (this.pendingAudienceSubscription) {\n                            this.logger.error('Racing audience subscriptions occured. This situation resolves into undefined scenario and/or nasal demons.');\n                            clearTimeout(this.pendingAudienceSubscription.timeoutId);\n                        }\n                        if (audienceSubscriptionSnapshot.audiences.length === 0) {\n                            return [2 /*return*/, this.handleAudienceUnsubscribeLongpoll(audienceSubscriptionSnapshot.cv, previousSubscriptionState)];\n                        }\n                        return [4 /*yield*/, new Promise(function (resolve) {\n                                var timeoutId = setTimeout(function () {\n                                    _this.pendingAudienceSubscription = undefined;\n                                    return resolve(_this.buildAudienceSubscriptionsTimeoutResponse(audienceSubscriptionSnapshot));\n                                }, timeoutInMs);\n                                _this.pendingAudienceSubscription = {\n                                    audienceSetResolve: resolve,\n                                    timeoutId: timeoutId\n                                };\n                            })];\n                    case 1:\n                        result = _c.sent();\n                        if (this.manager.getState() === Interfaces_1.TrouterState.Unknown || this.transportTypeName === this.WEBSOCKET_TRANSPORT_NAME) {\n                            return [2 /*return*/, result];\n                        }\n                        currentResponse = result.responses[0];\n                        if ((currentResponse === null || currentResponse === void 0 ? void 0 : currentResponse.result.audienceSubscriptionState) === this.AUDIENCE_SUBSCRIPTION_RESULT_BAD_REQUEST) {\n                            this.clearAudienceSubscriptionStateQueryParam();\n                            this.manager.onAudiencesSetResolved(result, audienceSubscriptionSnapshot.cv);\n                            return [2 /*return*/, result];\n                        }\n                        currentAudienceResponse = result.responses.find(function (r) { return r.audienceId === audienceSubscriptionSnapshot.audiences[0].id; });\n                        if ((currentAudienceResponse === null || currentAudienceResponse === void 0 ? void 0 : currentAudienceResponse.result.audienceSubscriptionState) === this.AUDIENCE_SUBSCRIPTION_RESULT_ERROR) {\n                            this.clearAudienceSubscriptionStateQueryParam();\n                            this.manager.onAudiencesSetResolved(result, audienceSubscriptionSnapshot.cv);\n                            return [2 /*return*/, result];\n                        }\n                        subscribesToDifferentAudience = ((_a = previousSubscriptionState === null || previousSubscriptionState === void 0 ? void 0 : previousSubscriptionState.audienceSubscriptionModel.audienceSubscriptions[0]) === null || _a === void 0 ? void 0 : _a.id) !== (currentResponse === null || currentResponse === void 0 ? void 0 : currentResponse.audienceId);\n                        if (previousSubscriptionState && subscribesToDifferentAudience) {\n                            synthResponses = this.mapToSyntheticAudienceSubscriptionResponses(previousSubscriptionState.audienceSubscriptionModel.audienceSubscriptions, this.AUDIENCE_SUBSCRIPTION_RESULT_UNSUBSCRIBED, 200);\n                            (_b = result.responses).push.apply(_b, synthResponses);\n                        }\n                        this.manager.onAudiencesSetResolved(result, audienceSubscriptionSnapshot.cv);\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    // remove the `audienceSubscriptionState` param from longpoll query string so the subscription is not attempted over and over creating loop\n    TrouterConnection.prototype.clearAudienceSubscriptionStateQueryParam = function () {\n        var _a, _b, _c;\n        if ((_c = (_b = (_a = this.socket) === null || _a === void 0 ? void 0 : _a.socket) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.query) {\n            this.socket.socket.options.query = this.socket.socket.options.query.replace(this.AUDIENCE_SUBSCRIPTION_STATE_QUERY_PARAM_REGEX, '');\n        }\n    };\n    TrouterConnection.prototype.handleAudienceUnsubscribeLongpoll = function (correlationVector, previousSubscriptionState) {\n        var _a;\n        this.audienceSubscriptionState = undefined;\n        var result = {\n            responses: []\n        };\n        if (previousSubscriptionState) {\n            var synthResponses = this.mapToSyntheticAudienceSubscriptionResponses(previousSubscriptionState.audienceSubscriptionModel.audienceSubscriptions, this.AUDIENCE_SUBSCRIPTION_RESULT_UNSUBSCRIBED, 200);\n            (_a = result.responses).push.apply(_a, synthResponses);\n        }\n        this.manager.onAudiencesSetResolved(result, correlationVector);\n        return result;\n    };\n    TrouterConnection.prototype.buildAudienceSubscriptionsTimeoutResponse = function (audienceSubscriptionSnapshot) {\n        this.logger.error(\"Audience subscription attempt has timed out.\");\n        return {\n            responses: this.mapToSyntheticAudienceSubscriptionResponses(audienceSubscriptionSnapshot.audiences, this.AUDIENCE_SUBSCRIPTION_RESULT_TIMEOUT)\n        };\n    };\n    TrouterConnection.prototype.mapToSyntheticAudienceSubscriptionResponses = function (audiences, synthState, synthResponseStatus) {\n        return audiences\n            .map(function (audSub) { return ({\n            audienceId: audSub.id,\n            result: {\n                audienceSubscriptionState: synthState,\n                responseStatus: synthResponseStatus\n            }\n        }); });\n    };\n    TrouterConnection.prototype.expediteBackoff = function () {\n        this.tokenBackoff.expediteIfPending();\n    };\n    TrouterConnection.prototype.sendRegisterRequest = function () {\n        var _this = this;\n        if (!this.options.registration || !this.registrarClient) {\n            throw new Error('Internal error - options.registration is undefined');\n        }\n        if (!this.allocateResult) {\n            throw new Error('Allocate result is undefined in sendRegisterRequest()');\n        }\n        this.logger.info('sending register request');\n        var span = new Common_1.Timespan();\n        this.connectionTracker.trackStart('registration');\n        var registrationTtl = this.getRegistrationTtl()[0];\n        this.registrarClient.register({\n            appId: this.options.registration.pnhAppId,\n            aesKey: '',\n            languageId: 'en-US',\n            platform: this.options.registration.platform,\n            templateKey: this.options.registration.pnhTemplateKey,\n            platformUIVersion: this.options.registration.platformUIVersion,\n            productContext: this.options.registration.productContext\n        }, {\n            TROUTER: [{\n                    context: this.options.registration.context,\n                    path: this.allocateResult.surl,\n                    ttl: registrationTtl\n                }]\n        }).then(function () {\n            _this.logger.info('Register request successful');\n            _this.connectionTracker.trackEnd('registration');\n            _this.fsm.onRegistrationSucceeded();\n            _this.connectionTracker.sendTelemetry(ConnectionTracker_1.ClientEventName.Registration, {\n                duration: span.duration\n            }, []);\n        }).catch(function (error) {\n            _this.logger.error(\"Register request failed. Error: \".concat(error));\n            _this.connectionTracker.trackError('registration', errorMessageToString(error));\n            _this.fsm.onRegistrationFailed();\n            _this.connectionTracker.sendTelemetry(ConnectionTracker_1.ClientEventName.Registration, {\n                duration: span.duration\n            }, []);\n        });\n    };\n    TrouterConnection.prototype.sendUnregisterRequest = function () {\n        var _this = this;\n        this.logger.info('sending unregister request');\n        var span = new Common_1.Timespan();\n        if (!this.options.registration || !this.registrarClient) {\n            throw new Error('Internal error - options.registration is undefined');\n        }\n        this.connectionTracker.trackStart('unregistration');\n        this.registrarClient.unregister().then(function () {\n            _this.logger.info('Unregister request successful');\n            _this.connectionTracker.trackEnd('unregistration');\n            _this.fsm.onUnregistrationDone();\n            _this.connectionTracker.sendTelemetry(ConnectionTracker_1.ClientEventName.Unregistration, {\n                duration: span.duration\n            }, []);\n        }).catch(function (error) {\n            _this.logger.error(\"Unregister request failed. Error: \".concat(error));\n            _this.connectionTracker.trackError('unregistration', errorMessageToString(error));\n            // The Registrar Client library already does internal retries on 5xx HTTP responses etc.\n            // So if we end up here, something more exceptional must have happened. There is little\n            // point delaying the stopping further by trying again, just finish as if successful.\n            _this.fsm.onUnregistrationDone();\n            _this.connectionTracker.sendTelemetry(ConnectionTracker_1.ClientEventName.Unregistration, {\n                duration: span.duration\n            }, []);\n        });\n    };\n    TrouterConnection.prototype.resetTokenBackoff = function () {\n        this.tokenBackoff.reset();\n    };\n    TrouterConnection.prototype.cancelPendingRegistrationRequests = function () {\n        if (this.registrarClient) {\n            this.registrarClient.cancelPendingRequests();\n        }\n    };\n    TrouterConnection.prototype.clearSentEventTimers = function () {\n        var keys = Object.keys(this.pendingSentEventTimers);\n        if (keys.length > 0) {\n            this.logger.debug('Clearing all pending downstream events related timers');\n            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                var key = keys_1[_i];\n                this.clearSentEventTimer(Number(key));\n            }\n        }\n    };\n    TrouterConnection.prototype.restartIncallModeTimer = function () {\n        var _this = this;\n        this.clearIncallModeTimerId();\n        this.logger.debug('Restarting incall mode timer');\n        this.incallModeTimerId = setTimeout(function () {\n            _this.logger.info('Call mode timer fired');\n            _this.fsm.onIncallModeTimer();\n        }, this.options.incallModeTimeoutMs);\n    };\n    TrouterConnection.prototype.enterIncallMode = function () {\n        this.logger.info('Entering incall mode');\n        this.timeoutOptions = this.options.incallTimeoutOptions;\n        this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs);\n        // Uncomment to enable change of timeout in XHR mode - do it once server start to support it\n        // if (this.socket) {\n        //     this.socket.socket.options.query = this.buildSocketIoUrlParams();\n        // }\n        this.inIncallMode = true;\n    };\n    TrouterConnection.prototype.exitIncallMode = function () {\n        this.logger.info('Exiting incall mode');\n        this.clearIncallModeTimerId();\n        this.timeoutOptions = this.options.timeoutOptions;\n        this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs);\n        // Uncomment to enable change of timeout in XHR mode - do it once server start to support it\n        // if (this.socket) {\n        //     this.socket.socket.options.query = this.buildSocketIoUrlParams();\n        // }\n        this.inIncallMode = false;\n    };\n    TrouterConnection.prototype.isIncallMode = function () {\n        return this.inIncallMode;\n    };\n    TrouterConnection.prototype.sendDisconnectTelemetryEvent = function (reason) {\n        var props = { reason: reason, serverClosed: !this.fsm.isActive() };\n        this.connectionTracker.trackDisconnected(props);\n        this.connectionTracker.clearConnectedInfo();\n    };\n    TrouterConnection.prototype.forceReconnectDueToNoRegistration = function () {\n        this.fsm.forceReconnect('force reconnect due to no registration');\n    };\n    TrouterConnection.prototype.resetReconnectParamsOnErrorThreshold = function () {\n        this.logger.warn(\"\".concat(this.connectingErrorsInRow, \" connection attempts, server-side failure: erasing cached connection parameters\"));\n        this.reconnectParams = undefined;\n    };\n    ////////// SocketIO callbacks //////////\n    TrouterConnection.prototype.onSocketConnecting = function (transportTypeName) {\n        this.logger.info(\"onSocketConnecting(\".concat(transportTypeName, \")\"));\n        this.transportTypeName = transportTypeName;\n        this.connectionTracker.trackProgress('connecting', this.transportTypeName);\n        this.fsm.onConnecting();\n    };\n    TrouterConnection.prototype.onSocketConnect = function (token) {\n        this.logger.info('onSocketConnect');\n        this.fsm.onSocketConnect(token);\n    };\n    TrouterConnection.prototype.onSocketConnectFailed = function (reason) {\n        this.logger.error('onSocketConnectFailed');\n        this.connectionTracker.trackError('connect_failed', reason, true, this.transportTypeName ? this.transportTypeName : this.UNKNOWN_TRANSPORT);\n        this.fsm.onConnectingFailed();\n    };\n    TrouterConnection.prototype.onSocketDisconnect = function (rawReason) {\n        var sessionLengthMs = this.connectionTracker.getSessionLength() || 0;\n        var reason = DisconnectReason_1.DisconnectReason.fromRawReason(rawReason);\n        this.logger.error(\"onSocketDisconnect, reason: \".concat(reason.reason));\n        if (reason.reason === 'dup' && this.lastDisconnectReason === 'dup' &&\n            sessionLengthMs < this.options.duplicateDisconnectThresholdMs) {\n            this.logger.warn('Socket was closed by server as Duplicate for the second time in a row ' +\n                \"after \".concat(sessionLengthMs, \" ms which is below the threshold of \") +\n                \"\".concat(this.options.duplicateDisconnectThresholdMs, \" ms. Resetting cached \") +\n                'connection parameters and making a new allocation.');\n            this.reconnectParams = undefined;\n        }\n        this.lastDisconnectReason = reason.reason;\n        this.fsm.onSocketDisconnect(reason);\n        this.connectionExpireTimestampInSecs = undefined;\n    };\n    TrouterConnection.prototype.onSocketReconnect = function () {\n        // this callback should not be called, because reconnect on socket.io is disabled, but\n        // leave it here in case error in socket.io\n        this.logger.error('onSocketReconnect');\n        this.fsm.onTrouterConnected();\n    };\n    TrouterConnection.prototype.onSocketReconnectFailed = function (reason) {\n        // this callback should not be called, because reconnect on socket.io is disabled, but\n        // leave it here in case error in socket.io\n        this.logger.error(\"onSocketReconnectFailed with '\".concat(reason, \"'\"));\n        this.fsm.onSocketDisconnect(DisconnectReason_1.DisconnectReason.fromSocketIoEventData('reconnecterror', reason));\n    };\n    TrouterConnection.prototype.onSocketReconnecting = function () {\n        // this callback should not be called, because reconnect on socket.io is disabled, but\n        // leave it here in case error in socket.io\n        this.logger.error('onSocketReconnecting');\n    };\n    TrouterConnection.prototype.onSocketError = function (errorObject) {\n        this.logger.error(\"onSocketError with '\".concat((0, Common_1.toJson)(errorObject), \"'\"));\n        if (this.fsm.isConnecting()) {\n            this.connectingErrorsInRow++;\n            if (this.connectingErrorsInRow >= this.connectingErrorsThreshold) {\n                this.resetReconnectParamsOnErrorThreshold();\n            }\n        }\n        this.connectionTracker.trackError('connectSocket', safeToStringOrType(errorObject));\n        this.fsm.onSocketDisconnect(DisconnectReason_1.DisconnectReason.fromSocketIoEventData('socketerror', errorObject));\n    };\n    TrouterConnection.prototype.onSocketMessage = function (requestJson) {\n        var _this = this;\n        var _a;\n        this.logger.debug('onSocketMessage');\n        var request;\n        try {\n            request = new TrouterRequest(requestJson, this.logger);\n            var chainId = (_a = request.headers) === null || _a === void 0 ? void 0 : _a['X-Microsoft-Skype-Chain-ID'];\n            var chainIdLogText = chainId ? \" Chain-Id \".concat(chainId) : '';\n            this.logger.info(\"Received request N \".concat(request.id).concat(chainIdLogText, \" CV \").concat(request.correlationVector, \" to '\").concat(request.url, \"'\"));\n            request.startTS = Date.now();\n            if (request.url && this.urlPath && request.url.startsWith(this.urlPath)) {\n                request.shortUrl = request.url.substring(this.urlPath.length);\n            }\n        }\n        catch (error) {\n            var msg = errorStackToJson(error);\n            this.logger.error(\"unable to parse request. Error: \".concat(msg));\n            this.connectionTracker.trackRequest(undefined, msg);\n            this.connectionTracker.sendResponseError(\"unable to parse request, error: \".concat(error));\n            return;\n        }\n        request.timeoutTimerId = setTimeout(function () {\n            if (request.replied) {\n                return;\n            }\n            _this.logger.error(\"Request \".concat(request.id, \" timed out\"));\n            var responseData = new ConnectionTracker_1.ResponseData(request.id);\n            responseData.status = 504;\n            responseData.headers = { 'Trouter-Responder': 'ClientLib' };\n            _this.sendResponse(request, responseData);\n            request.timedout = true;\n        }, this.timeoutOptions.requestTimeoutMs);\n        try {\n            this.connectionTracker.trackRequest(request);\n            this.fsm.onDownstreamRequest(request);\n        }\n        catch (error) {\n            this.logger.error(\"exception in socket.on message. Error: \".concat(errorStackToJson(error)));\n            this.connectionTracker.sendResponseError(errorMessageToString(error), request, undefined);\n        }\n    };\n    TrouterConnection.prototype.onTrouterConnected = function (eventArgs, userActivitySnapshot, audienceSubscriptionSnapshot) {\n        var _this = this;\n        var _a, _b, _c, _d;\n        if ((0, ProtocolAdapters_1.isV4ConnectEvent)(eventArgs)) {\n            var v4cArgs = eventArgs;\n            this.allocateResult = __assign(__assign({}, v4cArgs), { ttl: eventArgs.ttl.toString() });\n            this.populateAndCacheReconnectParams(v4cArgs, v4cArgs.reconnectUrl);\n            this.populateConnectionStateFields(v4cArgs);\n        }\n        else if (!this.allocateResult) {\n            this.logger.error('Invalid internal state - received onTrouterConnected while allocateResult is not set');\n            return;\n        }\n        this.connectingErrorsInRow = 0;\n        this.logger.info(\"onTrouterConnected: \".concat(this.allocateResult.url));\n        if (this.transportTypeName === 'xhr-polling' && userActivitySnapshot) {\n            this.manager.onUserActivityStateAccepted(userActivitySnapshot.cv);\n        }\n        // Prevent next 'trouter.connected' responses from other trouter nodes\n        // hackish way, since socket.io doesn't have API for that\n        if ((_c = (_b = (_a = this.socket) === null || _a === void 0 ? void 0 : _a.socket) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.query) {\n            this.socket.socket.options.query += '&connected=true';\n        }\n        // Strip off the first part of the URL, up to the path\n        // eslint-disable-next-line no-useless-escape\n        this.urlPath = this.allocateResult.url.replace(/https?:\\/\\/([A-z0-9\\:\\$\\-\\_\\.\\+\\!\\*\\\"\\(\\)\\,]*)\\//, '/');\n        var isNewUrl = (this.connectedUrl !== this.allocateResult.url);\n        this.connectedUrl = this.allocateResult.url;\n        this.connectionExpireTimestampInSecs = (0, Common_1.calculateExpireTsInSec)((0, ProtocolAdapters_1.ensureNumber)(eventArgs.ttl));\n        this.connectionTracker.trackEnd('connectSocket');\n        this.connectionTracker.trackConnected(isNewUrl, this.transportTypeName ? this.transportTypeName : this.UNKNOWN_TRANSPORT);\n        (_d = this.setAudienceSubscriptionsUnsafeAsync(audienceSubscriptionSnapshot)) === null || _d === void 0 ? void 0 : _d.catch(function (reason) { return _this.logger.error(\"Re-subscribe to audiences has failed with \".concat(reason)); });\n        this.fsm.onTrouterConnected();\n    };\n    TrouterConnection.prototype.onTrouterReconnect = function (eventArgs) {\n        var target = eventArgs.target;\n        this.logger.info(\"onTrouterReconnect target: \".concat(target));\n        if (target === 'self') {\n            this.fsm.onReconnectRequired(true, ReconnectReason.ServerInitiated);\n        }\n        else {\n            this.fsm.onReconnectRequired(false, ReconnectReason.ServerInitiated, eventArgs);\n        }\n    };\n    TrouterConnection.prototype.onTrouterMessageLoss = function (eventArgs) {\n        this.logger.debug('onTrouterMessageLoss');\n        // Send only array of tags for further processing\n        this.fsm.onTrouterMessageLost(eventArgs.droppedIndicators);\n    };\n    TrouterConnection.prototype.onAudienceSubscriptionResult = function (eventArgs) {\n        this.logger.info('onAudienceSubscriptionResult');\n        if (!this.pendingAudienceSubscription) {\n            return;\n        }\n        clearTimeout(this.pendingAudienceSubscription.timeoutId);\n        this.pendingAudienceSubscription.audienceSetResolve(eventArgs);\n        this.pendingAudienceSubscription = undefined;\n    };\n    ////////// Other functions //////////\n    TrouterConnection.prototype.buildV4cUrlParams = function () {\n        var urlParams = {};\n        urlParams.tc = encodeURI((0, Common_1.toJson)(this.clientInfo));\n        urlParams.timeout = Math.floor(this.timeoutOptions.pingTimeoutMs / 1000);\n        if (this.options.endpointId) {\n            urlParams.epid = this.options.endpointId;\n        }\n        return this.appendConnectedClientIds(this.buildQuery(urlParams), true);\n    };\n    TrouterConnection.prototype.attachSocketIoHandlers = function (socket, token, userActivitySnapshot, audienceSubscriptionSnapshot) {\n        var _this = this;\n        socket.on('connecting', function (transportTypeName) { _this.onSocketConnecting(transportTypeName); });\n        socket.on('connect', function () { _this.onSocketConnect(token); });\n        socket.on('connect_failed', function (reason) { _this.onSocketConnectFailed(reason); });\n        socket.on('close_during_connecting', function (reason) { _this.onSocketConnectFailed(reason); });\n        socket.on('disconnect', function (reason) { _this.onSocketDisconnect(reason); });\n        socket.on('reconnect', function () { _this.onSocketReconnect(); });\n        socket.on('reconnect_failed', function (reason) { _this.onSocketReconnectFailed(reason); });\n        socket.on('reconnecting', function () { _this.onSocketReconnecting(); });\n        socket.on('error', function (error) { _this.onSocketError(error); });\n        socket.on('message', function (request) { _this.onSocketMessage(request); });\n        socket.on('trouter.connected', function (eventArgs) { _this.onTrouterConnected(eventArgs, userActivitySnapshot, audienceSubscriptionSnapshot); });\n        socket.on('trouter.reconnect', function (eventArgs) { _this.onTrouterReconnect(eventArgs); });\n        socket.on('trouter.message_loss', function (eventArgs) { _this.onTrouterMessageLoss(eventArgs); });\n        // event valid only for long polling\n        // when user subscribes for audience events a query param `audienceSubscriptionState` is added to all long poll GETs \n        // if the audience subscription state differs from the one defined on server, it will adjust its state to be identical\n        // after audience set opeartion finished server side `audience.subscriptionresult` is fired marking the end of asynchronous operation\n        socket.on('audience.subscriptionresult', function (_, eventArgs) { _this.onAudienceSubscriptionResult(eventArgs); });\n    };\n    TrouterConnection.prototype.onNavigatorOnlineStatusUpdate = function () {\n        var state = window.navigator.onLine;\n        this.logger.debug(\"Browser online status update - new state: \".concat(state, \", previously: \").concat(this.isNavigatorOnline));\n        if (state && !this.isNavigatorOnline) {\n            this.isNavigatorOnline = true;\n            this.tokenBackoff.expediteIfPending();\n            this.connectionTracker.trackProgress('browserNet', 'online');\n        }\n        else if (!state && this.isNavigatorOnline) {\n            this.isNavigatorOnline = false;\n            this.connectionTracker.trackProgress('browserNet', 'offline');\n        }\n    };\n    TrouterConnection.prototype.onAllocationResponse = function (allocateResult, token) {\n        this.logger.info(\"Received allocation response \".concat(JSON.stringify(allocateResult)));\n        this.allocateResult = allocateResult;\n        this.populateAndCacheReconnectParams(this.allocateResult, \"\".concat(this.allocateResult.socketio, \"v4/a\"));\n        this.populateConnectionStateFields(this.allocateResult);\n        this.fsm.onAllocationSucceed(token);\n    };\n    TrouterConnection.prototype.populateAndCacheReconnectParams = function (args, reconnectUrl) {\n        this.reconnectParams = __assign({ serviceUrl: this.options.trouterUrl, reconnectUrl: reconnectUrl }, args.connectparams);\n        this.manager.onConnectionParametersUpdated(this.reconnectParams);\n    };\n    TrouterConnection.prototype.populateConnectionStateFields = function (args) {\n        var _a, _b;\n        var ttl = typeof args.ttl === 'string' ? parseInt(args.ttl, 10) : args.ttl;\n        // Don't use allocateResult.connectparams.se here since system clock can be\n        // incorrect on client's machine, so using TTL is safer\n        this.connectionExpireTimestampInSecs = (0, Common_1.calculateExpireTsInSec)(ttl);\n        this.connectionId = (_a = args.id) !== null && _a !== void 0 ? _a : '';\n        this.connectedClientId = args.ccid;\n        this.logger.debug(\"connected client id set {connectedClientId:\".concat(this.connectedClientId, \"}\"));\n        this.c2cUrlBase = (_b = args.curlb) !== null && _b !== void 0 ? _b : '';\n        if (this.c2cUrlBase === '') {\n            // Try to just remove the port as a fallback if the service didn't provide anything\n            var pos = args.surl.indexOf('://');\n            if (pos >= 0) {\n                pos = args.surl.indexOf('/', pos + 3);\n                if (pos >= 5 && args.surl.substr(pos - 5, 5) === ':3443') {\n                    this.c2cUrlBase = args.surl.substr(0, pos - 5);\n                }\n            }\n        }\n    };\n    TrouterConnection.prototype.onPingResponse = function () {\n        this.logger.debug('onPingResponse');\n        this.connectionTracker.increasePingResponseCount();\n        this.clearPingResponseTimer();\n        this.fsm.onPingResponse();\n    };\n    TrouterConnection.prototype.clearPingResponseTimer = function () {\n        if (this.pingResponseTimerId !== undefined) {\n            clearTimeout(this.pingResponseTimerId);\n            this.pingResponseTimerId = undefined;\n        }\n    };\n    TrouterConnection.prototype.buildQuery = function (map) {\n        // TO-DO: Replace this and all other similar functions around with URLSearchParams\n        var components = [];\n        for (var _i = 0, _a = Object.keys(map); _i < _a.length; _i++) {\n            var i = _a[_i];\n            if (map[i] !== undefined) {\n                components.push(\"\".concat(i, \"=\").concat(map[i]));\n            }\n        }\n        return components.join('&');\n    };\n    TrouterConnection.prototype.appendConnectedClientIds = function (url, isParamsOnly) {\n        var params = '';\n        if (!url.includes('ccid=')) {\n            params = \"ccid=\".concat(this.connectedClientId, \"&\");\n        }\n        if (this.domId) {\n            params += \"dom=\".concat(this.domId, \"&\");\n        }\n        if (params.length > 0) {\n            params = params.slice(0, -1);\n        }\n        var sep = (isParamsOnly || url.includes('?')) ? ('&') : ('?');\n        return this.appendCorrelationIds(url + sep + params, isParamsOnly);\n    };\n    TrouterConnection.prototype.appendEndpointId = function (url, isParamsOnly) {\n        var sep = (isParamsOnly || url.includes('?')) ? ('&') : ('?');\n        return (!url.includes('epid') && this.options.endpointId)\n            ? \"\".concat(url).concat(sep, \"epid=\").concat(this.options.endpointId)\n            : url;\n    };\n    TrouterConnection.prototype.appendCorrelationIds = function (url, isParamsOnly) {\n        var sep = (isParamsOnly || url.includes('?')) ? ('&') : ('?');\n        return (!url.includes('cor_id'))\n            ? \"\".concat(url).concat(sep, \"cor_id=\").concat(this.options.clientCorrelationID)\n                + \"&con_num=\".concat(this.clientID, \"_\").concat(this.connectionAttempt)\n            : url;\n    };\n    TrouterConnection.prototype.safeString = function (str) {\n        return (typeof str === 'string') ? str : '';\n    };\n    TrouterConnection.prototype.sendResponse = function (request, responseData) {\n        var _a, _b, _c;\n        if (request.timedout) {\n            this.logger.error(\"Request \".concat(request.id, \" already timed out\"));\n            return 1 /* SendResponseResult.Timeout */;\n        }\n        if (request.replied) {\n            this.logger.error(\"Response for request \".concat(request.id, \" already sent\"));\n            return 2 /* SendResponseResult.Duplicate */;\n        }\n        clearTimeout(request.timeoutTimerId);\n        request.timeoutTimerId = undefined;\n        request.replied = true;\n        responseData.headers = (_a = responseData.headers) !== null && _a !== void 0 ? _a : {};\n        var cv = request.correlationVector;\n        this.logger.info(\"Sending response N \".concat(request.id, \" CV \").concat(cv, \" with status \").concat(responseData.status));\n        if (cv) {\n            responseData.headers[cvHeader] = cv;\n        }\n        // Echo back the incoming \"trouter-request\" header\n        if ((_b = request.headers) === null || _b === void 0 ? void 0 : _b['trouter-request']) {\n            responseData.headers['trouter-request'] = request.headers['trouter-request'];\n        }\n        // Fill in \"trouter-client\" header\n        var latencyMS = Date.now() - request.startTS;\n        responseData.headers['trouter-client'] = (0, Common_1.toJson)({\n            cd: latencyMS\n        });\n        // Echo back \"trouter-is-broadcast\" header\n        if ((_c = request.headers) === null || _c === void 0 ? void 0 : _c['trouter-is-broadcast']) {\n            responseData.headers['trouter-is-broadcast'] = request.headers['trouter-is-broadcast'];\n        }\n        this.logger.debug(\"response: \".concat((0, Common_1.toJson)(responseData)));\n        if (this.socket) {\n            try {\n                this.socket.send((0, Common_1.toJson)(responseData));\n                responseData.sentTS = Date.now();\n                request.incrementCorrelationVector();\n                this.connectionTracker.trackResponse(request, latencyMS, responseData);\n                if (this.transportTypeName === 'websocket') {\n                    // Send ping request immediately to emulate 'ack' from server, so\n                    // client can faster react on network issues\n                    this.sendPingRequest();\n                }\n                return 0 /* SendResponseResult.OK */;\n            }\n            catch (error) {\n                var errorMsg = \"unable to send data on response.end. Error: \".concat(errorStackToJson(error));\n                this.logger.error(errorMsg);\n                this.connectionTracker.sendResponseError(errorMsg, request, responseData);\n                return 4 /* SendResponseResult.Disconnected */;\n            }\n        }\n        else {\n            this.connectionTracker.sendResponseError('no socket', request, responseData);\n            return 4 /* SendResponseResult.Disconnected */;\n        }\n    };\n    /*\n        Sends the activity state event to Trouter.\n        Has implemented support for sending the current state twice (or multiple times)\n        after reconnect, first immediately, and theen the second after configured delay.\n\n        If after the first sent state event the client app changes the state,\n        the new state is sent in the second event after the delay.\n        Meanwhile the new state is also sent immediately upon\n        the change, but the planned second sending (after delay) is triggered anyway,\n        to fulfill it's purpose, which is to prevent server-side race condition.\n     */\n    TrouterConnection.prototype.sendUserActivityStateMultiple = function (remaining) {\n        var _this = this;\n        var activityEvent = new DownstreamEvent('user.activity');\n        var activityEventObject = this.userActivityState.increaseCvAndGetEventObject();\n        activityEvent.args = activityEventObject;\n        this.logger.debug(\"Sending user activity '\".concat(this.userActivityState.toEventJSON(), \"', remaining \").concat(remaining - 1));\n        var timeoutReached = false;\n        this.sendDownstreamEvent(activityEvent, function () {\n            if (timeoutReached === true) {\n                return;\n            }\n            _this.logger.info(\"User activity state: \".concat(activityEventObject.state, \", cv: \").concat(activityEventObject.cv, \" accepted\"));\n            _this.manager.onUserActivityStateAccepted(activityEventObject.cv);\n            _this.clearSentEventTimer(activityEvent.timeoutTimerId);\n            if (remaining > 1) {\n                var timerId_1 = setTimeout(function () {\n                    _this.clearSentEventTimer(timerId_1);\n                    _this.sendUserActivityStateMultiple(remaining - 1);\n                }, _this.options.userActivitySecondResendDelayMs);\n                _this.registerSentEventTimer(timerId_1, 'user.activity/resend');\n            }\n        });\n        activityEvent.timeoutTimerId = setTimeout(function () {\n            _this.logger.error('Activity state response timeout is fired');\n            timeoutReached = true;\n            _this.fsm.onActivityStateResponseTimeout();\n            _this.clearSentEventTimer(activityEvent.timeoutTimerId);\n        }, this.timeoutOptions.userActivityResponseTimeoutMs);\n        this.registerSentEventTimer(activityEvent.timeoutTimerId, 'user.activity/response');\n    };\n    TrouterConnection.prototype.sendDownstreamEvent = function (event, responseCallback) {\n        this.logger.debug(\"Sending downstream event \".concat(event.name));\n        if (this.socket) {\n            this.socket.emit(event.name, event.args, responseCallback);\n        }\n    };\n    TrouterConnection.prototype.registerSentEventTimer = function (timerId, timerDescription) {\n        this.logger.debug(\"registering timer \".concat(timerId, \" -> \").concat(timerDescription));\n        this.pendingSentEventTimers[timerId] = timerDescription;\n    };\n    TrouterConnection.prototype.clearSentEventTimer = function (id) {\n        var timerDescription = this.pendingSentEventTimers[id];\n        this.logger.debug(\"clearing timer \".concat(id, \" -> \").concat(timerDescription));\n        delete this.pendingSentEventTimers[id];\n        clearTimeout(id);\n    };\n    /**\n     * Calculate registration interval. Result is based on configuration parameters\n     * and allocation ttl value from trouter server.\n     * Returns true only if the registration ttl is present and is smaller than known `allocationTtl`.\n     * This means we'll need to re-register to keep the registration alive for the duration of the allocation.\n     */\n    TrouterConnection.prototype.getRegistrationTtl = function () {\n        var _a, _b;\n        var allocationTtl = (0, Common_1.calculateTtlInSec)(this.connectionExpireTimestampInSecs);\n        this.logger.debug(\"Current connectionID will expire in \".concat(allocationTtl, \" seconds\"));\n        if (((_a = this.options.registration) === null || _a === void 0 ? void 0 : _a.registrarTtlSec) && allocationTtl > 0) {\n            var isLower = this.options.registration.registrarTtlSec < allocationTtl;\n            return [Math.min(this.options.registration.registrarTtlSec, allocationTtl), isLower];\n        }\n        else if ((_b = this.options.registration) === null || _b === void 0 ? void 0 : _b.registrarTtlSec) {\n            return [this.options.registration.registrarTtlSec, false];\n        }\n        else if (allocationTtl > 0) {\n            return [allocationTtl, false];\n        }\n        return [DEFAULT_REGISTRATION_TIMEOUT_SEC, false];\n    };\n    TrouterConnection.prototype.clearIncallModeTimerId = function () {\n        if (this.incallModeTimerId !== undefined) {\n            this.logger.debug('Clearing in-call mode timer');\n            clearTimeout(this.incallModeTimerId);\n            this.incallModeTimerId = undefined;\n        }\n    };\n    TrouterConnection.prototype.applyConnectionTrackerOptions = function (options) {\n        try {\n            var eventLoggerSent = (options.eventLogger && typeof options.eventLogger.logEvent === 'function');\n            if (!eventLoggerSent) {\n                this.logger.warn('Trouter client event logging disabled due to invalid configuration.');\n            }\n            else {\n                this.connectionTracker.mergeSettings(options.telemetrySettings);\n                this.connectionTracker.enable(options.eventLogger);\n            }\n        }\n        catch (error) {\n            this.logger.warn(\"Trouter client event logging disabled. Error: \".concat(errorStackToJson(error)));\n            this.connectionTracker.disable();\n        }\n    };\n    /**\n     * Returns boolean indicating if we can retry token fetch\n     * based on value of optional configuration 'retryLimitOnTokenFetch'\n     * @returns boolean\n     */\n    TrouterConnection.prototype.canRetryTokenFetchRequest = function (currentCounter) {\n        var retryLimit = this.options.retryLimitOnTokenFetch;\n        if (retryLimit === null || retryLimit === undefined) {\n            return true;\n        }\n        if (currentCounter < retryLimit) {\n            return true;\n        }\n        this.logger.warn(\"Reached limit on maximum number of token fetch request. Current count: \".concat(currentCounter, \", retry limit: \").concat(retryLimit));\n        return false;\n    };\n    return TrouterConnection;\n}());\nexports.TrouterConnection = TrouterConnection;\nfunction headersFromToken(token, usingLegacyTokenApi) {\n    var migrationHeader = usingLegacyTokenApi ? undefined : { 'X-MS-Migration': 'True' };\n    switch (token.tokenType.toLowerCase()) {\n        case 'skype':\n            return __assign({ 'X-Skypetoken': token.token }, migrationHeader);\n        case 'aad':\n        case 'cae':\n            return __assign({ Authorization: \"Bearer \".concat(token.token) }, migrationHeader);\n        default:\n            throw new Error(\"unsupported token type: \".concat(token.tokenType));\n    }\n}\nfunction safeToStringOrType(value) {\n    if (value !== undefined && value !== null && typeof value.toString === 'function') {\n        return value.toString();\n    }\n    return \"[\".concat(typeof value, \"]\");\n}\nfunction errorStackToJson(error) {\n    if (typeof error === 'object' && error !== null && error.stack !== undefined) {\n        // Keeping this as it was for now, but `error.stack` is usually just a string anyway.\n        // I guess it also converts newlines to '\\n', which some part may need? Or it's completely unnecessary?\n        return (0, Common_1.toJson)(error.stack);\n    }\n    return '\"(no error.stack)\"';\n}\nfunction errorMessageToString(error) {\n    if (typeof error === 'object' && error !== null && typeof error.message === 'string') {\n        return error.message;\n    }\n    return '(no error.message)';\n}\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageHandlerRegistry = void 0;\nvar Constants_1 = __webpack_require__(1);\nvar Logger_1 = __webpack_require__(0);\n/**\n * Registry of message handlers.\n * Safely executes individual handlers and aggregates results\n */\nvar MessageHandlerRegistry = /** @class */ (function () {\n    function MessageHandlerRegistry(logProvider) {\n        this.messageHandlers = [];\n        this.logger = new Logger_1.Logger(\"MessageHandlers\", logProvider);\n    }\n    MessageHandlerRegistry.prototype.register = function (handler) {\n        if (this.messageHandlers.some(function (item) { return item === handler; })) {\n            throw new Error('Registering the same handler twice is not allowed');\n        }\n        this.messageHandlers.push(handler);\n    };\n    MessageHandlerRegistry.prototype.clear = function () {\n        this.logger.debug('Clearing message handlers');\n        this.messageHandlers = [];\n    };\n    MessageHandlerRegistry.prototype.active = function () {\n        return (this.messageHandlers.length > 0);\n    };\n    MessageHandlerRegistry.prototype.handleMessage = function (message) {\n        var unhandledMessageResult = {\n            resultCode: Constants_1.UNHANDLED_MESSAGE_ACK,\n            isHandled: false\n        };\n        for (var _i = 0, _a = this.messageHandlers; _i < _a.length; _i++) {\n            var messageHandler = _a[_i];\n            var result = this.safeExecuteHandle(messageHandler, message);\n            if (result !== undefined && (result.isHandled === undefined || result.isHandled)) {\n                if (result.resultCode === undefined) {\n                    result.resultCode = Constants_1.HANDLED_MESSAGE_ACK;\n                }\n                return result;\n            }\n        }\n        return unhandledMessageResult;\n    };\n    MessageHandlerRegistry.prototype.safeExecuteHandle = function (handler, message) {\n        try {\n            return handler.handleMessage(message);\n        }\n        catch (exception) {\n            this.logger.warn(\"Trouter message handler threw an exception: \".concat(exception));\n            return undefined;\n        }\n    };\n    return MessageHandlerRegistry;\n}());\nexports.MessageHandlerRegistry = MessageHandlerRegistry;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addCacheAsBackupTo = void 0;\nfunction addCacheAsBackupTo(provider) {\n    var _this = this;\n    var cachedToken;\n    return function (forceRefresh) { return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (forceRefresh) {\n                cachedToken = undefined;\n            }\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n                    provider(forceRefresh).then(function (token) {\n                        cachedToken = token;\n                        resolve(token);\n                    }).catch(function (error) {\n                        if (cachedToken !== undefined && cachedToken.length > 0) {\n                            resolve(cachedToken);\n                        }\n                        reject(error);\n                    });\n                })];\n        });\n    }); };\n}\nexports.addCacheAsBackupTo = addCacheAsBackupTo;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrouterManager = exports.AudienceSubscriptionState = exports.UserActivityObject = void 0;\nvar Common_1 = __webpack_require__(3);\nvar Interfaces_1 = __webpack_require__(2);\nvar InternalInterfaces_1 = __webpack_require__(4);\nvar Logger_1 = __webpack_require__(0);\nvar ProtocolAdapters_1 = __webpack_require__(5);\nvar RegistrationEnforcer_1 = __webpack_require__(18);\nvar TrouterConnection_1 = __webpack_require__(7);\nvar TrouterFsm_1 = __webpack_require__(6);\nvar TrouterManagerFsm_1 = __webpack_require__(19);\n/**\n * UserActivity object\n */\nvar UserActivityObject = /** @class */ (function () {\n    function UserActivityObject(state, correlationVector) {\n        this.state = state;\n        this.correlationVector = correlationVector !== undefined ? correlationVector : Common_1.CorrelationVector.extend();\n    }\n    UserActivityObject.prototype.getStateString = function () {\n        switch (this.state) {\n            case Interfaces_1.UserActivityState.Active:\n                return 'active';\n            case Interfaces_1.UserActivityState.Inactive:\n                return 'inactive';\n            case Interfaces_1.UserActivityState.Unknown:\n                return 'unknown';\n            default:\n                return 'undefined';\n        }\n    };\n    UserActivityObject.prototype.increaseCvAndGetEventObject = function () {\n        this.correlationVector.increase();\n        return this.toEventObject();\n    };\n    UserActivityObject.prototype.toEventObject = function () {\n        return { state: this.getStateString(), cv: this.correlationVector.value() };\n    };\n    UserActivityObject.prototype.toEventJSON = function () {\n        return (0, Common_1.toJson)(this.toEventObject());\n    };\n    return UserActivityObject;\n}());\nexports.UserActivityObject = UserActivityObject;\nvar AudienceSubscriptionState = /** @class */ (function () {\n    function AudienceSubscriptionState(audienceSubscriptionModel, correlationVector) {\n        if (correlationVector === void 0) { correlationVector = Common_1.CorrelationVector.extend(); }\n        this.audienceSubscriptionModel = audienceSubscriptionModel;\n        this.correlationVector = correlationVector;\n    }\n    AudienceSubscriptionState.prototype.increaseCvAndGetEventObject = function () {\n        this.correlationVector.increase();\n        return this.toEventObject();\n    };\n    AudienceSubscriptionState.prototype.toEventObject = function () {\n        return { audiences: this.audienceSubscriptionModel.audienceSubscriptions, cv: this.correlationVector.value() };\n    };\n    AudienceSubscriptionState.prototype.toEventJSON = function () {\n        return (0, Common_1.toJson)(this.toEventObject());\n    };\n    return AudienceSubscriptionState;\n}());\nexports.AudienceSubscriptionState = AudienceSubscriptionState;\n/**\n * Trouter implementation\n */\nvar TrouterManager = /** @class */ (function () {\n    function TrouterManager(logFunc, options, tokenProvider, usingLegacyTokenApi, listener, protocolSelector) {\n        var _this = this;\n        this.logFunc = logFunc;\n        this.options = options;\n        this.tokenProvider = tokenProvider;\n        this.usingLegacyTokenApi = usingLegacyTokenApi;\n        this.listener = listener;\n        this.tokenTypeProtocolSelector = function (tokenType, reconnectParams) {\n            return _this.options.forceV4aProtocol ? 'v4a' : (0, ProtocolAdapters_1.usedProtocol)(tokenType, reconnectParams);\n        };\n        this.logger = new Logger_1.Logger('Manager', logFunc);\n        this.logger.info(\"Created TrouterManager with options \".concat((0, Common_1.toJson)(this.options)));\n        this.fsm = new TrouterManagerFsm_1.TrouterManagerFsm(logFunc, this);\n        this.baseEndpointUrl = '';\n        this.processedMessageLoss = {};\n        this.userActivityObject = new UserActivityObject(Interfaces_1.UserActivityState.Unknown);\n        this.protocolSelector = protocolSelector !== null && protocolSelector !== void 0 ? protocolSelector : this.tokenTypeProtocolSelector.bind(this);\n    }\n    TrouterManager.prototype.start = function () {\n        this.fsm.start();\n    };\n    TrouterManager.prototype.stop = function (dontUnregister) {\n        this.fsm.stop(dontUnregister);\n    };\n    TrouterManager.prototype.configure = function (options) {\n        this.options = options;\n        if (this.firstConnection !== undefined) {\n            this.firstConnection.configure(options);\n        }\n        if (this.secondConnection !== undefined) {\n            this.secondConnection.configure(options);\n        }\n        this.logger.info(\"Reconfigured TrouterManager with options \".concat((0, Common_1.toJson)(this.options)));\n    };\n    TrouterManager.prototype.checkConnection = function (disconnectDetected) {\n        if (this.firstConnection !== undefined) {\n            this.firstConnection.checkConnection(disconnectDetected);\n        }\n        if (this.secondConnection !== undefined) {\n            this.secondConnection.checkConnection(disconnectDetected);\n        }\n    };\n    TrouterManager.prototype.resendRegistration = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.secondConnection !== undefined) {\n                    this.logger.info('Resending registration on the second/new connection');\n                    return [2 /*return*/, this.secondConnection.resendRegistration()];\n                }\n                if (this.firstConnection !== undefined) {\n                    this.logger.info('Resending registration on the first/current connection');\n                    return [2 /*return*/, this.firstConnection.resendRegistration()];\n                }\n                this.logger.info('No connection to resend registration on, will be done upon (re)connect');\n                return [2 /*return*/];\n            });\n        });\n    };\n    TrouterManager.prototype.getServerState = function () {\n        if (this.firstConnection !== undefined) {\n            return this.firstConnection.getServerState();\n        }\n        return undefined;\n    };\n    /** Returns current state */\n    TrouterManager.prototype.getState = function () {\n        return this.fsm.getState();\n    };\n    TrouterManager.prototype.isInTerminalState = function () {\n        return this.fsm.getInternalState() === InternalInterfaces_1.TrouterManagerState.TerminalError;\n    };\n    TrouterManager.prototype.reportStateInfo = function () {\n        var firstState = this.firstConnection ? TrouterFsm_1.State[this.firstConnection.getState()] : \"Unknown\";\n        var managerState = InternalInterfaces_1.TrouterManagerState[this.fsm.getInternalState()];\n        if (this.secondConnection) {\n            var secondState = TrouterFsm_1.State[this.secondConnection.getState()];\n            return \"Manager \".concat(managerState, \"; 1st \").concat(firstState, \"; 2nd \").concat(secondState);\n        }\n        return \"Manager \".concat(managerState, \"; Connection \").concat(firstState);\n    };\n    //////////// IManagerWorker ////////////\n    TrouterManager.prototype.startFirstConnection = function () {\n        var connection = new TrouterConnection_1.TrouterConnection(this.logFunc, this.options, this.configuredTrouterManager(), this.tokenProvider, this.usingLegacyTokenApi, this.userActivityObject, this.protocolSelector, this.audienceSubscriptionState);\n        this.firstConnection = connection;\n        this.getConnectionCache()\n            .then(function (connectionCache) {\n            connection.start(connectionCache);\n        })\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\n            .catch(function () { });\n    };\n    TrouterManager.prototype.startSecondConnection = function (useConnectParamsFromCache) {\n        var connection = new TrouterConnection_1.TrouterConnection(this.logFunc, this.options, this.configuredTrouterManager(), this.tokenProvider, this.usingLegacyTokenApi, this.userActivityObject, this.protocolSelector, this.audienceSubscriptionState);\n        this.secondConnection = connection;\n        if (this.firstConnection !== undefined) {\n            this.firstConnection.disableRegistrationsAndAutoReconnect();\n        }\n        if (useConnectParamsFromCache) {\n            this.getConnectionCache()\n                .then(function (connectionCache) {\n                connection.start(connectionCache);\n            })\n                // eslint-disable-next-line @typescript-eslint/no-empty-function\n                .catch(function () { });\n        }\n        else {\n            connection.start();\n        }\n    };\n    TrouterManager.prototype.stopFirstConnection = function (dontUnregister) {\n        if (this.firstConnection !== undefined) {\n            // Store first connection to be able to compare in onDisconnected() handler\n            this.storedFirstConnection = this.firstConnection;\n            this.firstConnection.stop(dontUnregister);\n            this.firstConnection = undefined;\n        }\n    };\n    TrouterManager.prototype.stopSecondConnection = function (dontUnregister) {\n        if (this.secondConnection !== undefined) {\n            this.secondConnection.stop(dontUnregister);\n            this.secondConnection = undefined;\n        }\n    };\n    TrouterManager.prototype.stopSecondConnectionDelayed = function () {\n        if (this.secondConnection !== undefined) {\n            var connection_1 = this.secondConnection;\n            this.secondConnection = undefined;\n            this.logger.info(\"Closing an inactive connection in \".concat(Math.round(this.options.lingeringConnectionDelayMs / 1000), \"s\"));\n            setTimeout(function () {\n                connection_1.stop(true);\n            }, this.options.lingeringConnectionDelayMs);\n        }\n    };\n    TrouterManager.prototype.forceStopLingeringConnection = function () {\n        if (this.storedFirstConnection) {\n            this.storedFirstConnection.stop(false);\n            this.storedFirstConnection = undefined;\n        }\n    };\n    TrouterManager.prototype.switchConnections = function () {\n        var tmp = this.firstConnection;\n        this.firstConnection = this.secondConnection;\n        this.secondConnection = tmp;\n    };\n    TrouterManager.prototype.doesSecondConnectionExist = function () {\n        return this.secondConnection !== undefined;\n    };\n    TrouterManager.prototype.dispatchConnected = function () {\n        if (this.firstConnection !== undefined) {\n            var ss = this.firstConnection.getServerState();\n            var baseEndpointUrl = (ss.url.endsWith('/')) ? ss.url.slice(0, -1) : ss.url;\n            var connectionInfo = {\n                baseEndpointUrl: baseEndpointUrl,\n                newEndpointUrl: (baseEndpointUrl !== this.baseEndpointUrl),\n                c2cUrlBase: ss.c2cUrlBase,\n                clientId: ss.connectedClientId,\n                connectionId: ss.connectionId,\n                connectionTtlSec: ss.getRemainingTtlInSec()\n            };\n            this.baseEndpointUrl = baseEndpointUrl;\n            this.listener.onTrouterConnected(ss.url, connectionInfo);\n        }\n    };\n    TrouterManager.prototype.dispatchDisconnected = function () {\n        if (this.listener.onTrouterDisconnected) {\n            this.listener.onTrouterDisconnected();\n        }\n    };\n    TrouterManager.prototype.dispatchTerminalError = function () {\n        // Emit a disconnected event to listeners too.\n        if (this.listener.onTrouterDisconnected) {\n            this.listener.onTrouterDisconnected();\n        }\n    };\n    TrouterManager.prototype.dispatchRegistrationState = function (isRegistered) {\n        if (this.options.registrationStateCallback) {\n            this.options.registrationStateCallback(isRegistered);\n        }\n    };\n    TrouterManager.prototype.expediteBackoffOnConnections = function () {\n        var _a;\n        if (this.lastExpediteBackoffCallAt !== undefined && Date.now() - this.lastExpediteBackoffCallAt < ((_a = this.options.expediteBackoffOnStartMinimumDelayMs) !== null && _a !== void 0 ? _a : 10000)) {\n            this.logger.info('Expedite backoff due to start() too frequent, skipping');\n            return;\n        }\n        this.lastExpediteBackoffCallAt = Date.now();\n        if (this.firstConnection !== undefined) {\n            this.firstConnection.expediteBackoff();\n        }\n        if (this.secondConnection !== undefined) {\n            this.secondConnection.expediteBackoff();\n        }\n    };\n    //////////// IManagerConsumer ////////////\n    TrouterManager.prototype.onDownstreamRequest = function (connection, request, response) {\n        var req = {\n            id: request.id,\n            method: request.method,\n            path: \"/\".concat(request.shortUrl),\n            body: request.body,\n            headers: request.headers\n        };\n        var rsp = {\n            id: request.id,\n            status: 0,\n            headers: {},\n            body: '',\n            send: function () {\n                if (rsp.status <= 100 || rsp.status >= 999) {\n                    return 3 /* SendResponseResult.Incomplete */;\n                }\n                response.writeHead(rsp.status, rsp.headers);\n                return response.end(rsp.body);\n            }\n        };\n        this.listener.onTrouterRequest(req, rsp);\n    };\n    TrouterManager.prototype.onConnected = function (connection) {\n        this.fsm.onConnected(connection === this.firstConnection);\n    };\n    TrouterManager.prototype.onRegistered = function (connection) {\n        this.fsm.onRegistered(connection === this.firstConnection);\n    };\n    TrouterManager.prototype.onUnregistered = function (connection) {\n        this.fsm.onUnregistered(connection === this.firstConnection || connection === this.storedFirstConnection);\n    };\n    TrouterManager.prototype.onReconnecting = function (connection) {\n        this.fsm.onReconnecting(connection === this.firstConnection);\n    };\n    TrouterManager.prototype.onReconnectIsRequired = function (connection, useConnectParamsFromCache, reason) {\n        this.fsm.onReconnectionRequired(connection === this.firstConnection, useConnectParamsFromCache, reason);\n    };\n    TrouterManager.prototype.onDisconnected = function (connection) {\n        this.fsm.onDisconnected(connection === this.firstConnection || connection == this.storedFirstConnection);\n        this.storedFirstConnection = undefined;\n    };\n    TrouterManager.prototype.onTerminalError = function () {\n        // TODO: the argument passed to onTerminalError is just ignored\n        // this.fsm.onTerminalError(connection === this.firstConnection || connection == this.storedFirstConnection);\n        this.fsm.onTerminalError();\n        this.storedFirstConnection = undefined;\n    };\n    TrouterManager.prototype.onUserActivityStateAccepted = function (cv) {\n        if (this.listener.onTrouterUserActivityStateAccepted) {\n            this.listener.onTrouterUserActivityStateAccepted(cv);\n        }\n    };\n    TrouterManager.prototype.onAudiencesSetResolved = function (audienceSubscriptionsResponse, cv) {\n        var _a, _b;\n        (_b = (_a = this.listener).onAudiencesSetResolved) === null || _b === void 0 ? void 0 : _b.call(_a, audienceSubscriptionsResponse, cv);\n    };\n    TrouterManager.prototype.onConnectionParametersUpdated = function (connectionParameters) {\n        this.setConnectionCache(connectionParameters);\n    };\n    TrouterManager.prototype.setUserActivityState = function (state, correlationVector) {\n        this.userActivityObject = new UserActivityObject(state, Common_1.CorrelationVector.extend(correlationVector));\n        if (this.secondConnection !== undefined) {\n            this.logger.info(\"Setting user activity \".concat(this.userActivityObject.toEventJSON(), \" on the second/new connection\"));\n            this.secondConnection.setUserActivityState(this.userActivityObject);\n            return;\n        }\n        if (this.firstConnection !== undefined) {\n            this.logger.info(\"Setting user activity \".concat(this.userActivityObject.toEventJSON(), \" on the first/current connection\"));\n            this.firstConnection.setUserActivityState(this.userActivityObject);\n            return;\n        }\n    };\n    TrouterManager.prototype.setAudienceSubscriptionsAsync = function (audienceSubscriptionModel, timeoutInMs, correlationVector) {\n        this.audienceSubscriptionState = new AudienceSubscriptionState(audienceSubscriptionModel, Common_1.CorrelationVector.extend(correlationVector));\n        if (this.secondConnection) {\n            this.logger.info(\"Setting audience subscriptions \".concat(this.audienceSubscriptionState.toEventJSON(), \" on second/new connection\"));\n            return this.secondConnection.setAudienceSubscriptionsAsync(this.audienceSubscriptionState, timeoutInMs);\n        }\n        if (this.firstConnection) {\n            this.logger.info(\"Setting audience subscriptions \".concat(this.audienceSubscriptionState.toEventJSON(), \" on first/current connection\"));\n            return this.firstConnection.setAudienceSubscriptionsAsync(this.audienceSubscriptionState, timeoutInMs);\n        }\n        throw new Error('No connection found');\n    };\n    TrouterManager.prototype.onTrouterMessageLost = function (indicators) {\n        var _this = this;\n        if (this.listener.onTrouterMessageLoss) {\n            if (indicators === null || indicators === void 0 ? void 0 : indicators.length) {\n                // Filter out already seen dropped indicators and inform server that they are processed\n                var duplicates = indicators.filter(function (di) { return _this.processedMessageLoss[\"\".concat(di.tag, \"-\").concat(di.etag)] !== undefined; });\n                if (duplicates.length) {\n                    this.logger.info(\"onTrouterMessageLoss - immediately acknowledging \".concat(duplicates.length, \" seen dropped indicators\"));\n                    this.sendProcessedDroppedIndicators(duplicates);\n                    indicators = indicators.filter(function (di) { return _this.processedMessageLoss[\"\".concat(di.tag, \"-\").concat(di.etag)] === undefined; });\n                    if (!indicators.length) {\n                        this.logger.info('onTrouterMessageLoss - all declared dropped indicators have been seen before');\n                        return;\n                    }\n                }\n                // Send the data to the listeners\n                var messageLossProcessed = this.listener.onTrouterMessageLoss(indicators.map(function (di) { return di.tag; }));\n                if (!messageLossProcessed) {\n                    this.logger.warn('onTrouterMessageLoss - some flow tag(s) have not been processed by listeners');\n                    return;\n                }\n                // Update the cache\n                indicators.forEach(function (di) {\n                    _this.processedMessageLoss[\"\".concat(di.tag, \"-\").concat(di.etag)] = '';\n                });\n                this.sendProcessedDroppedIndicators(indicators);\n            }\n            else {\n                this.logger.warn('onTrouterMessageLoss - no flow tags have been provided');\n            }\n        }\n    };\n    TrouterManager.prototype.getConnectionCache = function () {\n        var _this = this;\n        if (!this.options.connectionCache) {\n            return Promise.resolve(this.connectionCache);\n        }\n        this.logger.debug('Querying host\\'s connection cache');\n        return this.options.connectionCache.onGetTrouterConnectionCache()\n            .then(function (serialized) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            var parsed = serialized ? JSON.parse(serialized) : undefined;\n            return typeof parsed === 'object' ? parsed : undefined;\n        })\n            .catch(function (e) {\n            _this.logger.warn(\"Invalid connection cache content provided: \".concat(e));\n            return _this.connectionCache;\n        });\n    };\n    TrouterManager.prototype.setConnectionCache = function (content) {\n        this.connectionCache = content;\n        if (this.options.connectionCache) {\n            try {\n                this.options.connectionCache.onSetTrouterConnectionCache(JSON.stringify(content));\n            }\n            catch (e) {\n                this.logger.warn(\"Error setting external connection cache: \".concat(e));\n            }\n        }\n    };\n    TrouterManager.prototype.sendProcessedDroppedIndicators = function (messageLossIndicators) {\n        if (this.firstConnection !== undefined) {\n            this.firstConnection.sendProcessedDroppedIndicators(messageLossIndicators);\n            return;\n        }\n        if (this.secondConnection !== undefined) {\n            this.secondConnection.sendProcessedDroppedIndicators(messageLossIndicators);\n            return;\n        }\n    };\n    TrouterManager.prototype.configuredTrouterManager = function () {\n        return new RegistrationEnforcer_1.RegistrationEnforcer(this, this.options.connectionDependsOnRegistration, this.options.delayEventsUntilRegistered);\n    };\n    return TrouterManager;\n}());\nexports.TrouterManager = TrouterManager;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrouterUrlPromise = void 0;\nvar Logger_1 = __webpack_require__(0);\n/**\n * Util that encapsulates lifecycle of active trouter URL and manages waiter for the URL via promise\n */\nvar TrouterUrlPromise = /** @class */ (function () {\n    function TrouterUrlPromise(logProvider) {\n        this.logger = new Logger_1.Logger('UrlPromise', logProvider);\n    }\n    TrouterUrlPromise.prototype.getPromise = function () {\n        var _this = this;\n        if (this.url !== undefined) {\n            this.logger.debug(\"returning previously resolved url: \".concat(this.url));\n            return Promise.resolve(this.url);\n        }\n        if (this.pendingPromise === undefined) {\n            this.logger.debug('creating and returning promise');\n            this.pendingPromise = new Promise(function (resolve, reject) {\n                _this.pendingPromiseResolveRef = resolve;\n                _this.pendingPromiseRejectRef = reject;\n            });\n        }\n        else {\n            this.logger.debug('returning existing promise');\n        }\n        return this.pendingPromise;\n    };\n    TrouterUrlPromise.prototype.resolveUrl = function (url) {\n        this.url = url;\n        this.logger.debug(\"got url: \".concat(this.url));\n        var resolveCallback = this.pendingPromiseResolveRef;\n        this.pendingPromise = undefined;\n        this.pendingPromiseResolveRef = undefined;\n        this.pendingPromiseRejectRef = undefined;\n        if (resolveCallback !== undefined) {\n            this.logger.debug('resolving promise');\n            resolveCallback(url);\n        }\n    };\n    TrouterUrlPromise.prototype.rejectUrl = function (error) {\n        this.logger.debug('aborting');\n        var rejectCallback = this.pendingPromiseRejectRef;\n        this.url = undefined;\n        this.pendingPromise = undefined;\n        this.pendingPromiseResolveRef = undefined;\n        this.pendingPromiseRejectRef = undefined;\n        if (rejectCallback !== undefined) {\n            this.logger.debug('rejecting promise');\n            rejectCallback(error);\n        }\n    };\n    TrouterUrlPromise.prototype.resetUrl = function () {\n        this.logger.debug('resetting url');\n        this.url = undefined;\n    };\n    return TrouterUrlPromise;\n}());\nexports.TrouterUrlPromise = TrouterUrlPromise;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, module) {/** Socket.IO.js build:0.9.6, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, global) {\r\n\r\n  /**\r\n   * IO namespace.\r\n   *\r\n   * @namespace\r\n   */\r\n\r\n  var io = exports;\r\n\r\n  /**\r\n   * Socket.IO version\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  io.version = '0.9.6';\r\n\r\n  /**\r\n   * Protocol implemented.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  io.protocol = 1;\r\n\r\n  /**\r\n   * Available transports, these will be populated with the available transports\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  io.transports = [];\r\n\r\n  /**\r\n   * Keep track of jsonp callbacks.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  io.j = [];\r\n\r\n  /**\r\n   * Keep track of our io.Sockets\r\n   *\r\n   * @api private\r\n   */\r\n  io.sockets = {};\r\n\r\n\r\n  /**\r\n   * Manages connections to hosts.\r\n   *\r\n   * @param {String} uri\r\n   * @Param {Boolean} force creation of new socket (defaults to false)\r\n   * @api public\r\n   */\r\n\r\n  io.connect = function (host, details) {\r\n    var uri = io.util.parseUri(host)\r\n      , uuri\r\n      , socket;\r\n\r\n    if (global && global.location) {\r\n      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);\r\n      uri.host = uri.host || (global.document\r\n        ? global.document.domain : global.location.hostname);\r\n      uri.port = uri.port || global.location.port;\r\n    }\r\n\r\n    uuri = io.util.uniqueUri(uri);\r\n\r\n    var options = {\r\n        host: uri.host\r\n      , secure: 'https' == uri.protocol\r\n      , port: uri.port || ('https' == uri.protocol ? 443 : 80)\r\n      , query: uri.query || ''\r\n    };\r\n\r\n    io.util.merge(options, details);\r\n\r\n    if (options['force new connection'] || !io.sockets[uuri]) {\r\n      socket = new io.Socket(options);\r\n    }\r\n\r\n    if (!options['force new connection'] && socket) {\r\n      io.sockets[uuri] = socket;\r\n    }\r\n\r\n    socket = socket || io.sockets[uuri];\r\n\r\n    // Making /v4/c have empty namespace\r\n    if (options['skipped handshake data']) {\r\n      return socket.of('');\r\n    } else {\r\n      // if path is different from '' or /\r\n      return socket.of(uri.path.length > 1 ? uri.path : '');\r\n    }\r\n  };\r\n\r\n})(\r\n     true ? module.exports : (this.io = {})\r\n  , 'undefined' === typeof global ? window : global);\r\n\r\n// Workaround inside webpack\r\nvar io = module.exports;\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, global) {\r\n\r\n  /**\r\n   * Utilities namespace.\r\n   *\r\n   * @namespace\r\n   */\r\n\r\n  var util = exports.util = {};\r\n\r\n  /**\r\n   * Parses an URI\r\n   *\r\n   * @author Steven Levithan <stevenlevithan.com> (MIT license)\r\n   * @api public\r\n   */\r\n\r\n  var re = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\r\n\r\n  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',\r\n               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',\r\n               'anchor'];\r\n\r\n  util.parseUri = function (str) {\r\n    var m = re.exec(str || '')\r\n      , uri = {}\r\n      , i = 14;\r\n\r\n    while (i--) {\r\n      uri[parts[i]] = m[i] || '';\r\n    }\r\n\r\n    return uri;\r\n  };\r\n\r\n  /**\r\n   * Produces a unique url that identifies a Socket.IO connection.\r\n   *\r\n   * @param {Object} uri\r\n   * @api public\r\n   */\r\n\r\n  util.uniqueUri = function (uri) {\r\n    var protocol = uri.protocol\r\n      , host = uri.host\r\n      , port = uri.port;\r\n\r\n    if ('document' in global) {\r\n      host = host || document.domain;\r\n      port = port || (protocol == 'https'\r\n        && document.location.protocol !== 'https:' ? 443 : document.location.port);\r\n    } else {\r\n      host = host || 'localhost';\r\n\r\n      if (!port && protocol == 'https') {\r\n        port = 443;\r\n      }\r\n    }\r\n\r\n    return (protocol || 'http') + '://' + host + ':' + (port || 80);\r\n  };\r\n\r\n  /**\r\n   * Mergest 2 query strings in to once unique query string\r\n   *\r\n   * @param {String} base\r\n   * @param {String} addition\r\n   * @api public\r\n   */\r\n\r\n  util.query = function (base, addition) {\r\n    var query = util.chunkQuery(base || '')\r\n      , components = [];\r\n\r\n    util.merge(query, util.chunkQuery(addition || ''));\r\n    for (var part in query) {\r\n      if (query.hasOwnProperty(part)) {\r\n        components.push(part + '=' + query[part]);\r\n      }\r\n    }\r\n\r\n    return components.length ? '?' + components.join('&') : '';\r\n  };\r\n\r\n  /**\r\n   * Transforms a querystring in to an object\r\n   *\r\n   * @param {String} qs\r\n   * @api public\r\n   */\r\n\r\n  util.chunkQuery = function (qs) {\r\n    var query = {}\r\n      , params = qs.split('&')\r\n      , i = 0\r\n      , l = params.length\r\n      , kv;\r\n\r\n    for (; i < l; ++i) {\r\n      kv = params[i].split('=');\r\n      if (kv[0]) {\r\n        query[kv[0]] = kv[1];\r\n      }\r\n    }\r\n\r\n    return query;\r\n  };\r\n\r\n  /**\r\n   * Executes the given function when the page is loaded.\r\n   *\r\n   *     io.util.load(function () { console.log('page loaded'); });\r\n   *\r\n   * @param {Function} fn\r\n   * @api public\r\n   */\r\n\r\n  var pageLoaded = false;\r\n\r\n  util.load = function (fn) {\r\n    if ('document' in global && document.readyState === 'complete' || pageLoaded) {\r\n      return fn();\r\n    }\r\n\r\n    util.on(global, 'load', fn, false);\r\n  };\r\n\r\n  /**\r\n   * Adds an event.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  util.on = function (element, event, fn, capture) {\r\n    if (element.attachEvent) {\r\n      element.attachEvent('on' + event, fn);\r\n    } else if (element.addEventListener) {\r\n      element.addEventListener(event, fn, capture);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.\r\n   *\r\n   * @param {Boolean} [xdomain] Create a request that can be used cross domain.\r\n   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.\r\n   * @api private\r\n   */\r\n\r\n  util.request = function (xdomain) {\r\n\r\n    if (xdomain && 'undefined' != typeof XDomainRequest) {\r\n      return new XDomainRequest();\r\n    }\r\n\r\n    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {\r\n      return new XMLHttpRequest();\r\n    }\r\n\r\n    if (!xdomain) {\r\n      try {\r\n        return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');\r\n      } catch(e) { }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * XHR based transport constructor.\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   */\r\n\r\n  /**\r\n   * Change the internal pageLoaded value.\r\n   */\r\n\r\n  if ('undefined' != typeof window) {\r\n    util.load(function () {\r\n      pageLoaded = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Defers a function to ensure a spinner is not displayed by the browser\r\n   *\r\n   * @param {Function} fn\r\n   * @api public\r\n   */\r\n\r\n  util.defer = function (fn) {\r\n    if (!util.ua.webkit || 'undefined' != typeof importScripts) {\r\n      return fn();\r\n    }\r\n\r\n    util.load(function () {\r\n      setTimeout(fn, 100);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Merges two objects.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.merge = function merge (target, additional, deep, lastseen) {\r\n    var seen = lastseen || []\r\n      , depth = typeof deep == 'undefined' ? 2 : deep\r\n      , prop;\r\n\r\n    for (prop in additional) {\r\n      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {\r\n        if (typeof target[prop] !== 'object' || !depth) {\r\n          target[prop] = additional[prop];\r\n          seen.push(additional[prop]);\r\n        } else {\r\n          util.merge(target[prop], additional[prop], depth - 1, seen);\r\n        }\r\n      }\r\n    }\r\n\r\n    return target;\r\n  };\r\n\r\n  /**\r\n   * Merges prototypes from objects\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.mixin = function (ctor, ctor2) {\r\n    util.merge(ctor.prototype, ctor2.prototype);\r\n  };\r\n\r\n  /**\r\n   * Shortcut for prototypical and static inheritance.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  util.inherit = function (ctor, ctor2) {\r\n    function f() {};\r\n    f.prototype = ctor2.prototype;\r\n    ctor.prototype = new f;\r\n  };\r\n\r\n  /**\r\n   * Checks if the given object is an Array.\r\n   *\r\n   *     io.util.isArray([]); // true\r\n   *     io.util.isArray({}); // false\r\n   *\r\n   * @param Object obj\r\n   * @api public\r\n   */\r\n\r\n  util.isArray = Array.isArray || function (obj) {\r\n    return Object.prototype.toString.call(obj) === '[object Array]';\r\n  };\r\n\r\n  /**\r\n   * Intersects values of two arrays into a third\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.intersect = function (arr, arr2) {\r\n    var ret = []\r\n      , longest = arr.length > arr2.length ? arr : arr2\r\n      , shortest = arr.length > arr2.length ? arr2 : arr;\r\n\r\n    for (var i = 0, l = shortest.length; i < l; i++) {\r\n      if (~util.indexOf(longest, shortest[i]))\r\n        ret.push(shortest[i]);\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   * Array indexOf compatibility.\r\n   *\r\n   * @see bit.ly/a5Dxa2\r\n   * @api public\r\n   */\r\n\r\n  util.indexOf = function (arr, o, i) {\r\n\r\n    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0;\r\n         i < j && arr[i] !== o; i++) {}\r\n\r\n    return j <= i ? -1 : i;\r\n  };\r\n\r\n  /**\r\n   * Converts enumerables to array.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.toArray = function (enu) {\r\n    var arr = [];\r\n\r\n    for (var i = 0, l = enu.length; i < l; i++)\r\n      arr.push(enu[i]);\r\n\r\n    return arr;\r\n  };\r\n\r\n  /**\r\n   * UA / engines detection namespace.\r\n   *\r\n   * @namespace\r\n   */\r\n\r\n  util.ua = {};\r\n\r\n  /**\r\n   * Whether the UA supports CORS for XHR.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {\r\n    try {\r\n      var a = new XMLHttpRequest();\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n\r\n    return a.withCredentials != undefined;\r\n  })();\r\n\r\n  /**\r\n   * Detect webkit.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.ua.webkit = 'undefined' != typeof navigator\r\n    && /webkit/i.test(navigator.userAgent);\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' === typeof global ? window : global);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.EventEmitter = EventEmitter;\r\n\r\n  /**\r\n   * Event emitter constructor.\r\n   *\r\n   * @api public.\r\n   */\r\n\r\n  function EventEmitter () {};\r\n\r\n  /**\r\n   * Adds a listener\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.on = function (name, fn) {\r\n    if (!this.$events) {\r\n      this.$events = {};\r\n    }\r\n\r\n    if (!this.$events[name]) {\r\n      this.$events[name] = fn;\r\n    } else if (io.util.isArray(this.$events[name])) {\r\n      this.$events[name].push(fn);\r\n    } else {\r\n      this.$events[name] = [this.$events[name], fn];\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n  /**\r\n   * Adds a volatile listener.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.once = function (name, fn) {\r\n    var self = this;\r\n\r\n    function on () {\r\n      self.removeListener(name, on);\r\n      fn.apply(this, arguments);\r\n    };\r\n\r\n    on.listener = fn;\r\n    this.on(name, on);\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Removes a listener.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.removeListener = function (name, fn) {\r\n    if (this.$events && this.$events[name]) {\r\n      var list = this.$events[name];\r\n\r\n      if (io.util.isArray(list)) {\r\n        var pos = -1;\r\n\r\n        for (var i = 0, l = list.length; i < l; i++) {\r\n          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\r\n            pos = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (pos < 0) {\r\n          return this;\r\n        }\r\n\r\n        list.splice(pos, 1);\r\n\r\n        if (!list.length) {\r\n          delete this.$events[name];\r\n        }\r\n      } else if (list === fn || (list.listener && list.listener === fn)) {\r\n        delete this.$events[name];\r\n      }\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Removes all listeners for an event.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.removeAllListeners = function (name) {\r\n    // TODO: enable this when node 0.5 is stable\r\n    //if (name === undefined) {\r\n      //this.$events = {};\r\n      //return this;\r\n    //}\r\n\r\n    if (this.$events && this.$events[name]) {\r\n      this.$events[name] = null;\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Gets all listeners for a certain event.\r\n   *\r\n   * @api publci\r\n   */\r\n\r\n  EventEmitter.prototype.listeners = function (name) {\r\n    if (!this.$events) {\r\n      this.$events = {};\r\n    }\r\n\r\n    if (!this.$events[name]) {\r\n      this.$events[name] = [];\r\n    }\r\n\r\n    if (!io.util.isArray(this.$events[name])) {\r\n      this.$events[name] = [this.$events[name]];\r\n    }\r\n\r\n    return this.$events[name];\r\n  };\r\n\r\n  /**\r\n   * Emits an event.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.emit = function (name) {\r\n    if (!this.$events) {\r\n      return false;\r\n    }\r\n\r\n    var handler = this.$events[name];\r\n\r\n    if (!handler) {\r\n      return false;\r\n    }\r\n\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n\r\n    if ('function' == typeof handler) {\r\n      handler.apply(this, args);\r\n    } else if (io.util.isArray(handler)) {\r\n      var listeners = handler.slice();\r\n\r\n      for (var i = 0, l = listeners.length; i < l; i++) {\r\n        listeners[i].apply(this, args);\r\n      }\r\n    } else {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * Removed JSON polyfill - obsolete, and we are using native JSON.parse etc. throughout the rest of the codebase anyway\r\n */\r\n\r\n(function (exports, nativeJSON) {\r\n  \"use strict\";\r\n\r\n  // use native JSON if it's available\r\n  if (nativeJSON && nativeJSON.parse){\r\n    return exports.JSON = {\r\n      parse: nativeJSON.parse\r\n    , stringify: nativeJSON.stringify\r\n    }\r\n  }\r\n\r\n  throw new Error(\"JSON not available\");\r\n  \r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , typeof JSON !== 'undefined' ? JSON : undefined\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Parser namespace.\r\n   *\r\n   * @namespace\r\n   */\r\n\r\n  var parser = exports.parser = {};\r\n\r\n  /**\r\n   * Packet types.\r\n   */\r\n\r\n  var packets = parser.packets = [\r\n      'disconnect'\r\n    , 'connect'\r\n    , 'heartbeat'\r\n    , 'message'\r\n    , 'json'\r\n    , 'event'\r\n    , 'ack'\r\n    , 'error'\r\n    , 'noop'\r\n  ];\r\n\r\n  /**\r\n   * Errors reasons.\r\n   */\r\n\r\n  var reasons = parser.reasons = [\r\n      'transport not supported'\r\n    , 'client not handshaken'\r\n    , 'unauthorized'\r\n  ];\r\n\r\n  /**\r\n   * Errors advice.\r\n   */\r\n\r\n  var advice = parser.advice = [\r\n      'reconnect'\r\n  ];\r\n\r\n  /**\r\n   * Shortcuts.\r\n   */\r\n\r\n  var JSON = io.JSON\r\n    , indexOf = io.util.indexOf;\r\n\r\n  /**\r\n   * Encodes a packet.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  parser.encodePacket = function (packet) {\r\n    var type = indexOf(packets, packet.type)\r\n      , id = packet.id || ''\r\n      , endpoint = packet.endpoint || ''\r\n      , ack = packet.ack\r\n      , data = null;\r\n\r\n    switch (packet.type) {\r\n      case 'error':\r\n        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''\r\n          , adv = packet.advice ? indexOf(advice, packet.advice) : '';\r\n\r\n        if (reason !== '' || adv !== '')\r\n          data = reason + (adv !== '' ? ('+' + adv) : '');\r\n\r\n        break;\r\n\r\n      case 'message':\r\n        if (packet.data !== '')\r\n          data = packet.data;\r\n        break;\r\n\r\n      case 'event':\r\n        var ev = { name: packet.name };\r\n\r\n        if (packet.args && packet.args.length) {\r\n          ev.args = packet.args;\r\n        }\r\n\r\n        data = JSON.stringify(ev);\r\n        break;\r\n\r\n      case 'json':\r\n        data = JSON.stringify(packet.data);\r\n        break;\r\n\r\n      case 'connect':\r\n        if (packet.qs)\r\n          data = packet.qs;\r\n        break;\r\n\r\n      case 'ack':\r\n        data = packet.ackId\r\n          + (packet.args && packet.args.length\r\n              ? '+' + JSON.stringify(packet.args) : '');\r\n        break;\r\n    }\r\n\r\n    // construct packet with required fragments\r\n    var encoded = [\r\n        type\r\n      , id + (ack == 'data' ? '+' : '')\r\n      , endpoint\r\n    ];\r\n\r\n    // data fragment is optional\r\n    if (data !== null && data !== undefined)\r\n      encoded.push(data);\r\n\r\n    return encoded.join(':');\r\n  };\r\n\r\n  /**\r\n   * Encodes multiple messages (payload).\r\n   *\r\n   * @param {Array} messages\r\n   * @api private\r\n   */\r\n\r\n  parser.encodePayload = function (packets) {\r\n    var decoded = '';\r\n\r\n    if (packets.length == 1)\r\n      return packets[0];\r\n\r\n    for (var i = 0, l = packets.length; i < l; i++) {\r\n      var packet = packets[i];\r\n      decoded += '\\ufffd' + packet.length + '\\ufffd' + packets[i];\r\n    }\r\n\r\n    return decoded;\r\n  };\r\n\r\n  /**\r\n   * Decodes a packet\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  var regexp = /([^:]+):([0-9]+)?(\\+)?:([^:]+)?:?([\\s\\S]*)?/;\r\n\r\n  parser.decodePacket = function (data) {\r\n    var pieces = data.match(regexp);\r\n\r\n    if (!pieces) return {};\r\n\r\n    var id = pieces[2] || ''\r\n      , data = pieces[5] || ''\r\n      , packet = {\r\n            type: packets[pieces[1]]\r\n          , endpoint: pieces[4] || ''\r\n        };\r\n\r\n    // whether we need to acknowledge the packet\r\n    if (id) {\r\n      packet.id = id;\r\n      if (pieces[3])\r\n        packet.ack = 'data';\r\n      else\r\n        packet.ack = true;\r\n    }\r\n\r\n    // handle different packet types\r\n    switch (packet.type) {\r\n      case 'error':\r\n        var pieces = data.split('+');\r\n        packet.reason = reasons[pieces[0]] || '';\r\n        packet.advice = advice[pieces[1]] || '';\r\n        break;\r\n\r\n      case 'message':\r\n        packet.data = data || '';\r\n        break;\r\n\r\n      case 'event':\r\n        try {\r\n          var opts = JSON.parse(data);\r\n          packet.name = opts.name;\r\n          packet.args = opts.args;\r\n        } catch (e) { }\r\n\r\n        packet.args = packet.args || [];\r\n        break;\r\n\r\n      case 'json':\r\n        try {\r\n          packet.data = JSON.parse(data);\r\n        } catch (e) { }\r\n        break;\r\n\r\n      case 'connect':\r\n        packet.qs = data || '';\r\n        break;\r\n\r\n      case 'ack':\r\n        var pieces = data.match(/^([0-9]+)(\\+)?(.*)/);\r\n        if (pieces) {\r\n          packet.ackId = pieces[1];\r\n          packet.args = [];\r\n\r\n          if (pieces[3]) {\r\n            try {\r\n              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];\r\n            } catch (e) { }\r\n          }\r\n        }\r\n        break;\r\n\r\n      case 'disconnect':\r\n        packet.reason = data;\r\n        break;\r\n\r\n      case 'heartbeat':\r\n        break;\r\n    };\r\n\r\n    return packet;\r\n  };\r\n\r\n  /**\r\n   * Decodes data payload. Detects multiple messages\r\n   *\r\n   * @return {Array} messages\r\n   * @api public\r\n   */\r\n\r\n  parser.decodePayload = function (data) {\r\n    // IE doesn't like data[i] for unicode chars, charAt works fine\r\n    if (data.charAt(0) == '\\ufffd') {\r\n      var ret = [];\r\n\r\n      for (var i = 1, length = ''; i < data.length; i++) {\r\n        if (data.charAt(i) == '\\ufffd') {\r\n          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));\r\n          i += Number(length) + 1;\r\n          length = '';\r\n        } else {\r\n          length += data.charAt(i);\r\n        }\r\n      }\r\n\r\n      return ret;\r\n    } else {\r\n      return [parser.decodePacket(data)];\r\n    }\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.Transport = Transport;\r\n\r\n  /**\r\n   * This is the transport template for all supported transport methods.\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   * @param {exports.Socket} socket\r\n   */\r\n\r\n  function Transport (socket, sessid) {\r\n    this.socket = socket;\r\n    this.sessid = sessid;\r\n    this.connectErrorCallback = undefined;\r\n    this.isOpened = false;\r\n  };\r\n\r\n  /**\r\n   * Apply EventEmitter mixin.\r\n   */\r\n\r\n  io.util.mixin(Transport, io.EventEmitter);\r\n\r\n  /**\r\n   * Handles the response from the server. When a new response is received\r\n   * it will automatically update the timeout, decode the message and\r\n   * forwards the response to the onMessage function for further processing.\r\n   *\r\n   * @param {String} data Response from the server.\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onData = function (data) {\r\n    this.clearCloseTimeout();\r\n\r\n    // If the connection in currently open (or in a reopening state) reset the close\r\n    // timeout since we have just received data. This check is necessary so\r\n    // that we don't reset the timeout on an explicitly disconnected connection.\r\n    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {\r\n      this.setCloseTimeout();\r\n    }\r\n\r\n    if (data !== '') {\r\n      // todo: we should only do decodePayload for xhr transports\r\n      var msgs = io.parser.decodePayload(data);\r\n\r\n      if (msgs && msgs.length) {\r\n        for (var i = 0, l = msgs.length; i < l; i++) {\r\n          this.onPacket(msgs[i]);\r\n        }\r\n      }\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Handles packets.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onPacket = function (packet) {\r\n    this.socket.setHeartbeatTimeout();\r\n\r\n    if (packet.type == 'heartbeat') {\r\n      return this.onHeartbeat();\r\n    }\r\n\r\n    if (packet.type == 'connect' && packet.endpoint == '') {\r\n      this.onConnect();\r\n    }\r\n\r\n    if (packet.type == 'error' && packet.advice == 'reconnect') {\r\n      this.isOpened = false;\r\n    }\r\n\r\n    this.socket.onPacket(packet);\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Sets close timeout\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.setCloseTimeout = function () {\r\n    if (!this.closeTimeout) {\r\n      var self = this;\r\n\r\n      this.closeTimeout = setTimeout(function () {\r\n        self.onDisconnect();\r\n      }, this.socket.closeTimeout);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called when transport disconnects.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onDisconnect = function () {\r\n    if (this.close && this.isOpened) this.close();\r\n    this.clearTimeouts();\r\n    this.socket.onDisconnect();\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Called when transport connects\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onConnect = function () {\r\n    this.socket.onConnect();\r\n    this.connectErrorCallback = undefined;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clears close timeout\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.clearCloseTimeout = function () {\r\n    if (this.closeTimeout) {\r\n      clearTimeout(this.closeTimeout);\r\n      this.closeTimeout = null;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear timeouts\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.clearTimeouts = function () {\r\n    this.clearCloseTimeout();\r\n\r\n    if (this.reopenTimeout) {\r\n      clearTimeout(this.reopenTimeout);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Sends a packet\r\n   *\r\n   * @param {Object} packet object.\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.packet = function (packet) {\r\n    this.send(io.parser.encodePacket(packet));\r\n  };\r\n\r\n  /**\r\n   * Send the received heartbeat message back to server. So the server\r\n   * knows we are still connected.\r\n   *\r\n   * @param {String} heartbeat Heartbeat response from the server.\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onHeartbeat = function (heartbeat) {\r\n    this.packet({ type: 'heartbeat' });\r\n  };\r\n\r\n  /**\r\n   * Called when the transport opens.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onOpen = function () {\r\n    this.isOpened = true;\r\n    this.clearCloseTimeout();\r\n    this.socket.onOpen();\r\n  };\r\n\r\n  /**\r\n   * Notifies the base when the connection with the Socket.IO server\r\n   * has been disconnected.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onClose = function () {\r\n    var self = this;\r\n\r\n    /* FIXME: reopen delay causing a infinit loop\r\n    this.reopenTimeout = setTimeout(function () {\r\n      self.open();\r\n    }, this.socket.options['reopen delay']);*/\r\n\r\n    this.isOpened = false;\r\n    this.socket.onClose();\r\n    this.onDisconnect();\r\n  };\r\n\r\n  /**\r\n   * Generates a connection url based on the Socket.IO URL Protocol.\r\n   * See <https://github.com/learnboost/socket.io-node/> for more details.\r\n   *\r\n   * @returns {String} Connection url\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.prepareUrl = function (query) {\r\n    /** @var {ISocketIoOptions} options */\r\n    var options = this.socket.options;\r\n\r\n    if (options['skipped handshake data']) {\r\n      // /v4/c protocol\r\n      return options.rewriteUrlForProxy(options['skipped handshake data'].websocketUrl + (query ? query : ''))\r\n    }\r\n\r\n    var url = this.scheme() + '://'\r\n      + options.host + ':' + options.port + '/'\r\n      + options.resource + '/' + io.protocol\r\n      + '/' + this.name + '/' + this.sessid + (query ? query : '');\r\n\r\n    return options.rewriteUrlForProxy(url);\r\n  };\r\n\r\n  /**\r\n   * Checks if the transport is ready to start a connection.\r\n   *\r\n   * @param {Socket} socket The socket instance that needs a transport\r\n   * @param {Function} fn The callback\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.ready = function (socket, fn) {\r\n    fn.call(this);\r\n  };\r\n\r\n  /**\r\n   * Clears the event handlers attached on to by specific transport implementations.\r\n   *\r\n   * @api private\r\n   */\r\n  Transport.prototype.clearEventHandlers = function () {\r\n      return this;\r\n  };\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.Socket = Socket;\r\n\r\n  /**\r\n   * Create a new `Socket.IO client` which can establish a persistent\r\n   * connection with a Socket.IO enabled server.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  function Socket (options) {\r\n    this.options = {\r\n        port: 80\r\n      , secure: false\r\n      , document: 'document' in global ? document : false\r\n      , resource: 'socket.io'\r\n      , transports: io.transports.slice()\r\n      , 'connect timeout': 10000\r\n      , 'try multiple transports': true\r\n      , 'reconnect': true\r\n      , 'reconnection delay': 500\r\n      , 'reconnection limit': Infinity\r\n      , 'reopen delay': 3000\r\n      , 'max reconnection attempts': 10\r\n      , 'sync disconnect on unload': true\r\n      , 'auto connect': true\r\n      , 'flash policy port': 10843\r\n    };\r\n\r\n    io.util.merge(this.options, options);\r\n\r\n    this.connected = false;\r\n    this.open = false;\r\n    this.connecting = false;\r\n    this.reconnecting = false;\r\n    this.namespaces = {};\r\n    this.buffer = [];\r\n    this.doBuffer = false;\r\n    this.disconnected = false;\r\n\r\n    if (this.options['sync disconnect on unload'] &&\r\n        (!this.isXDomain() || io.util.ua.hasCORS)) {\r\n      var self = this;\r\n\r\n      io.util.on(global, 'unload', function () {\r\n        self.disconnectSync();\r\n      }, false);\r\n    }\r\n\r\n    if (this.options['auto connect']) {\r\n      this.connect();\r\n    }\r\n};\r\n\r\n  /**\r\n   * Apply EventEmitter mixin.\r\n   */\r\n\r\n  io.util.mixin(Socket, io.EventEmitter);\r\n\r\n  /**\r\n   * Returns a namespace listener/emitter for this socket\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.of = function (name) {\r\n    if (!this.namespaces[name]) {\r\n      this.namespaces[name] = new io.SocketNamespace(this, name);\r\n\r\n      if (name !== '') {\r\n        this.namespaces[name].packet({ type: 'connect' });\r\n      }\r\n    }\r\n\r\n    return this.namespaces[name];\r\n  };\r\n\r\n  /**\r\n   * Emits the given event to the Socket and all namespaces\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.publish = function () {\r\n    this.emit.apply(this, arguments);\r\n\r\n    var nsp;\r\n\r\n    for (var i in this.namespaces) {\r\n      if (this.namespaces.hasOwnProperty(i)) {\r\n        nsp = this.of(i);\r\n        nsp.$emit.apply(nsp, arguments);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Performs the handshake\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  function empty () { };\r\n\r\n  Socket.prototype.handshake = function (fn) {\r\n    var self = this\r\n      , options = this.options;\r\n      \r\n    if (self.disconnected) {\r\n      return;\r\n    }\r\n\r\n    function complete (data) {\r\n      if (data instanceof Error) {\r\n        self.onError(data.message);\r\n      } else {\r\n        fn.apply(null, data.split(':'));\r\n      }\r\n    };\r\n\r\n    var url = options.rewriteUrlForProxy([\r\n          'http' + (options.secure ? 's' : '') + ':/'\r\n        , options.host + ':' + options.port\r\n        , options.resource\r\n        , io.protocol\r\n        , io.util.query(this.options.query, 't=' + +new Date)\r\n      ].join('/'));\r\n\r\n    if (this.isXDomain() && !io.util.ua.hasCORS) {\r\n      var insertAt = document.getElementsByTagName('script')[0]\r\n        , script = document.createElement('script');\r\n\r\n      script.src = url + '&jsonp=' + io.j.length;\r\n      insertAt.parentNode.insertBefore(script, insertAt);\r\n\r\n      io.j.push(function (data) {\r\n        complete(data);\r\n        script.parentNode.removeChild(script);\r\n      });\r\n    } else {\r\n      var xhr = io.util.request();\r\n      \r\n      xhr.open('GET', url, true);\r\n\r\n      var headers = this.options.requestHeaders;\r\n      if (headers !== undefined) {\r\n        Object.keys(headers).forEach(function(name) {\r\n          xhr.setRequestHeader(name, headers[name]);\r\n        });\r\n      }\r\n      xhr.onreadystatechange = function () {\r\n        if (xhr.readyState == 4) {\r\n          xhr.onreadystatechange = empty;\r\n\r\n          if (xhr.status == 200) {\r\n            complete(xhr.responseText);\r\n          } else {\r\n            !self.reconnecting && self.onError(xhr.responseText);\r\n          }\r\n        }\r\n      };\r\n      xhr.send(null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Find an available transport based on the options supplied in the constructor.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.getTransport = function (override) {\r\n    var transports = override || this.transports, match;\r\n\r\n    for (var i = 0, transport; transport = transports[i]; i++) {\r\n      if (io.Transport[transport]\r\n        && io.Transport[transport].check(this)\r\n        && (!this.isXDomain() || io.Transport[transport].xdomainCheck())) {\r\n        return new io.Transport[transport](this, this.sessionid);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Connects to the server.\r\n   *\r\n   * @param {Function} [fn] Callback.\r\n   * @returns {io.Socket}\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.connect = function (fn) {\r\n    if (this.connecting || this.disconnected) {\r\n      return this;\r\n    }\r\n\r\n    var self = this;\r\n\r\n    var onHandshakeComplete = (function (sid, heartbeat, close, transports) {\r\n      // Params come from response's body - it's splitted by ':'\r\n      // example: 1178beba4026e2c7-48e62d038b18f416:85:85:websocket,xhr-polling,jsonp-polling\r\n      self.sessionid = sid;\r\n      // Add two seconds, so connection is closed by server, not client - otherwise\r\n      // there will be a onSocketDisconnect event which will start health check, etc\r\n      // This can happen if server returns close/heartbeat timeout equal to 40 which is server's timeout to\r\n      // close long poll connection, in such case client can close connection before server response with empty\r\n      // response and client goes to health check. Server can return such timeout if client send too small ping timeout\r\n      // during handshake\r\n      self.closeTimeout = close * 1000 + 2000;\r\n      self.heartbeatTimeout = heartbeat * 1000 + 2000;\r\n      self.transports = transports ? io.util.intersect(\r\n          transports.split(',')\r\n        , self.options.transports\r\n      ) : self.options.transports;\r\n\r\n      self.setHeartbeatTimeout();\r\n      self.remainingTransports = self.transports.slice(0);\r\n\r\n      function tryNextTransport() {\r\n        if (!self.connected && !self.disconnected) {\r\n          self.connecting = false;\r\n          clearTimeout(self.connectTimeoutTimer);\r\n\r\n          if (self.options['try multiple transports']) {\r\n            while (self.remainingTransports.length > 0\r\n                   && self.remainingTransports.splice(0,1)[0] != self.transport.name) {}\r\n\r\n            if (self.remainingTransports.length){\r\n              connect(self.remainingTransports);\r\n            } else {\r\n              self.publish('connect_failed');\r\n            }\r\n          } else {\r\n            self.publish('connect_failed');\r\n          }\r\n        }\r\n      }\r\n\r\n\r\n      function connect (transports){\r\n        if (self.transport) {\r\n            self.transport.clearTimeouts();\r\n            self.transport.clearEventHandlers();\r\n        }\r\n\r\n        self.transport = self.getTransport(transports);\r\n        if (!self.transport || self.disconnected) return self.publish('connect_failed');\r\n\r\n        // once the transport is ready (i.e. page is fully loaded)\r\n        self.transport.ready(self, function () {\r\n          self.connecting = true;\r\n          self.publish('connecting', self.transport.name);\r\n          self.transport.open(tryNextTransport);\r\n\r\n          if (self.options['connect timeout']) {\r\n            self.connectTimeoutTimer = setTimeout(function () {\r\n              tryNextTransport();\r\n            }, self.options['connect timeout']);\r\n          }\r\n        });\r\n      }\r\n\r\n      connect(self.transports);\r\n\r\n      self.once('connect', function (){\r\n        clearTimeout(self.connectTimeoutTimer);\r\n\r\n        fn && typeof fn == 'function' && fn();\r\n      });\r\n    });\r\n\r\n    if (this.options['skipped handshake data']) {\r\n      // /v4/c protocol\r\n      var data = this.options['skipped handshake data'];\r\n      // There is no need for the client to know a Socket ID with this protocol\r\n      // Can probably just use some dummy/random/timestamp thing as session id, it is completely opaque, on server too\r\n      // It can also be filled retroactively after being sent from the server inside a WS message (trouter.connected),\r\n      // but I don't think we need to bother.\r\n      onHandshakeComplete('v4c-' + new Date().getTime(), data.timeout, data.timeout, 'websocket');\r\n    } else {\r\n      this.handshake(onHandshakeComplete);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Clears and sets a new heartbeat timeout using the value given by the\r\n   * server during the handshake.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.setHeartbeatTimeout = function () {\r\n    clearTimeout(this.heartbeatTimeoutTimer);\r\n\r\n    var self = this;\r\n    this.heartbeatTimeoutTimer = setTimeout(function () {\r\n      self.transport.onClose();\r\n    }, this.heartbeatTimeout);\r\n  };\r\n\r\n  /**\r\n   * Sends a message.\r\n   *\r\n   * @param {Object} data packet.\r\n   * @returns {io.Socket}\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.packet = function (data) {\r\n    if (this.connected && !this.doBuffer) {\r\n      this.transport.packet(data);\r\n    } else {\r\n      this.buffer.push(data);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Sets buffer state\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.setBuffer = function (v) {\r\n    this.doBuffer = v;\r\n\r\n    if (!v && this.connected && this.buffer.length) {\r\n      this.transport.payload(this.buffer);\r\n      this.buffer = [];\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Disconnect the established connect.\r\n   *\r\n   * @returns {io.Socket}\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.disconnect = function () {\r\n    if (this.connected || this.connecting) {\r\n      if (this.open) {\r\n        this.of('').packet({ type: 'disconnect' });\r\n      }\r\n\r\n      // handle disconnection immediately\r\n      this.onDisconnect('booted');\r\n    }\r\n    this.disconnected = true;\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Disconnects the socket with a sync XHR.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.disconnectSync = function () {\r\n    // ensure disconnection\r\n    var xhr = io.util.request()\r\n      , uri = this.resource + '/' + io.protocol + '/' + this.sessionid;\r\n\r\n    xhr.open('GET', uri, true);\r\n\r\n    // handle disconnection immediately\r\n    this.onDisconnect('booted');\r\n  };\r\n\r\n  /**\r\n   * Check if we need to use cross domain enabled transports. Cross domain would\r\n   * be a different port or different domain name.\r\n   *\r\n   * @returns {Boolean}\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.isXDomain = function () {\r\n\r\n    var port = global.location.port ||\r\n      ('https:' == global.location.protocol ? 443 : 80);\r\n\r\n    return this.options.host !== global.location.hostname\r\n      || this.options.port != port;\r\n  };\r\n\r\n  /**\r\n   * Called upon handshake.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onConnect = function () {\r\n    if (!this.connected) {\r\n      this.connected = true;\r\n      this.connecting = false;\r\n      if (!this.doBuffer) {\r\n        // make sure to flush the buffer\r\n        this.setBuffer(false);\r\n      }\r\n      this.emit('connect');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called when the transport opens\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onOpen = function () {\r\n    this.open = true;\r\n  };\r\n\r\n  /**\r\n   * Called when the transport closes.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onClose = function () {\r\n    this.open = false;\r\n    clearTimeout(this.heartbeatTimeoutTimer);\r\n  };\r\n\r\n  /**\r\n   * Called when the transport first opens a connection\r\n   *\r\n   * @param text\r\n   */\r\n\r\n  Socket.prototype.onPacket = function (packet) {\r\n    this.of(packet.endpoint).onPacket(packet);\r\n  };\r\n\r\n  /**\r\n   * Handles an error.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onError = function (err) {\r\n    if (err && err.advice) {\r\n      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {\r\n        this.disconnect();\r\n        if (this.options.reconnect) {\r\n          this.reconnect();\r\n        }\r\n      }\r\n    }\r\n\r\n    this.publish('error', err && err.reason ? err.reason : err);\r\n  };\r\n\r\n  /**\r\n   * Called when the transport disconnects.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onDisconnect = function (reason) {\r\n    var wasConnected = this.connected\r\n      , wasConnecting = this.connecting;\r\n\r\n    this.connected = false;\r\n    this.connecting = false;\r\n    this.open = false;\r\n\r\n    if (wasConnected || wasConnecting) {\r\n      this.transport.close();\r\n      this.transport.clearTimeouts();\r\n      if (wasConnected) {\r\n        this.publish('disconnect', reason);\r\n\r\n        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {\r\n          this.reconnect();\r\n        }\r\n      } else {\r\n        this.publish('close_during_connecting', reason);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called upon reconnection.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.reconnect = function () {\r\n    this.reconnecting = true;\r\n    this.reconnectionAttempts = 0;\r\n    this.reconnectionDelay = this.options['reconnection delay'];\r\n\r\n    var self = this\r\n      , maxAttempts = this.options['max reconnection attempts']\r\n      , tryMultiple = this.options['try multiple transports']\r\n      , limit = this.options['reconnection limit'];\r\n\r\n    function reset () {\r\n      if (self.connected) {\r\n        for (var i in self.namespaces) {\r\n          if (self.namespaces.hasOwnProperty(i) && '' !== i) {\r\n              self.namespaces[i].packet({ type: 'connect' });\r\n          }\r\n        }\r\n        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);\r\n      }\r\n\r\n      clearTimeout(self.reconnectionTimer);\r\n\r\n      self.removeListener('connect_failed', maybeReconnect);\r\n      self.removeListener('connect', maybeReconnect);\r\n\r\n      self.reconnecting = false;\r\n\r\n      delete self.reconnectionAttempts;\r\n      delete self.reconnectionDelay;\r\n      delete self.reconnectionTimer;\r\n      delete self.redoTransports;\r\n\r\n      self.options['try multiple transports'] = tryMultiple;\r\n    };\r\n\r\n    function maybeReconnect () {\r\n      if (!self.reconnecting) {\r\n        return;\r\n      }\r\n\r\n      if (self.connected) {\r\n        return reset();\r\n      };\r\n\r\n      if (self.connecting && self.reconnecting) {\r\n        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);\r\n      }\r\n\r\n      if (self.reconnectionAttempts++ >= maxAttempts) {\r\n        if (!self.redoTransports) {\r\n          self.on('connect_failed', maybeReconnect);\r\n          self.options['try multiple transports'] = true;\r\n          self.transport = self.getTransport();\r\n          self.redoTransports = true;\r\n          self.connect();\r\n        } else {\r\n          self.publish('reconnect_failed');\r\n          reset();\r\n        }\r\n      } else {\r\n        if (self.reconnectionDelay < limit) {\r\n          self.reconnectionDelay *= 2; // exponential back off\r\n        }\r\n\r\n        self.connect();\r\n        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);\r\n        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);\r\n      }\r\n    };\r\n\r\n    this.options['try multiple transports'] = false;\r\n    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);\r\n\r\n    this.on('connect', maybeReconnect);\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , 'undefined' === typeof global ? window : global\r\n);\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.SocketNamespace = SocketNamespace;\r\n\r\n  /**\r\n   * Socket namespace constructor.\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   */\r\n\r\n  function SocketNamespace (socket, name) {\r\n    this.socket = socket;\r\n    this.name = name || '';\r\n    this.flags = {};\r\n    this.json = new Flag(this, 'json');\r\n    this.ackPackets = 0;\r\n    this.acks = {};\r\n  };\r\n\r\n  /**\r\n   * Apply EventEmitter mixin.\r\n   */\r\n\r\n  io.util.mixin(SocketNamespace, io.EventEmitter);\r\n\r\n  /**\r\n   * Copies emit since we override it\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;\r\n\r\n  /**\r\n   * Creates a new namespace, by proxying the request to the socket. This\r\n   * allows us to use the synax as we do on the server.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  SocketNamespace.prototype.of = function () {\r\n    return this.socket.of.apply(this.socket, arguments);\r\n  };\r\n\r\n  /**\r\n   * Sends a packet.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  SocketNamespace.prototype.packet = function (packet) {\r\n    packet.endpoint = this.name;\r\n    this.socket.packet(packet);\r\n    this.flags = {};\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Sends a message\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  SocketNamespace.prototype.send = function (data, fn) {\r\n    var packet = {\r\n        type: this.flags.json ? 'json' : 'message'\r\n      , data: data\r\n    };\r\n\r\n    if ('function' == typeof fn) {\r\n      packet.id = ++this.ackPackets;\r\n      packet.ack = true;\r\n      this.acks[packet.id] = fn;\r\n    }\r\n\r\n    return this.packet(packet);\r\n  };\r\n\r\n  /**\r\n   * Emits an event\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  SocketNamespace.prototype.emit = function (name) {\r\n    var args = Array.prototype.slice.call(arguments, 1)\r\n      , lastArg = args[args.length - 1]\r\n      , packet = {\r\n            type: 'event'\r\n          , name: name\r\n        };\r\n\r\n    if ('function' == typeof lastArg) {\r\n      packet.id = ++this.ackPackets;\r\n      packet.ack = 'data';\r\n      this.acks[packet.id] = lastArg;\r\n      args = args.slice(0, args.length - 1);\r\n    }\r\n\r\n    packet.args = args;\r\n\r\n    return this.packet(packet);\r\n  };\r\n\r\n  /**\r\n   * Disconnects the namespace\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  SocketNamespace.prototype.disconnect = function () {\r\n    if (this.name === '') {\r\n      this.socket.disconnect();\r\n    } else {\r\n      this.packet({ type: 'disconnect' });\r\n      this.$emit('disconnect');\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Handles a packet\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  SocketNamespace.prototype.onPacket = function (packet) {\r\n    var self = this;\r\n\r\n    function ack () {\r\n      self.packet({\r\n          type: 'ack'\r\n        , args: io.util.toArray(arguments)\r\n        , ackId: packet.id\r\n      });\r\n    };\r\n\r\n    switch (packet.type) {\r\n      case 'connect':\r\n        this.$emit('connect');\r\n        break;\r\n\r\n      case 'disconnect':\r\n        if (this.name === '') {\r\n          this.socket.onDisconnect(packet.reason || 'booted');\r\n        } else {\r\n          this.$emit('disconnect', packet.reason || '');\r\n        }\r\n        break;\r\n\r\n      case 'message':\r\n      case 'json':\r\n        var params = ['message', packet.data];\r\n\r\n        if (packet.ack == 'data') {\r\n          params.push(ack);\r\n        } else if (packet.ack) {\r\n          this.packet({ type: 'ack', ackId: packet.id });\r\n        }\r\n\r\n        this.$emit.apply(this, params);\r\n        break;\r\n\r\n      case 'event':\r\n        var params = [packet.name].concat(packet.args);\r\n\r\n        if (packet.ack == 'data')\r\n          params.push(ack);\r\n\r\n        this.$emit.apply(this, params);\r\n        break;\r\n\r\n      case 'ack':\r\n        if (this.acks[packet.ackId]) {\r\n          this.acks[packet.ackId].apply(this, packet.args);\r\n          delete this.acks[packet.ackId];\r\n        }\r\n        break;\r\n\r\n      case 'error':\r\n        if (packet.advice){\r\n          this.socket.onError(packet);\r\n        } else {\r\n          if (packet.reason == 'unauthorized') {\r\n            this.$emit('connect_failed', packet.reason);\r\n          } else {\r\n            this.$emit('error', packet.reason);\r\n          }\r\n        }\r\n        break;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Flag interface.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  function Flag (nsp, name) {\r\n    this.namespace = nsp;\r\n    this.name = name;\r\n  };\r\n\r\n  /**\r\n   * Send a message\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  Flag.prototype.send = function () {\r\n    this.namespace.flags[this.name] = true;\r\n    this.namespace.send.apply(this.namespace, arguments);\r\n  };\r\n\r\n  /**\r\n   * Emit an event\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  Flag.prototype.emit = function () {\r\n    this.namespace.flags[this.name] = true;\r\n    this.namespace.emit.apply(this.namespace, arguments);\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.websocket = WS;\r\n\r\n  /**\r\n   * The WebSocket transport uses the HTML5 WebSocket API to establish an\r\n   * persistent connection with the Socket.IO server. This transport will also\r\n   * be inherited by the FlashSocket fallback as it provides a API compatible\r\n   * polyfill for the WebSockets.\r\n   *\r\n   * @constructor\r\n   * @extends {io.Transport}\r\n   * @api public\r\n   */\r\n\r\n  function WS (socket) {\r\n    io.Transport.apply(this, arguments);\r\n  };\r\n\r\n  /**\r\n   * Inherits from Transport.\r\n   */\r\n\r\n  io.util.inherit(WS, io.Transport);\r\n\r\n  /**\r\n   * Transport name\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  WS.prototype.name = 'websocket';\r\n\r\n  function empty() { };\r\n\r\n  /**\r\n   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach\r\n   * all the appropriate listeners to handle the responses from the server.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  WS.prototype.open = function (connectErrorCallback) {\r\n    var query = io.util.query(this.socket.options.query)\r\n      , self = this\r\n      , Socket\r\n\r\n    this.connectErrorCallback = connectErrorCallback;\r\n\r\n    if (!Socket) {\r\n      Socket = global.MozWebSocket || global.WebSocket;\r\n    }\r\n\r\n    this.websocket = new Socket(this.prepareUrl(query));\r\n\r\n    this.websocket.onopen = function () {\r\n      self.onOpen();\r\n      self.socket.setBuffer(false);\r\n    };\r\n    this.websocket.onmessage = function (ev) {\r\n      self.onData(ev.data);\r\n    };\r\n    this.websocket.onclose = function () {\r\n      self.onClose();\r\n      self.socket.setBuffer(true);\r\n    };\r\n    this.websocket.onerror = function (e) {\r\n      self.onError(e);\r\n    };\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Send a message to the Socket.IO server. The message will automatically be\r\n   * encoded in the correct message format.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  WS.prototype.send = function (data) {\r\n    this.websocket.send(data);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Payload\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  WS.prototype.payload = function (arr) {\r\n    for (var i = 0, l = arr.length; i < l; i++) {\r\n      this.packet(arr[i]);\r\n    }\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Disconnect the established `WebSocket` connection.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  WS.prototype.close = function () {\r\n    this.websocket.close();\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Handle the errors that `WebSocket` might be giving when we\r\n   * are attempting to connect or send messages.\r\n   *\r\n   * @param {Error} e The error.\r\n   * @api private\r\n   */\r\n\r\n  WS.prototype.onError = function (e) {\r\n      if (this.connectErrorCallback !== undefined) {\r\n        this.connectErrorCallback();\r\n        this.connectErrorCallback = undefined;\r\n      }\r\n      this.socket.onError(e);\r\n  };\r\n\r\n  /**\r\n   * Returns the appropriate scheme for the URI generation.\r\n   *\r\n   * @api private\r\n   */\r\n  WS.prototype.scheme = function () {\r\n    return this.socket.options.secure ? 'wss' : 'ws';\r\n  };\r\n\r\n  /**\r\n   * Checks if the browser has support for native `WebSockets` and that\r\n   * it's not the polyfill created for the FlashSocket transport.\r\n   *\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  WS.check = function () {\r\n    return ('WebSocket' in global && !('__addTask' in WebSocket))\r\n          || 'MozWebSocket' in global;\r\n  };\r\n\r\n  /**\r\n   * Check if the `WebSocket` transport support cross domain communications.\r\n   *\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  WS.xdomainCheck = function () {\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Clears the event listeners attached to the `WebSocket` transport object.\r\n   *\r\n   * @api private\r\n   */\r\n  WS.prototype.clearEventHandlers = function() {\r\n      if (this.websocket) {\r\n          this.websocket.onopen = this.websocket.onmessage = this.websocket.onclose = this.websocket.onerror = empty;\r\n      }\r\n      return this;\r\n  };\r\n\r\n  /**\r\n   * Add the transport to your public io.transports array.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  io.transports.push('websocket');\r\n\r\n})(\r\n    'undefined' != typeof io ? io.Transport : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , 'undefined' === typeof global ? window : global\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  exports.XHR = XHR;\r\n\r\n  /**\r\n   * XHR constructor\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   */\r\n\r\n  function XHR (socket) {\r\n    if (!socket) return;\r\n\r\n    io.Transport.apply(this, arguments);\r\n  };\r\n\r\n  /**\r\n   * Inherits from Transport.\r\n   */\r\n\r\n  io.util.inherit(XHR, io.Transport);\r\n\r\n  /**\r\n   * Establish a connection\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  XHR.prototype.open = function () {\r\n    this.socket.setBuffer(false);\r\n    this.onOpen();\r\n    this.get();\r\n\r\n    // we need to make sure the request succeeds since we have no indication\r\n    // whether the request opened or not until it succeeded.\r\n    this.setCloseTimeout();\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Check if we need to send data to the Socket.IO server, if we have data in our\r\n   * buffer we encode it and forward it to the `post` method.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  XHR.prototype.payload = function (payload) {\r\n    var msgs = [];\r\n\r\n    for (var i = 0, l = payload.length; i < l; i++) {\r\n      msgs.push(io.parser.encodePacket(payload[i]));\r\n    }\r\n\r\n    this.send(io.parser.encodePayload(msgs));\r\n  };\r\n\r\n  /**\r\n   * Send data to the Socket.IO server.\r\n   *\r\n   * @param data The message\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  XHR.prototype.send = function (data) {\r\n    this.post(data);\r\n    return this;\r\n  };\r\n\r\n  function empty () { };\r\n\r\n  /**\r\n   * Posts a encoded message to the Socket.IO server.\r\n   *\r\n   * IMPORTANT: Note that only one of these requests should be in flight at any time,\r\n   * see the mutation of `doBuffer` via `setBuffer`, and where `post` is called from.\r\n   * Subsequent messages will be queued, and sent out on the next call\r\n   * to `setBuffer(false)` (e.g. from the success callback).\r\n   *\r\n   * @param {String} data A encoded message.\r\n   * @api private\r\n   */\r\n  XHR.prototype.post = function (data) {\r\n    var self = this;\r\n    this.socket.setBuffer(true);\r\n\r\n    this.sendXHR = this.request('POST');\r\n\r\n    function stateChange () {\r\n      if (this.readyState == 4) {\r\n        this.onreadystatechange = empty;\r\n\r\n        if (this.status == 200) {\r\n          clearTimeout(this.ackTimeoutTimer);\r\n\r\n          // this flushes the buffer, which can trigger another call to `post`,\r\n          // that will overwrite `self.sendXHR`\r\n          self.socket.setBuffer(false);\r\n\r\n          // at this point, self.sendXHR may already be the subsequent request\r\n        } else {\r\n          self.onClose();\r\n        }\r\n      }\r\n    }\r\n\r\n    function onload () {\r\n      this.onload = empty;\r\n      self.socket.setBuffer(false);\r\n    };\r\n\r\n    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {\r\n      this.sendXHR.onload = this.sendXHR.onerror = onload;\r\n    } else {\r\n      this.sendXHR.onreadystatechange = stateChange;\r\n    }\r\n\r\n    this.sendXHR.send(data);\r\n    self.sendXHR.ackTimeoutTimer = setTimeout(function () {\r\n      self.onClose();\r\n    }, self.socket.options.ackTimeoutMs);\r\n  };\r\n\r\n  /**\r\n   * Disconnects the established `XHR` connection.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  XHR.prototype.close = function () {\r\n    this.onClose();\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Generates a configured XHR request\r\n   *\r\n   * @param {String} url The url that needs to be requested.\r\n   * @param {String} method The method the request should use.\r\n   * @returns {XMLHttpRequest}\r\n   * @api private\r\n   */\r\n\r\n  XHR.prototype.request = function (method) {\r\n    var req = io.util.request(this.socket.isXDomain())\r\n      , query = io.util.query(this.socket.options.query, 't=' + +new Date);\r\n\r\n    req.open(method || 'GET', this.prepareUrl(query), true);\r\n\r\n    var headers = this.socket.options.requestHeaders;\r\n    if (headers !== undefined) {\r\n      Object.keys(headers).forEach(function(name) {\r\n        req.setRequestHeader(name, headers[name]);\r\n      });\r\n    }\r\n\r\n    if (method == 'POST') {\r\n      try {\r\n        if (req.setRequestHeader) {\r\n          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\r\n        } else {\r\n          // XDomainRequest\r\n          req.contentType = 'text/plain';\r\n        }\r\n      } catch (e) {}\r\n    }\r\n\r\n    return req;\r\n  };\r\n\r\n  /**\r\n   * Returns the scheme to use for the transport URLs.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  XHR.prototype.scheme = function () {\r\n    return this.socket.options.secure ? 'https' : 'http';\r\n  };\r\n\r\n  /**\r\n   * Check if the XHR transports are supported\r\n   *\r\n   * @param {Boolean} xdomain Check if we support cross domain requests.\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  XHR.check = function (socket, xdomain) {\r\n\r\n    try {\r\n      var request = io.util.request(xdomain),\r\n          usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),\r\n          socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),\r\n          isXProtocol = (socketProtocol != global.location.protocol);\r\n      if (request && !(usesXDomReq && isXProtocol)) {\r\n        return true;\r\n      }\r\n    } catch(e) {}\r\n\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Check if the XHR transport supports cross domain requests.\r\n   *\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  XHR.xdomainCheck = function () {\r\n    return XHR.check(null, true);\r\n  };\r\n\r\n  /**\r\n   * Clears the event listeners attached to the XHR transport object.\r\n   *\r\n   * @api private\r\n   */\r\n  XHR.prototype.clearEventHandlers = function () {\r\n      if (this.sendXHR) {\r\n          this.sendXHR.onreadystatechange = this.sendXHR.onload = empty;\r\n      }\r\n      return this;\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io.Transport : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , 'undefined' === typeof global ? window : global\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports['xhr-polling'] = XHRPolling;\r\n\r\n  /**\r\n   * The XHR-polling transport uses long polling XHR requests to create a\r\n   * \"persistent\" connection with the server.\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   */\r\n\r\n  function XHRPolling () {\r\n    io.Transport.XHR.apply(this, arguments);\r\n  };\r\n\r\n  /**\r\n   * Inherits from XHR transport.\r\n   */\r\n\r\n  io.util.inherit(XHRPolling, io.Transport.XHR);\r\n\r\n  /**\r\n   * Merge the properties from XHR transport\r\n   */\r\n\r\n  io.util.merge(XHRPolling, io.Transport.XHR);\r\n\r\n  /**\r\n   * Transport name\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  XHRPolling.prototype.name = 'xhr-polling';\r\n\r\n  /**\r\n   * Establish a connection, for iPhone and Android this will be done once the page\r\n   * is loaded.\r\n   *\r\n   * @returns {Transport} Chaining.\r\n   * @api public\r\n   */\r\n\r\n  XHRPolling.prototype.open = function (connectErrorCallback) {\r\n    var self = this;\r\n\r\n    self.connectErrorCallback = connectErrorCallback;\r\n\r\n    io.Transport.XHR.prototype.open.call(self);\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Starts a XHR request to wait for incoming messages.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  function empty () {};\r\n\r\n  XHRPolling.prototype.get = function () {\r\n    if (!this.isOpened) return;\r\n\r\n    var self = this;\r\n\r\n    function stateChange () {\r\n      if (this.readyState == 4) {\r\n        this.onreadystatechange = empty;\r\n\r\n        if (this.status == 200) {\r\n          self.connectErrorCallback = undefined;\r\n          self.onData(this.responseText);\r\n          self.get();\r\n        } else {\r\n          self.onClose();\r\n\r\n          if (self.connectErrorCallback !== undefined) {\r\n            self.connectErrorCallback();\r\n            self.connectErrorCallback = undefined;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    function onload () {\r\n      self.connectErrorCallback = undefined;\r\n      this.onload = empty;\r\n      this.onerror = empty;\r\n      self.onData(this.responseText);\r\n      self.get();\r\n    };\r\n\r\n    function onerror () {\r\n      self.onClose();\r\n\r\n      if (self.connectErrorCallback !== undefined) {\r\n        self.connectErrorCallback();\r\n        self.connectErrorCallback = undefined;\r\n      }\r\n    };\r\n\r\n    this.xhr = this.request();\r\n\r\n    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {\r\n      this.xhr.onload = onload;\r\n      this.xhr.onerror = onerror;\r\n    } else {\r\n      this.xhr.onreadystatechange = stateChange;\r\n    }\r\n\r\n    this.xhr.send(null);\r\n  };\r\n\r\n  /**\r\n   * Handle the unclean close behavior.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  XHRPolling.prototype.onClose = function () {\r\n    io.Transport.XHR.prototype.onClose.call(this);\r\n\r\n    if (this.xhr) {\r\n      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;\r\n      try {\r\n        this.xhr.abort();\r\n      } catch(e){}\r\n      this.xhr = null;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Webkit based browsers show a infinit spinner when you start a XHR request\r\n   * before the browsers onload event is called so we need to defer opening of\r\n   * the transport until the onload event is called. Wrapping the cb in our\r\n   * defer method solve this.\r\n   *\r\n   * @param {Socket} socket The socket instance that needs a transport\r\n   * @param {Function} fn The callback\r\n   * @api private\r\n   */\r\n\r\n  XHRPolling.prototype.ready = function (socket, fn) {\r\n    var self = this;\r\n\r\n    io.util.defer(function () {\r\n      fn.call(self);\r\n    });\r\n  };\r\n\r\n   /**\r\n   * Clears the event listeners attached to the XHR transport object.\r\n   *\r\n   * @api private\r\n   */\r\n  XHRPolling.prototype.clearEventHandlers = function () {\r\n      io.Transport.XHR.prototype.clearEventHandlers.call(this);\r\n\r\n      if (this.xhr) {\r\n          this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;\r\n      }\r\n      return this;\r\n  }\r\n\r\n  /**\r\n   * Add the transport to your public io.transports array.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  io.transports.push('xhr-polling');\r\n\r\n})(\r\n    'undefined' != typeof io ? io.Transport : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , 'undefined' === typeof global ? window : global\r\n);\r\n\r\nexports.io = io;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(14)(module)))\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConnectionTracker = exports.Properties = exports.TrackerStep = exports.ClientEventName = exports.ResponseData = void 0;\nvar Common_1 = __webpack_require__(3);\nvar Constants_1 = __webpack_require__(1);\nvar Logger_1 = __webpack_require__(0);\n/**\n * Data for trouter response\n */\nvar ResponseData = /** @class */ (function () {\n    function ResponseData(id) {\n        this.id = id;\n        this.status = 200;\n        this.headers = {};\n        this.body = '';\n    }\n    return ResponseData;\n}());\nexports.ResponseData = ResponseData;\n// Possible telemetry events\nvar ClientEventName;\n(function (ClientEventName) {\n    ClientEventName[\"Connected\"] = \"trouter_js_client_connected\";\n    ClientEventName[\"Disconnected\"] = \"trouter_js_client_disconnected\";\n    ClientEventName[\"Error\"] = \"trouter_js_client_error\";\n    ClientEventName[\"Progress\"] = \"trouter_js_client_progress\";\n    ClientEventName[\"Response\"] = \"trouter_js_client_response\";\n    ClientEventName[\"Request\"] = \"trouter_js_client_request\";\n    ClientEventName[\"CheckConnection\"] = \"trouter_js_client_check_connection\";\n    ClientEventName[\"Registration\"] = \"trouter_js_client_registration\";\n    ClientEventName[\"Unregistration\"] = \"trouter_js_client_unregistration\";\n})(ClientEventName || (exports.ClientEventName = ClientEventName = {}));\n/**\n * Stores one step of connection process\n */\nvar TrackerStep = /** @class */ (function () {\n    function TrackerStep(stepName, operation, delta, ts, error) {\n        this.stepName = stepName;\n        this.operation = operation;\n        this.delta = delta;\n        this.ts = ts;\n        this.error = error;\n    }\n    return TrackerStep;\n}());\nexports.TrackerStep = TrackerStep;\n/**\n * Base class for something that can be used as a property bag\n */\nvar Properties = /** @class */ (function () {\n    function Properties() {\n    }\n    return Properties;\n}());\nexports.Properties = Properties;\n/**\n * Information about connection\n */\nvar ConnectedInfo = /** @class */ (function () {\n    function ConnectedInfo() {\n        this.numberOfPingReplies = 0;\n        this.connectedTimestamp = 0;\n        this.isNewUrl = false;\n        this.transportType = '';\n        this.connectionNumber = 0;\n    }\n    return ConnectedInfo;\n}());\n/**\n * Default values for IEventLogSettings\n */\nvar EventLogSettings = /** @class */ (function () {\n    function EventLogSettings() {\n        this.enabled = false;\n        this.numberOfStepsToMaintain = 40;\n        this.logHealthCheckError = false;\n        this.sendProgressTimeoutSecs = 55;\n        this.logSendPingError = false;\n        this.maxBackoffInMs = 120000;\n        this.trouter_js_client_connected = false;\n        this.trouter_js_client_disconnected = false;\n        this.trouter_js_client_error = false;\n        this.trouter_js_client_progress = false;\n        this.trouter_js_client_response = false;\n        this.trouter_js_client_request = false;\n        this.trouter_js_client_registration = false;\n        this.trouter_js_client_unregistration = false;\n        /** This event is ENABLED by default */\n        this.trouter_js_client_check_connection = true;\n    }\n    return EventLogSettings;\n}());\n/**\n * Telemetry sender\n */\nvar ConnectionTracker = /** @class */ (function () {\n    function ConnectionTracker(logfunc, clientId, clientInfo, getServerState, endpointId, clientCorrelationID, environment) {\n        this.clientId = clientId;\n        this.clientInfo = clientInfo;\n        this.getServerState = getServerState;\n        this.endpointId = endpointId;\n        this.clientCorrelationID = clientCorrelationID;\n        this.environment = environment;\n        this.logger = new Logger_1.Logger('ConnectionTracker', logfunc);\n        this.clientCorrelationID = clientCorrelationID !== undefined ? clientCorrelationID : '';\n        this.steps = [];\n        this.connectionAttempt = 0;\n        this.totalStepCount = 0;\n        this.beginTimestamp = new Common_1.Timespan();\n        this.eventLogSettings = new EventLogSettings();\n        this.connectedInfo = new ConnectedInfo();\n    }\n    ConnectionTracker.prototype.enable = function (telemetrySender) {\n        this.eventLogSettings.enabled = true;\n        this.eventLogger = telemetrySender;\n    };\n    ConnectionTracker.prototype.disable = function () {\n        this.eventLogSettings.enabled = false;\n    };\n    ConnectionTracker.prototype.sendProgress = function (context) {\n        // connect truncates steps array. this check ensures that a progress event is only sent out if the client is not connected\n        if (this.steps.length > 0) {\n            this.sendTelemetry(ClientEventName.Progress, context, this.steps);\n        }\n    };\n    ConnectionTracker.prototype.cancelProgressTimer = function () {\n        if (this.progressTimeout !== undefined) {\n            clearTimeout(this.progressTimeout);\n            this.progressTimeout = undefined;\n        }\n    };\n    ConnectionTracker.prototype.resetProgressSendTimer = function () {\n        var _this = this;\n        this.cancelProgressTimer();\n        // send connection steps after a timeout\n        // this timeout may fire if auth callback never comes or the client is stuck in a loop to get connected\n        if (this.eventLogSettings.sendProgressTimeoutSecs !== undefined && this.eventLogSettings.sendProgressTimeoutSecs > 0) {\n            this.progressTimeout = setTimeout(function () {\n                _this.sendProgress({\n                    reason: 'timeout',\n                    timeoutSecs: _this.eventLogSettings.sendProgressTimeoutSecs\n                });\n            }, 1000 * this.eventLogSettings.sendProgressTimeoutSecs);\n        }\n    };\n    ConnectionTracker.prototype.setConnectedInfo = function (isNewUrl, transportType) {\n        this.connectedInfo.numberOfPingReplies = 0;\n        this.connectedInfo.connectedTimestamp = Date.now();\n        this.connectedInfo.isNewUrl = isNewUrl;\n        this.connectedInfo.transportType = transportType;\n        ++this.connectedInfo.connectionNumber;\n    };\n    ConnectionTracker.prototype.clearConnectedInfo = function () {\n        this.connectedInfo.numberOfPingReplies = 0;\n        this.connectedInfo.connectedTimestamp = 0;\n        this.connectedInfo.isNewUrl = true;\n        this.connectedInfo.transportType = '';\n    };\n    // Copies from\n    // source {\n    //    propName: value\n    // }\n    // to\n    // dest {\n    //    propName: { value: actualValue }\n    // }\n    ConnectionTracker.prototype.copyProperties = function (dest, source) {\n        // copy properties from source and add in a format expected by logger\n        for (var _i = 0, _a = Object.keys(source); _i < _a.length; _i++) {\n            var prop = _a[_i];\n            if (source[prop] !== undefined) {\n                // replace hyphen by _\n                dest[prop.replace(/-/g, '_')] = { value: source[prop] };\n            }\n        }\n    };\n    ConnectionTracker.prototype.increasePingResponseCount = function () {\n        ++this.connectedInfo.numberOfPingReplies;\n    };\n    /**\n     * @param eventName Telemetry event name\n     * @param eventProperties Event property bag\n     * @param progress\n     */\n    ConnectionTracker.prototype.sendTelemetry = function (eventName, eventProperties, progress) {\n        try {\n            if (this.eventLogSettings.enabled === true\n                && this.eventLogSettings[eventName] === true\n                && this.eventLogger !== undefined) {\n                var serverState = this.getServerState();\n                var clientEvent = {\n                    name: eventName,\n                    properties: {\n                        connectionAttempt: { value: this.connectionAttempt },\n                        epid: { value: this.endpointId },\n                        clientCorrelationID: { value: this.clientCorrelationID },\n                        steps: { value: (0, Common_1.toJson)(progress) },\n                        clientID: { value: this.clientId },\n                        eventVersion: { value: 3 },\n                        environment: { value: this.environment },\n                        cv: { value: Constants_1.CLIENT_VERSION },\n                        ua: { value: this.clientInfo.ua },\n                        // Copy ServerState\n                        connectionId: { value: serverState.connectionId },\n                        connectedClientId: { value: serverState.connectedClientId },\n                        domId: { value: serverState.domId },\n                        url: { value: serverState.unsecureUrl },\n                        surl: { value: serverState.url },\n                        ttlInSecs: { value: serverState.getRemainingTtlInSec() },\n                        // Copy this.connectedInfo\n                        numberOfPingReplies: { value: this.connectedInfo.numberOfPingReplies },\n                        connectedTimestamp: { value: this.connectedInfo.connectedTimestamp },\n                        isNewUrl: { value: this.connectedInfo.isNewUrl },\n                        transportType: { value: this.connectedInfo.transportType },\n                        connectionNumber: { value: this.connectedInfo.connectionNumber }\n                    }\n                };\n                this.copyProperties(clientEvent.properties, eventProperties);\n                this.eventLogger.logEvent(clientEvent);\n            }\n        }\n        catch (exc) {\n            this.logger.warn(\"error in sending event \".concat(eventName, \": \").concat((0, Common_1.toJson)(exc)));\n        }\n    };\n    ConnectionTracker.prototype.createStep = function (stepName, operation, error) {\n        return new TrackerStep(stepName, operation, this.beginTimestamp.duration, Date.now(), error);\n    };\n    ConnectionTracker.prototype.addStep = function (tag, progressHint, error) {\n        if (this.eventLogSettings.enabled === false) {\n            return;\n        }\n        if (this.steps.length === 0) {\n            this.beginTimestamp.reset();\n        }\n        this.steps.push(this.createStep(tag, progressHint, error));\n        ++this.totalStepCount;\n        // do not maintain an ever growing list of steps. send a progress event with what is collected so far and clear steps\n        // there should be enough context in any event for the server to group events created for the sameonnection\n        if (this.eventLogSettings.numberOfStepsToMaintain !== undefined\n            && this.steps.length > this.eventLogSettings.numberOfStepsToMaintain) {\n            var progress = this.steps.slice(0);\n            this.steps.length = 0;\n            this.sendTelemetry(ClientEventName.Progress, { reason: 'flush' }, progress);\n        }\n    };\n    ConnectionTracker.prototype.trackStart = function (tag) {\n        this.addStep(tag, 'start');\n    };\n    ConnectionTracker.prototype.trackEnd = function (tag) {\n        this.addStep(tag, 'end');\n    };\n    ConnectionTracker.prototype.trackError = function (tag, error, addStep, subOperation) {\n        if (addStep === void 0) { addStep = true; }\n        if (tag === 'health' && this.eventLogSettings.logHealthCheckError !== true) {\n            return;\n        }\n        if (tag === 'ping' && this.eventLogSettings.logSendPingError === false) {\n            return;\n        }\n        if (subOperation === undefined) {\n            subOperation = 'error';\n        }\n        if (addStep === true) {\n            this.addStep(tag, subOperation, error);\n        }\n        this.sendTelemetry(ClientEventName.Error, {}, [this.createStep(tag, subOperation, error)]);\n    };\n    ConnectionTracker.prototype.trackProgress = function (tag, subOperation) {\n        this.addStep(tag, subOperation);\n    };\n    ConnectionTracker.prototype.trackConnected = function (isNewUrl, transportType) {\n        this.setConnectedInfo(isNewUrl, transportType);\n        var progress = this.steps.slice(0);\n        var totalSteps = this.totalStepCount;\n        var connectionDuration = this.beginTimestamp.duration;\n        // clear steps collected\n        this.steps.length = 0;\n        this.totalStepCount = 0;\n        this.sendTelemetry(ClientEventName.Connected, {\n            stepCount: progress.length,\n            totalStepCount: totalSteps,\n            connectionEstablishmentMs_Total: connectionDuration\n        }, progress);\n        this.cancelProgressTimer();\n    };\n    ConnectionTracker.prototype.getSessionLength = function () {\n        return Date.now() - this.connectedInfo.connectedTimestamp;\n    };\n    ConnectionTracker.prototype.trackDisconnected = function (context) {\n        context.sessionLengthMS = this.getSessionLength();\n        this.sendTelemetry(ClientEventName.Disconnected, context, []);\n        this.resetProgressSendTimer();\n    };\n    ConnectionTracker.prototype.trackNewConnection = function () {\n        ++this.connectionAttempt;\n    };\n    ConnectionTracker.prototype.trackRequest = function (request, errorMsg) {\n        var context = {};\n        if (errorMsg !== undefined) {\n            context.hasError = true;\n            context.error = errorMsg;\n        }\n        try {\n            if (request) {\n                context.requestID = request.id;\n                context.httpMethod = request.method;\n                context.url = request.url;\n                context.bodyLength = request.body.length;\n                context.shortUrl = request.shortUrl;\n                context.requestTimeStamp = request.startTS;\n                context.correlationVector = request.correlationVector;\n                var headers = request.headers;\n                for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n                    var header = _a[_i];\n                    context[header] = headers[header];\n                }\n            }\n        }\n        catch (exc) {\n            context.hasError = true;\n            context.error = \"\".concat(context.error, \" error creating request context \").concat((0, Common_1.toJson)(exc));\n        }\n        this.sendTelemetry(ClientEventName.Request, context, []);\n    };\n    ConnectionTracker.prototype.trackResponse = function (request, latencyMS, responseData, errorMsg) {\n        var context = {};\n        if (errorMsg !== undefined) {\n            context.hasError = true;\n            context.error = errorMsg;\n        }\n        try {\n            context.responseTimestamp = responseData !== undefined ? responseData.sentTS : Date.now();\n            if (request) {\n                context.requestID = request.id;\n                context.httpMethod = request.method;\n                context.shortUrl = request.shortUrl;\n                context.correlationVector = request.correlationVector;\n                var headers = request.headers;\n                for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n                    var header = _a[_i];\n                    context[header] = headers[header];\n                }\n            }\n            if (responseData) {\n                context.latencyMS = latencyMS;\n                context.responseCode = responseData.status;\n                context.responseLength = responseData.body.length;\n            }\n        }\n        catch (exc) {\n            context.hasError = true;\n            context.error = \"\".concat(context.error, \" error creating response context \").concat((0, Common_1.toJson)(exc));\n        }\n        this.sendTelemetry(ClientEventName.Response, context, []);\n    };\n    ConnectionTracker.prototype.sendResponseError = function (errorMsg, request, responseData) {\n        this.trackResponse(request, undefined, responseData, errorMsg);\n    };\n    ConnectionTracker.prototype.close = function () {\n        this.sendProgress({\n            reason: 'closed'\n        });\n        this.steps.length = 0;\n        this.cancelProgressTimer();\n    };\n    ConnectionTracker.prototype.mergeSettings = function (settings) {\n        if (!settings) {\n            return;\n        }\n        this.eventLogSettings.numberOfStepsToMaintain = Math.min(40, Math.max(10, (settings.numberOfStepsToMaintain !== undefined ? settings.numberOfStepsToMaintain : 0)));\n        // min of 55 secs and max allowed is 1 hr\n        var newProgressTimeout = Math.min(3600, Math.max(55, settings.sendProgressTimeoutSecs !== undefined ? settings.sendProgressTimeoutSecs : 0));\n        this.eventLogSettings.logHealthCheckError = settings.logHealthCheckError;\n        this.eventLogSettings.logSendPingError = settings.logSendPingError;\n        // Copy enable/disable flags for all telemetry events\n        for (var _i = 0, _a = Object.keys(ClientEventName).map(function (k) { return ClientEventName[k]; }); _i < _a.length; _i++) {\n            var iterator = _a[_i];\n            if (settings[iterator] !== undefined) {\n                this.eventLogSettings[iterator] = settings[iterator];\n            }\n        }\n        if (this.eventLogSettings.sendProgressTimeoutSecs !== newProgressTimeout) {\n            this.eventLogSettings.sendProgressTimeoutSecs = newProgressTimeout;\n            this.resetProgressSendTimer();\n        }\n    };\n    return ConnectionTracker;\n}());\nexports.ConnectionTracker = ConnectionTracker;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DisconnectReason = void 0;\n/**\n * Disconnect reason format sent when using the /v4/c protocol as part of the socket.io disconnect (`0::`),\n * e.g.\n * - `0::`\n * - `0:::dup`\n * - `0:::{\"reason\":\"unauthorized\",\"claims\":\"Bearer token_types=\\\"skype,aad,cae\\\"\"}`\n *\n * Additionally, it is also used internally for other socket.io events calling `TrouterFsm.onSocketDisconnect` (see usages).\n */\nvar DisconnectReason = /** @class */ (function () {\n    function DisconnectReason(reason, claims, details) {\n        this.reason = reason;\n        this.claims = claims;\n        this.details = details;\n    }\n    DisconnectReason.fromRawReason = function (rawReason, logger) {\n        if (rawReason === '' || rawReason === 'dup') {\n            return new DisconnectReason(rawReason);\n        }\n        try {\n            var parsedReason = JSON.parse(rawReason);\n            if (typeof parsedReason !== 'object' || parsedReason.reason === undefined) {\n                logger === null || logger === void 0 ? void 0 : logger.error('invalid disconnect reason format');\n                return new DisconnectReason('unknown', undefined, rawReason);\n            }\n            return new DisconnectReason(parsedReason.reason, parsedReason.claims, parsedReason.details);\n        }\n        catch (e) {\n            // Non-JSON string from the `0::` socket.io message is just set \"as is\" as details\n            return new DisconnectReason('disconnect', undefined, rawReason);\n        }\n    };\n    DisconnectReason.fromSocketIoEventData = function (event, arg) {\n        return typeof arg === 'string' ? new DisconnectReason(event, undefined, arg) : undefined;\n    };\n    DisconnectReason.prototype.toTelemetryString = function () {\n        if (this.reason === 'socketerror' || this.reason === 'reconnecterror' || this.reason === 'disconnect') {\n            return this.details;\n        }\n        return this.reason;\n    };\n    return DisconnectReason;\n}());\nexports.DisconnectReason = DisconnectReason;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExponentialBackoff = void 0;\n/**\n * Executes callbacks with exponential backoff\n */\nvar ExponentialBackoff = /** @class */ (function () {\n    function ExponentialBackoff(logger, maxBackoffInMs, gapDetectionSettings) {\n        if (gapDetectionSettings === void 0) { gapDetectionSettings = { tolerance: 2, minimumWaitMs: 10000 }; }\n        this.logger = logger;\n        this.maxBackoffInMs = maxBackoffInMs;\n        this.gapDetectionSettings = gapDetectionSettings;\n        this.backoffId = 0;\n        this.backoffCount = 0;\n    }\n    ExponentialBackoff.calculateNextBackoffMs = function (backoffCount, maxBackoffInMs) {\n        var fudge = 1 + (Math.random() - 0.5) * 0.4; // +/- 20%\n        var backoff = 1000 * Math.pow(2, backoffCount) * fudge; // 1s initial\n        backoff = Math.round(backoff);\n        return Math.min(maxBackoffInMs, backoff);\n    };\n    ExponentialBackoff.prototype.setMaxBackoffMs = function (ms) {\n        this.maxBackoffInMs = ms;\n    };\n    ExponentialBackoff.prototype.backoff = function (taskName, handler) {\n        var _this = this;\n        if (this.timerHandle !== undefined) {\n            this.logger.debug('Clearing current back off');\n            clearTimeout(this.timerHandle);\n            this.timerHandle = undefined;\n        }\n        // This detects a situation where the computer/tab likely went to sleep while NOT waiting on backoff,\n        // but doing other things (e.g. waiting on fetch, waiting on token provider, etc.),\n        // and woke up much later, the operation having failed, triggering a retry after backoff.\n        // If a lot of time has passed in sleep, we want to reset that backoff.\n        //\n        // We are counting on the fact that the operation (fetch, token wait, etc.) should never take significantly longer\n        // than the maximum allowed backoff time, to avoid unwanted resets.\n        //\n        // (If computer woke up while it WAS waiting on backoff, after a long time, it would likely complete that wait\n        // immediately, so previousCompleteTime would be very close to the next attempt, thus not triggering this.)\n        if (this.previousCompleteTime !== undefined) {\n            var elapsed = Date.now() - this.previousCompleteTime;\n            // The time to reset this needs to be much longer here, as the operation itself can take quite a long time even under normal circumstances.\n            // In practice, based on settings as of February 2024, this can be triggered after a sleep that in some cases needs to be over 10 minutes.\n            if (elapsed > this.maxBackoffInMs * this.gapDetectionSettings.tolerance && elapsed > this.gapDetectionSettings.minimumWaitMs) {\n                this.logger.info(\"Back off for \".concat(taskName, \" with ID \").concat(this.backoffId, \" will be reset due to a lot of time having passed since the previous backoff (\").concat(elapsed, \" ms)\"));\n                this.backoffCount = 0;\n                this.previousCompleteTime = undefined;\n            }\n        }\n        var backoffMs = ExponentialBackoff.calculateNextBackoffMs(this.backoffCount, this.maxBackoffInMs);\n        this.backoffId++;\n        this.backoffCount++;\n        this.logger.info(\"Backing off \".concat(taskName, \" for \").concat(backoffMs, \" milliseconds with ID \").concat(this.backoffId));\n        this.callback = function (waitStart, expectedWait) {\n            if (shouldReset(waitStart, expectedWait, _this.gapDetectionSettings)) {\n                // Most likely computer/tab went to sleep while waiting on backoff and woke up much later\n                _this.logger.info(\"Back off for \".concat(taskName, \" with ID \").concat(_this.backoffId, \" will be reset due to the wait (\").concat(Date.now() - (waitStart !== null && waitStart !== void 0 ? waitStart : 0), \" ms) being longer than expected (\").concat(expectedWait, \" ms)\"));\n                _this.backoffCount = 0;\n            }\n            _this.logger.info(\"Back off for \".concat(taskName, \" with ID \").concat(_this.backoffId, \" complete, invoking handler\"));\n            _this.timerHandle = undefined;\n            _this.callback = undefined;\n            _this.previousCompleteTime = Date.now();\n            handler();\n        };\n        var backoffWaitStart = Date.now();\n        this.timerHandle = setTimeout(function () { var _a; return (_a = _this.callback) === null || _a === void 0 ? void 0 : _a.call(_this, backoffWaitStart, backoffMs); }, backoffMs);\n    };\n    /// Stop the backoff if active, do not call the handler and reset to the initial/shortest period again\n    ExponentialBackoff.prototype.reset = function () {\n        if (this.timerHandle !== undefined) {\n            this.logger.debug(\"Resetting back off with ID \".concat(this.backoffId));\n            clearTimeout(this.timerHandle);\n            this.timerHandle = undefined;\n            this.callback = undefined;\n        }\n        this.backoffCount = 0;\n    };\n    /// Call the handler right now if active and reset to the initial/shortest period again\n    ExponentialBackoff.prototype.expediteIfPending = function () {\n        this.backoffCount = 0;\n        if (this.timerHandle !== undefined) {\n            this.logger.debug(\"Expediting back off with ID \".concat(this.backoffId));\n            clearTimeout(this.timerHandle);\n            this.timerHandle = undefined;\n            var callback = this.callback;\n            this.callback = undefined;\n            if (callback) {\n                callback();\n            }\n        }\n    };\n    return ExponentialBackoff;\n}());\nexports.ExponentialBackoff = ExponentialBackoff;\nfunction shouldReset(waitStart, expectedWait, settings) {\n    if (waitStart === undefined || expectedWait === undefined) {\n        return false;\n    }\n    var actualWait = Date.now() - waitStart;\n    return actualWait > expectedWait * settings.tolerance && actualWait > settings.minimumWaitMs;\n}\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LoggingManagerConsumer = exports.RegistrationEnforcer = void 0;\nvar TrouterFsm_1 = __webpack_require__(6);\n/**\n * Intercepts calls from TrouterConnection to TrouterManager, to only allow\n * switching to the \"connected\" state after the connection\n * has been successfully registered, and disconnects Trouter if an existing\n * registration expires or gets revoked.\n *\n * One instance of this wrappere exists per each TrouterConnection (though wrapping the same TrouterManger instance),\n * this object thus holds state specific to a particular TrouterConnection.\n */\nvar RegistrationEnforcer = /** @class */ (function () {\n    function RegistrationEnforcer(wrapped, shouldConnectionDependOnRegistration, shouldHoldBackEvents) {\n        this.wrapped = wrapped;\n        this.shouldConnectionDependOnRegistration = shouldConnectionDependOnRegistration;\n        this.shouldHoldBackEvents = shouldHoldBackEvents;\n        this.isRegistered = false;\n        this.heldBackEvents = [];\n    }\n    RegistrationEnforcer.prototype.onDownstreamRequest = function (connection, request, response) {\n        this.passIfRegisteredOrNotNeeded('onDownstreamRequest', connection, request, response);\n    };\n    RegistrationEnforcer.prototype.onConnected = function (connection) {\n        this.passIfRegisteredOrNotNeeded('onConnected', connection);\n    };\n    RegistrationEnforcer.prototype.onRegistered = function (connection) {\n        this.isRegistered = true;\n        this.wrapped.onRegistered(connection);\n        this.fireHeldBackEvents();\n    };\n    RegistrationEnforcer.prototype.onUnregistered = function (connection) {\n        this.isRegistered = false;\n        this.wrapped.onUnregistered(connection);\n        if (connection.getState() === TrouterFsm_1.State.Connected && this.shouldConnectionDependOnRegistration()) {\n            connection.forceReconnectDueToNoRegistration();\n        }\n    };\n    RegistrationEnforcer.prototype.onReconnecting = function (connection) {\n        this.wrapped.onReconnecting(connection);\n    };\n    RegistrationEnforcer.prototype.onReconnectIsRequired = function (connection, useConnectParamsFromCache, reason) {\n        this.wrapped.onReconnectIsRequired(connection, useConnectParamsFromCache, reason);\n    };\n    RegistrationEnforcer.prototype.onDisconnected = function (connection) {\n        this.isRegistered = false;\n        this.dropHeldBackEvents();\n        this.wrapped.onDisconnected(connection);\n    };\n    RegistrationEnforcer.prototype.onTerminalError = function (connection) {\n        this.wrapped.onTerminalError(connection);\n    };\n    RegistrationEnforcer.prototype.onConnectionParametersUpdated = function (connectParams) {\n        this.wrapped.onConnectionParametersUpdated(connectParams);\n    };\n    RegistrationEnforcer.prototype.onTrouterMessageLost = function (flowTags) {\n        this.passIfRegisteredOrNotNeeded('onTrouterMessageLost', flowTags);\n    };\n    RegistrationEnforcer.prototype.onUserActivityStateAccepted = function (cv) {\n        this.passIfRegisteredOrNotNeeded('onUserActivityStateAccepted', cv);\n    };\n    RegistrationEnforcer.prototype.onAudiencesSetResolved = function (audienceSubscriptionsResponse, cv) {\n        this.passIfRegisteredOrNotNeeded('onAudiencesSetResolved', audienceSubscriptionsResponse, cv);\n    };\n    RegistrationEnforcer.prototype.getState = function () {\n        return this.wrapped.getState();\n    };\n    RegistrationEnforcer.prototype.holdBackEvent = function (kind) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        this.heldBackEvents.push({ kind: kind, args: args });\n    };\n    RegistrationEnforcer.prototype.passIfRegisteredOrNotNeeded = function (kind) {\n        var _a;\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var connectionDependsOnRegistration = this.shouldConnectionDependOnRegistration();\n        var holdBackEvents = this.shouldHoldBackEvents();\n        // replay existing events if we previously needed registration but now don't, or if we should not hold back events anymore\n        if (!connectionDependsOnRegistration || !holdBackEvents) {\n            this.fireHeldBackEvents(connectionDependsOnRegistration ?\n                function (e) { return e.kind !== 'onConnected'; } :\n                undefined);\n        }\n        if (this.isRegistered || !connectionDependsOnRegistration || (holdBackEvents === false && kind !== 'onConnected')) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-explicit-any\n            (_a = this.wrapped)[kind].apply(_a, args);\n        }\n        else {\n            this.holdBackEvent.apply(this, __spreadArray([kind], args, false));\n        }\n    };\n    RegistrationEnforcer.prototype.fireHeldBackEvents = function (filter) {\n        var _a;\n        for (var _i = 0, _b = this.heldBackEvents; _i < _b.length; _i++) {\n            var event_1 = _b[_i];\n            if (filter !== undefined && !filter(event_1)) {\n                continue;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-explicit-any\n            (_a = this.wrapped)[event_1.kind].apply(_a, event_1.args);\n        }\n        if (filter === undefined) {\n            this.heldBackEvents = [];\n        }\n        else {\n            // keep everything that wasn't fired\n            this.heldBackEvents = this.heldBackEvents.filter(function (e) { return !filter(e); });\n        }\n    };\n    RegistrationEnforcer.prototype.dropHeldBackEvents = function () {\n        this.heldBackEvents = [];\n    };\n    return RegistrationEnforcer;\n}());\nexports.RegistrationEnforcer = RegistrationEnforcer;\n/**\n * Wrapper for debugging and tests, can be used to compare\n * the original and filtered events, by creating e.g.\n * ```\n * new LoggingManagerConsumer(\n *   new RegistrationEnforcer(\n *     new LoggingManagerConsumer(this, 'inner'),\n *     true\n *   ),\n * 'outer')\n * ```\n * where the outer one will log all the calls from TrouterConnection,\n * and the inner one will only log the calls that go through (with the\n * resulting order/delay/etc.)\n */\nvar LoggingManagerConsumer = /** @class */ (function () {\n    function LoggingManagerConsumer(wrapped, prefix, logger, onEventAction) {\n        this.wrapped = wrapped;\n        this.prefix = prefix;\n        this.logger = logger;\n        this.onEventAction = onEventAction;\n    }\n    LoggingManagerConsumer.prototype.onEvent = function (name, jsonArgs) {\n        var _a;\n        if (this.onEventAction !== undefined) {\n            this.onEventAction(name, jsonArgs);\n        }\n        else {\n            ((_a = this.logger) !== null && _a !== void 0 ? _a : console).log(\"\".concat(this.prefix, \" TracingEnforcer: \").concat(name, \"(\").concat(jsonArgs, \")\"));\n        }\n    };\n    LoggingManagerConsumer.prototype.onDownstreamRequest = function (connection, request, response) {\n        this.onEvent('onDownstreamRequest', JSON.stringify({ request: request, response: response }));\n        this.wrapped.onDownstreamRequest(connection, request, response);\n    };\n    LoggingManagerConsumer.prototype.onConnected = function (connection) {\n        this.onEvent('onConnected', connection.getState().toString());\n        this.wrapped.onConnected(connection);\n    };\n    LoggingManagerConsumer.prototype.onRegistered = function (connection) {\n        this.onEvent('onRegistered', connection.getState().toString());\n        this.wrapped.onRegistered(connection);\n    };\n    LoggingManagerConsumer.prototype.onUnregistered = function (connection) {\n        this.onEvent('onUnregistered', connection.getState().toString());\n        this.wrapped.onUnregistered(connection);\n    };\n    LoggingManagerConsumer.prototype.onReconnecting = function (connection) {\n        this.onEvent('onReconnecting', connection.getState().toString());\n        this.wrapped.onReconnecting(connection);\n    };\n    LoggingManagerConsumer.prototype.onReconnectIsRequired = function (connection, useConnectParamsFromCache, reason) {\n        this.onEvent('onReconnectIsRequired', JSON.stringify({ connection: connection.getState().toString(), useConnectParamsFromCache: useConnectParamsFromCache, reason: reason }));\n        this.wrapped.onReconnectIsRequired(connection, useConnectParamsFromCache, reason);\n    };\n    LoggingManagerConsumer.prototype.onDisconnected = function (connection) {\n        this.onEvent('onDisconnected', connection.getState().toString());\n        this.wrapped.onDisconnected(connection);\n    };\n    LoggingManagerConsumer.prototype.onTerminalError = function (connection) {\n        this.onEvent('onTerminalError', JSON.stringify({ connection: connection }));\n        this.wrapped.onTerminalError(connection);\n    };\n    LoggingManagerConsumer.prototype.onConnectionParametersUpdated = function (connectParams) {\n        this.onEvent('onConnectionParametersUpdated', JSON.stringify({ connectParams: connectParams }));\n        this.wrapped.onConnectionParametersUpdated(connectParams);\n    };\n    LoggingManagerConsumer.prototype.onTrouterMessageLost = function (flowTags) {\n        this.onEvent('onTrouterMessageLost', JSON.stringify({ flowTags: flowTags }));\n        this.wrapped.onTrouterMessageLost(flowTags);\n    };\n    LoggingManagerConsumer.prototype.onUserActivityStateAccepted = function (cv) {\n        this.onEvent('onUserActivityStateAccepted', JSON.stringify({ cv: cv }));\n        this.wrapped.onUserActivityStateAccepted(cv);\n    };\n    LoggingManagerConsumer.prototype.onAudiencesSetResolved = function (audienceSubscriptionsResponse, cv) {\n        this.onEvent('onAudiencesSetResolved', JSON.stringify({ audienceSubscriptionsResponse: audienceSubscriptionsResponse, cv: cv }));\n        this.wrapped.onAudiencesSetResolved(audienceSubscriptionsResponse, cv);\n    };\n    LoggingManagerConsumer.prototype.getState = function () {\n        return this.wrapped.getState();\n    };\n    return LoggingManagerConsumer;\n}());\nexports.LoggingManagerConsumer = LoggingManagerConsumer;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrouterManagerFsm = void 0;\nvar Interfaces_1 = __webpack_require__(2);\nvar InternalInterfaces_1 = __webpack_require__(4);\nvar Logger_1 = __webpack_require__(0);\nvar TrouterConnection_1 = __webpack_require__(7);\n/**\n * State machine for manager\n */\nvar TrouterManagerFsm = /** @class */ (function () {\n    function TrouterManagerFsm(logFunc, worker) {\n        this.worker = worker;\n        this.state = InternalInterfaces_1.TrouterManagerState.Unknown;\n        this.logger = new Logger_1.Logger('ManagerFsm', logFunc);\n    }\n    TrouterManagerFsm.prototype.start = function () {\n        if (this.state === InternalInterfaces_1.TrouterManagerState.Unknown) {\n            this.setState(InternalInterfaces_1.TrouterManagerState.Disconnected);\n            this.worker.forceStopLingeringConnection();\n            this.worker.startFirstConnection();\n        }\n        else {\n            // Trouter is already running, but external code calling start()\n            // is often triggered by some relevant external event (e.g. computer waking up),\n            // so we want to retry immediately to not create unnecessary delays.\n            this.logger.info(\"start called in state '\".concat(InternalInterfaces_1.TrouterManagerState[this.state], \"', expediting pending backoffs, if any\"));\n            this.worker.expediteBackoffOnConnections();\n        }\n    };\n    TrouterManagerFsm.prototype.stop = function (dontUnregister) {\n        if (this.state !== InternalInterfaces_1.TrouterManagerState.Unknown) {\n            this.setState(InternalInterfaces_1.TrouterManagerState.Unknown);\n            this.worker.stopFirstConnection(dontUnregister === true);\n            this.worker.stopSecondConnection(dontUnregister === true);\n        }\n        else {\n            this.showIgnored('stop');\n        }\n    };\n    /** Returns current state */\n    TrouterManagerFsm.prototype.getState = function () {\n        switch (this.state) {\n            case InternalInterfaces_1.TrouterManagerState.Unknown:\n            case InternalInterfaces_1.TrouterManagerState.Connected:\n            case InternalInterfaces_1.TrouterManagerState.Disconnected:\n            case InternalInterfaces_1.TrouterManagerState.Switching:\n                return this.state;\n            case InternalInterfaces_1.TrouterManagerState.TerminalError:\n                return Interfaces_1.TrouterState.Disconnected;\n        }\n    };\n    TrouterManagerFsm.prototype.getInternalState = function () {\n        return this.state;\n    };\n    TrouterManagerFsm.prototype.onConnected = function (first) {\n        if (this.state === InternalInterfaces_1.TrouterManagerState.Disconnected && first) {\n            if (this.worker.doesSecondConnectionExist()) {\n                this.setState(InternalInterfaces_1.TrouterManagerState.Switching);\n            }\n            else {\n                this.setState(InternalInterfaces_1.TrouterManagerState.Connected);\n                this.worker.dispatchConnected();\n            }\n        }\n        else {\n            this.showIgnored(\"onConnected(\".concat(first, \")\"));\n        }\n    };\n    TrouterManagerFsm.prototype.onRegistered = function (first) {\n        if (this.state === InternalInterfaces_1.TrouterManagerState.Disconnected && !first) {\n            this.setState(InternalInterfaces_1.TrouterManagerState.Connected);\n            this.worker.switchConnections();\n            this.worker.stopSecondConnection(true);\n            this.worker.dispatchConnected();\n        }\n        else if (this.state === InternalInterfaces_1.TrouterManagerState.Switching && !first) {\n            this.setState(InternalInterfaces_1.TrouterManagerState.Connected);\n            this.worker.switchConnections();\n            this.worker.stopSecondConnectionDelayed();\n            this.worker.dispatchConnected();\n        }\n        else if (this.state === InternalInterfaces_1.TrouterManagerState.Disconnected && first) {\n            // happens when reconnect prompts connection to the same instance which dispatches disconnect as duplicate (both on old connection)\n            // at this point `first` is the new connection\n            this.setState(InternalInterfaces_1.TrouterManagerState.Connected);\n            this.worker.dispatchConnected();\n        }\n        this.worker.dispatchRegistrationState(true);\n    };\n    TrouterManagerFsm.prototype.onUnregistered = function (first) {\n        if (first) {\n            this.worker.dispatchRegistrationState(false);\n        }\n    };\n    TrouterManagerFsm.prototype.onReconnecting = function (first) {\n        if ((this.state === InternalInterfaces_1.TrouterManagerState.Connected || this.state === InternalInterfaces_1.TrouterManagerState.Switching) && first) {\n            this.setState(InternalInterfaces_1.TrouterManagerState.Disconnected);\n            this.worker.dispatchDisconnected();\n        }\n        else {\n            this.showIgnored(\"onReconnecting(\".concat(first, \")\"));\n        }\n    };\n    TrouterManagerFsm.prototype.onReconnectionRequired = function (first, useConnectParamsFromCache, reason) {\n        if (this.state === InternalInterfaces_1.TrouterManagerState.Connected && first) {\n            this.setState(InternalInterfaces_1.TrouterManagerState.Switching);\n            this.worker.startSecondConnection(useConnectParamsFromCache);\n        }\n        else if (this.state === InternalInterfaces_1.TrouterManagerState.Disconnected && first) {\n            this.worker.startSecondConnection(useConnectParamsFromCache);\n        }\n        else if (this.state === InternalInterfaces_1.TrouterManagerState.Switching && first && reason === TrouterConnection_1.ReconnectReason.Configuration) {\n            // Intentionally ignoring `trouter.reconnect` events arriving during an in-progress switch (on either connection),\n            // only configuration change is handled. This matches the current behavior of the C++ client.\n            // Even in the ignored cases, the client should still end up being connected to the right environment eventually.\n            this.logger.debug('onReconnectionRequired: switch requested while already in Switching state');\n            this.worker.stopSecondConnection(true);\n            this.worker.startSecondConnection(useConnectParamsFromCache);\n        }\n        else {\n            this.showIgnored(\"onReconnectionRequired(\".concat(first, \")\"));\n        }\n    };\n    TrouterManagerFsm.prototype.onDisconnected = function (first) {\n        if (this.state == InternalInterfaces_1.TrouterManagerState.Unknown && first) {\n            // This is executed after an explicit stop()\n            this.worker.dispatchDisconnected();\n        }\n        else if (this.state == InternalInterfaces_1.TrouterManagerState.Switching && first) {\n            // The current/old connection got disconnected during a connection switch\n            // (the disconnect would result only in onReconnecting() at other times,\n            // when automatic reconnects are still enabled)\n            this.worker.switchConnections();\n            this.worker.stopSecondConnection(false);\n            this.setState(InternalInterfaces_1.TrouterManagerState.Disconnected);\n            this.worker.dispatchDisconnected();\n        }\n        else {\n            this.showIgnored(\"onDisconnected(\".concat(first, \")\"));\n        }\n    };\n    TrouterManagerFsm.prototype.onTerminalError = function () {\n        this.setState(InternalInterfaces_1.TrouterManagerState.TerminalError);\n        this.worker.dispatchTerminalError();\n    };\n    TrouterManagerFsm.prototype.showIgnored = function (event) {\n        this.logger.info(\"Ignoring event '\".concat(event, \"' in state '\").concat(InternalInterfaces_1.TrouterManagerState[this.state], \"'\"));\n    };\n    TrouterManagerFsm.prototype.setState = function (state) {\n        this.logger.info(\"Switching from state '\".concat(InternalInterfaces_1.TrouterManagerState[this.state], \"' to state '\").concat(InternalInterfaces_1.TrouterManagerState[state], \"'\"));\n        if (this.state === state) {\n            this.logger.error(\"Attempt to switch to the current state '\".concat(InternalInterfaces_1.TrouterManagerState[state], \"'\"));\n            return;\n        }\n        this.state = state;\n    };\n    return TrouterManagerFsm;\n}());\nexports.TrouterManagerFsm = TrouterManagerFsm;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft. All rights reserved.\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.replaceTrouterUrlBase = exports.getTrouterServiceVersion = exports.createTrouterService = exports.TrouterService = exports.UserActivityState = exports.TrouterState = void 0;\nvar Constants_1 = __webpack_require__(1);\nvar Interfaces_1 = __webpack_require__(2);\nObject.defineProperty(exports, \"TrouterState\", { enumerable: true, get: function () { return Interfaces_1.TrouterState; } });\nObject.defineProperty(exports, \"UserActivityState\", { enumerable: true, get: function () { return Interfaces_1.UserActivityState; } });\nvar Logger_1 = __webpack_require__(0);\nvar MessageHandler_1 = __webpack_require__(8);\nvar SkypeTokenProviderWithCache_1 = __webpack_require__(9);\nvar TrouterManager_1 = __webpack_require__(10);\nvar TrouterUrlPromise_1 = __webpack_require__(11);\nfunction populateTelemetryOptions(startingCfg, ecsCfg) {\n    if (!ecsCfg) {\n        return startingCfg;\n    }\n    var res = __assign(__assign({}, startingCfg), {\n        enabled: ecsCfg.TelemetryEnabled\n    });\n    if (ecsCfg.ClientTelemetryEventEnabled !== undefined) {\n        res = __assign(__assign({}, res), ecsCfg.ClientTelemetryEventEnabled);\n    }\n    return res;\n}\nfunction populateTrouterOptions(cfg, logger, ecsCfg) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    var rewriteUrlForProxyCallback = function (url) {\n        if (cfg.proxyUrlRewrite) {\n            logger.info('Using rewritten URL for proxy');\n            return cfg.proxyUrlRewrite(url);\n        }\n        else {\n            return url;\n        }\n    };\n    return {\n        clientInfo: {\n            ua: cfg.trouterSettings.productName,\n            v: cfg.trouterSettings.version\n        },\n        ioOptions: {\n            // uncomment for manual testing\n            // transports: ['xhr-polling'],\n            // 'connect timeout': XXX, 10000 by default in socket.io code\n            ackTimeoutMs: 5000,\n            rewriteUrlForProxy: rewriteUrlForProxyCallback\n        },\n        clientCorrelationID: cfg.trouterSettings.sessionId,\n        environment: cfg.trouterSettings.environment,\n        telemetrySettings: populateTelemetryOptions(cfg.telemetryConfig.settings, ecsCfg),\n        eventLogger: cfg.telemetryConfig.eventLogger,\n        endpointId: cfg.trouterSettings.registrationId,\n        // keeping existing behavior of || - using default value when there's empty string\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        trouterUrl: (ecsCfg === null || ecsCfg === void 0 ? void 0 : ecsCfg.TrouterConnectionUrl) || cfg.trouterSettings.trouterServiceUrl,\n        registration: cfg.trouterSettings.registrarServiceUrl\n            ? {\n                registrarUrl: cfg.trouterSettings.registrarServiceUrl,\n                registrationId: (_a = cfg.trouterSettings.registrationId) !== null && _a !== void 0 ? _a : '',\n                pnhAppId: (_b = cfg.trouterSettings.pnhAppId) !== null && _b !== void 0 ? _b : '',\n                platform: (_c = cfg.trouterSettings.platform) !== null && _c !== void 0 ? _c : '',\n                pnhTemplateKey: (_d = cfg.trouterSettings.pnhTemplate) !== null && _d !== void 0 ? _d : '',\n                platformUIVersion: (_e = cfg.trouterSettings.platformUIVersion) !== null && _e !== void 0 ? _e : '',\n                // keeping existing behavior of || - using default value when there's empty string\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                productContext: cfg.trouterSettings.pnhProductContext || undefined,\n                context: (_f = cfg.trouterSettings.pnhContext) !== null && _f !== void 0 ? _f : '',\n                registrarTtlSec: ((_g = cfg.trouterSettings.maxRegistrationTimeInMs) !== null && _g !== void 0 ? _g : 0) / 1000\n            }\n            : undefined,\n        connectionDependsOnRegistration: cfg.trouterSettings.registrarServiceUrl === undefined ?\n            (function () { return false; }) :\n            ((_h = cfg.trouterSettings.connectionDependsOnRegistration) !== null && _h !== void 0 ? _h : (function () { return false; })),\n        delayEventsUntilRegistered: (_j = cfg.trouterSettings.delayEventsUntilRegistered) !== null && _j !== void 0 ? _j : (function () { return false; }),\n        timeoutOptions: __assign({ \n            // keeping existing behavior of || - using default value when there's 0\n            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n            connectionTimeoutMs: cfg.trouterSettings.trouterConnectTimeoutInMs || 30000, fetchTimeoutMs: 10000, pingTimeoutMs: 40000, pongTimeoutMs: 5000, \n            /** Followup WI to remove hardcoded value: https://domoreexp.visualstudio.com/MSTeams/_workitems/edit/2307271 */\n            maxBackoffMs: cfg.trouterSettings.productName === 'TeamsCDL' ? 300000 : 30000, requestTimeoutMs: 5000, userActivityResponseTimeoutMs: 10000 }, cfg.trouterSettings.timeoutOptions),\n        incallTimeoutOptions: __assign({ connectionTimeoutMs: 10000, fetchTimeoutMs: 5000, pingTimeoutMs: 5000, pongTimeoutMs: 2000, maxBackoffMs: cfg.trouterSettings.productName === 'TeamsCDL' ? 300000 : 10000, requestTimeoutMs: 5000, userActivityResponseTimeoutMs: 10000 }, cfg.trouterSettings.incallTimeoutOptions),\n        incallModeTimeoutMs: (_k = cfg.trouterSettings.incallModeTimeoutMs) !== null && _k !== void 0 ? _k : 0,\n        lingeringConnectionDelayMs: 60000,\n        // keeping existing behavior of || - using default value when there's 0\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        userActivitySecondResendDelayMs: cfg.trouterSettings.userActivitySecondResendDelayMs || 10000,\n        duplicateDisconnectThresholdMs: 10000,\n        connectionCache: cfg.connectionCache,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        registrationStateCallback: cfg.registrationStateCallbackForAcsDoNotUse,\n        rewriteUrlForProxy: rewriteUrlForProxyCallback,\n        retryLimitOnTokenFetch: cfg.trouterSettings.retryLimitOnTokenFetch,\n        extraConnectionHeaders: cfg.trouterSettings.extraConnectionHeaders,\n        expediteBackoffOnStartMinimumDelayMs: 10000,\n        // JSON.stringify() override for dumping options to log as JSON in TrouterManager\n        toJSON: function () {\n            return __assign(__assign({}, this), { \n                // If cache is set to some object of the host app, do not try to serialize it.\n                // It could contain circular references and JSON.stringify() would fully fail.\n                connectionCache: this.connectionCache ? {} : this.connectionCache });\n        }\n    };\n}\n/**\n * TrouterService implementation class\n */\nvar TrouterService = /** @class */ (function () {\n    function TrouterService(logProvider) {\n        this.logProvider = logProvider;\n        this.stateChangedListeners = [];\n        this.logger = new Logger_1.Logger('Trouter', logProvider);\n        this.trouterUrlPromise = new TrouterUrlPromise_1.TrouterUrlPromise(logProvider);\n        this.messageHandlers = new MessageHandler_1.MessageHandlerRegistry(logProvider);\n        this.listeners = {};\n        this.connectionInfo = null;\n        this.logger.info(\"Created TrouterService version \".concat(Constants_1.CLIENT_VERSION));\n    }\n    TrouterService.prototype.start = function (cfg) {\n        var _a;\n        this.logger.info('Start');\n        if (!cfg.skypeTokenProvider && !cfg.authTokenProvider) {\n            throw new Error('no token provider has been configured, either skypeTokenProvider or authTokenProvider must be populated');\n        }\n        if (cfg.skypeTokenProvider && !cfg.trouterSettings.disableInternalSkypeTokenCache) {\n            cfg.skypeTokenProvider = (0, SkypeTokenProviderWithCache_1.addCacheAsBackupTo)(cfg.skypeTokenProvider);\n        }\n        this.trouterCfg = cfg;\n        var options = populateTrouterOptions(cfg, this.logger, this.ecsCfg);\n        if (cfg.internalEnableV4cProtocol === false) {\n            options.forceV4aProtocol = true;\n        }\n        var authTokenProvider = authTokenProviderProtector(this.logger, (_a = cfg.authTokenProvider) !== null && _a !== void 0 ? _a : skypeTokenAdapter(cfg.skypeTokenProvider));\n        if (this.trouterServer === undefined) {\n            this.trouterServer = new TrouterManager_1.TrouterManager(this.logProvider, options, authTokenProvider, cfg.authTokenProvider === undefined, this);\n        }\n        if (this.pendingActivityState !== undefined) {\n            this.trouterServer.setUserActivityState(this.pendingActivityState[0], this.pendingActivityState[1]);\n            this.pendingActivityState = undefined;\n        }\n        this.trouterServer.start();\n    };\n    TrouterService.prototype.stop = function (dontUnregister) {\n        this.logger.info('close connection');\n        this.trouterUrlPromise.rejectUrl(new Error('TrouterService is stopped'));\n        if (this.trouterServer !== undefined) {\n            this.trouterServer.stop(dontUnregister);\n        }\n    };\n    TrouterService.prototype.setEcsConfig = function (fullEcsData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(function (resolve) {\n                        var ecsSection = 'TrouterJScriptClient';\n                        _this.ecsCfg = (fullEcsData[ecsSection]);\n                        _this.logger.info(\"Setting ECS configuration to \".concat(JSON.stringify(_this.ecsCfg)));\n                        if (_this.trouterServer !== undefined && _this.trouterCfg !== undefined) {\n                            var options = populateTrouterOptions(_this.trouterCfg, _this.logger, _this.ecsCfg);\n                            _this.trouterServer.configure(options);\n                        }\n                        resolve();\n                    })];\n            });\n        });\n    };\n    /**\n     * Notifies trouter that network is restored - trouter will try to restore connection immediately\n     */\n    TrouterService.prototype.checkConnection = function (disconnectDetected) {\n        if (this.trouterServer !== undefined) {\n            this.trouterServer.checkConnection(disconnectDetected !== null && disconnectDetected !== void 0 ? disconnectDetected : false);\n        }\n    };\n    TrouterService.prototype.resendRegistration = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!this.trouterServer) {\n                    throw new Error('resendRegistration called too early');\n                }\n                return [2 /*return*/, this.trouterServer.resendRegistration()];\n            });\n        });\n    };\n    // Listeners\n    TrouterService.prototype.registerListener = function (listener, path) {\n        if (path === '' || !path.startsWith('/') || path.includes('?') || path.includes('#')) {\n            this.logger.error(\"Listener path '\".concat(path, \"' is not valid\"));\n            return false;\n        }\n        if (this.listeners[path]) {\n            this.logger.error(\"Another listener is already registered for path '\".concat(path, \"'\"));\n            return false;\n        }\n        this.listeners[path] = listener;\n        this.logger.debug(\"Listener for path '\".concat(path, \"' registered\"));\n        if (this.connectionInfo) {\n            listener.onTrouterConnected(this.connectionInfo.baseEndpointUrl + path, this.connectionInfo);\n        }\n        return true;\n    };\n    TrouterService.prototype.unregisterListener = function (listener) {\n        var paths = [];\n        for (var _i = 0, _a = Object.keys(this.listeners); _i < _a.length; _i++) {\n            var path = _a[_i];\n            if (this.listeners[path] === listener) {\n                paths.push(path);\n            }\n        }\n        if (paths.length === 0) {\n            return false;\n        }\n        for (var _b = 0, paths_1 = paths; _b < paths_1.length; _b++) {\n            var path = paths_1[_b];\n            delete this.listeners[path];\n        }\n        this.logger.debug(\"Listener for path(s) '\".concat(paths.join('\\', \\''), \"' unregistered\"));\n        return true;\n    };\n    TrouterService.prototype.onTrouterConnected = function (endpointUrl, connectionInfo) {\n        this.logger.debug('Trouter is now connected');\n        for (var _i = 0, _a = Object.keys(this.listeners); _i < _a.length; _i++) {\n            var path = _a[_i];\n            try {\n                this.listeners[path].onTrouterConnected(connectionInfo.baseEndpointUrl + path, connectionInfo);\n            }\n            catch (e) {\n                this.logger.error(\"Listener '\".concat(path, \"' threw an exception from onTrouterConnected(): \").concat(e));\n            }\n        }\n        this.connectionInfo = connectionInfo;\n        this.trouterUrlPromise.resolveUrl(endpointUrl);\n        this.notifyStateChanged(Interfaces_1.TrouterState.Connected, {\n            url: endpointUrl,\n            getRemainingTtlInSec: function () { return connectionInfo.connectionTtlSec; }\n        });\n    };\n    TrouterService.prototype.onTrouterDisconnected = function () {\n        this.logger.debug('Trouter is now disconnected');\n        this.connectionInfo = null;\n        for (var _i = 0, _a = Object.keys(this.listeners); _i < _a.length; _i++) {\n            var path = _a[_i];\n            var listener = this.listeners[path];\n            if (listener.onTrouterDisconnected) {\n                try {\n                    listener.onTrouterDisconnected();\n                }\n                catch (e) {\n                    this.logger.error(\"Listener '\".concat(path, \"' threw an exception from onTrouterDisconnected(): \").concat(e));\n                }\n            }\n        }\n        this.notifyStateChanged(Interfaces_1.TrouterState.Disconnected);\n    };\n    TrouterService.prototype.onTrouterRequest = function (request, response) {\n        var bestPath = '';\n        for (var _i = 0, _a = Object.keys(this.listeners); _i < _a.length; _i++) {\n            var path = _a[_i];\n            if (request.path.startsWith(path) && path.length > bestPath.length) {\n                bestPath = path;\n            }\n        }\n        if (bestPath !== '') {\n            try {\n                this.listeners[bestPath].onTrouterRequest(request, response);\n            }\n            catch (e) {\n                this.logger.error(\"Listener '\".concat(bestPath, \"' threw an exception from onTrouterRequest(): \").concat(e));\n                response.status = 500;\n                response.headers = { 'Trouter-Responder': 'ClientLib' };\n                response.send();\n            }\n            return;\n        }\n        if (this.tryMessageHandlers(request, response)) {\n            return;\n        }\n        response.status = 404;\n        response.headers = { 'Trouter-Responder': 'ClientLib' };\n        response.send();\n    };\n    TrouterService.prototype.onTrouterMessageLoss = function (flowTags) {\n        this.logger.info(\"onTrouterMessageLoss called with tags [\".concat(flowTags, \"]\"));\n        var messageLossProcessed = true;\n        for (var _i = 0, _a = Object.keys(this.listeners); _i < _a.length; _i++) {\n            var path = _a[_i];\n            var listener = this.listeners[path];\n            if (listener.onTrouterMessageLoss) {\n                try {\n                    messageLossProcessed = listener.onTrouterMessageLoss(flowTags) && messageLossProcessed;\n                    if (messageLossProcessed === undefined) {\n                        this.logger.error(\"Listener '\".concat(path, \"' did not return a boolean value from onTrouterMessageLoss()\"));\n                        messageLossProcessed = false;\n                    }\n                }\n                catch (e) {\n                    this.logger.error(\"Listener '\".concat(path, \"' threw an exception from onTrouterMessageLoss(): \").concat(e));\n                    messageLossProcessed = false;\n                }\n            }\n        }\n        return messageLossProcessed;\n    };\n    TrouterService.prototype.onTrouterUserActivityStateAccepted = function (cv) {\n        this.logger.debug(\"onTrouterUserActivityStateAccepted cv: \".concat(cv));\n        for (var _i = 0, _a = Object.keys(this.listeners); _i < _a.length; _i++) {\n            var path = _a[_i];\n            var listener = this.listeners[path];\n            if (listener.onTrouterUserActivityStateAccepted) {\n                try {\n                    listener.onTrouterUserActivityStateAccepted(cv);\n                }\n                catch (e) {\n                    this.logger.error(\"Listener '\".concat(path, \"' threw an exception from onTrouterUserActivityStateAccepted(): \").concat(e));\n                }\n            }\n        }\n    };\n    TrouterService.prototype.onAudiencesSetResolved = function (audienceSubscriptionsResponse, cv) {\n        this.logger.debug(\"onAudiencesSetResolved cv: \".concat(cv));\n        for (var _i = 0, _a = Object.keys(this.listeners); _i < _a.length; _i++) {\n            var path = _a[_i];\n            var listener = this.listeners[path];\n            if (listener.onAudiencesSetResolved) {\n                try {\n                    listener.onAudiencesSetResolved(audienceSubscriptionsResponse, cv);\n                }\n                catch (e) {\n                    this.logger.error(\"Listener '\".concat(path, \"' threw an exception from onAudienceSubscribed(): \").concat(e));\n                }\n            }\n        }\n    };\n    TrouterService.prototype.setUserActivityState = function (state, correlationVector) {\n        if (state !== Interfaces_1.UserActivityState.Active && state !== Interfaces_1.UserActivityState.Inactive) {\n            throw new Error(\"setUserActivityState called with unsupported value \".concat(state));\n        }\n        this.logger.info(\"setUserActivityState called with value \".concat(Interfaces_1.UserActivityState[state]));\n        if (this.trouterServer && this.state() !== Interfaces_1.TrouterState.Unknown) {\n            this.trouterServer.setUserActivityState(state, correlationVector);\n        }\n        else {\n            this.pendingActivityState = [state, correlationVector];\n            this.logger.warn('setUserActivityState called before start() or after stop()');\n        }\n    };\n    TrouterService.prototype.setAudienceSubscriptions = function (audienceSubscriptionModel, correlationVector) {\n        if (audienceSubscriptionModel.audienceSubscriptions.length > 1) {\n            throw new Error(\"Only singular audience subscription is supported\");\n        }\n        if (this.trouterServer && this.state() !== Interfaces_1.TrouterState.Unknown) {\n            return this.trouterServer.setAudienceSubscriptionsAsync(audienceSubscriptionModel, 15000, correlationVector);\n        }\n        throw new Error('audience subscribe called before start() or after stop()');\n    };\n    // Legacy API\n    TrouterService.prototype.state = function () {\n        if (this.trouterServer !== undefined) {\n            return this.trouterServer.getState();\n        }\n        return Interfaces_1.TrouterState.Unknown;\n    };\n    TrouterService.prototype.isInTerminalState = function () {\n        if (this.trouterServer !== undefined) {\n            return this.trouterServer.isInTerminalState();\n        }\n        return false;\n    };\n    TrouterService.prototype.reportStateInfo = function () {\n        if (this.trouterServer === undefined) {\n            return \"\";\n        }\n        return this.trouterServer.reportStateInfo();\n    };\n    TrouterService.prototype.getServerState = function () {\n        if (this.trouterServer !== undefined) {\n            return this.trouterServer.getServerState();\n        }\n        return undefined;\n    };\n    TrouterService.prototype.getTrouterUrlAsync = function () {\n        if (this.trouterServer !== undefined) {\n            return this.trouterUrlPromise.getPromise();\n        }\n        else {\n            return Promise.reject(new Error('TrouterService has not been started'));\n        }\n    };\n    TrouterService.prototype.onStateChanged = function (callback) {\n        this.logger.info('onStateChanged called');\n        if (callback === undefined) {\n            this.stateChangedListeners = this.stateChangedListeners.filter(function (listener) { return (listener.wrappedCallback === undefined); });\n        }\n        else {\n            this.offStateChanged(callback);\n            var wrapper = function (state, info) {\n                callback(state, info ? info.url : '');\n            };\n            wrapper.wrappedCallback = callback;\n            this.stateChangedListeners.push(wrapper);\n        }\n    };\n    TrouterService.prototype.offStateChanged = function (callback) {\n        this.logger.info('offStateChanged called');\n        var sizeBeforeRemoval = this.stateChangedListeners.length;\n        this.stateChangedListeners = this.stateChangedListeners.filter(function (listener) { return (listener.wrappedCallback !== callback); });\n        return (sizeBeforeRemoval > this.stateChangedListeners.length);\n    };\n    TrouterService.prototype.addCallback = function (callback) {\n        this.logger.info('addListener called');\n        var index = this.stateChangedListeners.indexOf(callback, 0);\n        if (index === -1 && callback !== undefined) {\n            this.stateChangedListeners.push(callback);\n        }\n    };\n    TrouterService.prototype.removeCallback = function (callback) {\n        this.logger.info('removeListener called');\n        var index = this.stateChangedListeners.indexOf(callback, 0);\n        if (index > -1) {\n            this.stateChangedListeners.splice(index, 1);\n            return true;\n        }\n        return false;\n    };\n    TrouterService.prototype.registerMessageHandler = function (handler) {\n        this.logger.info('registerMessageHandler is called');\n        this.messageHandlers.register(handler);\n    };\n    TrouterService.prototype.clearMessageHandlers = function () {\n        this.logger.info('clearMessageHandlers is called');\n        this.messageHandlers.clear();\n    };\n    TrouterService.prototype.notifyStateChanged = function (state, info) {\n        var _this = this;\n        this.logger.info(\"notifyStateChanged called, will forward to \".concat(this.stateChangedListeners.length, \" listeners\"));\n        this.stateChangedListeners.forEach(function (callback) {\n            try {\n                callback(state, info);\n            }\n            catch (error) {\n                _this.logger.error(\"Error in callback \".concat(error));\n            }\n        });\n    };\n    TrouterService.prototype.tryMessageHandlers = function (request, response) {\n        if (!this.messageHandlers.active()) {\n            return false;\n        }\n        var body;\n        var eventId = null;\n        try {\n            body = JSON.parse(request.body);\n            eventId = (body && (body.evt || body.eventId)) || null;\n            // eslint-disable-next-line no-empty\n        }\n        catch (e) { }\n        var message = {\n            eventId: eventId,\n            url: (this.connectionInfo ? this.connectionInfo.baseEndpointUrl : '') + request.path,\n            body: body,\n            rawBody: request.body,\n            headers: request.headers\n        };\n        var result = this.messageHandlers.handleMessage(message);\n        if (!result.isHandled) {\n            return false;\n        }\n        response.status = result.resultCode;\n        if (result.responseHeaders) {\n            response.headers = result.responseHeaders;\n        }\n        if (result.responseBody) {\n            response.body = result.responseBody;\n        }\n        response.send();\n        return true;\n    };\n    return TrouterService;\n}());\nexports.TrouterService = TrouterService;\nfunction createTrouterService(logger) {\n    return new TrouterService(logger);\n}\nexports.createTrouterService = createTrouterService;\nfunction getTrouterServiceVersion() {\n    return Constants_1.CLIENT_VERSION;\n}\nexports.getTrouterServiceVersion = getTrouterServiceVersion;\nfunction replaceTrouterUrlBase(existingUrl, newBase) {\n    var schemaSepPos = existingUrl.indexOf('://');\n    if (schemaSepPos >= 0) {\n        var pathSepPos = existingUrl.indexOf('/', schemaSepPos + 3);\n        if (pathSepPos >= 0) {\n            return newBase + existingUrl.substr(pathSepPos);\n        }\n    }\n    return '';\n}\nexports.replaceTrouterUrlBase = replaceTrouterUrlBase;\nfunction skypeTokenAdapter(provider) {\n    var _this = this;\n    return function (req) { return __awaiter(_this, void 0, void 0, function () {\n        var _a;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _a = {};\n                    return [4 /*yield*/, provider(req.needFresh)];\n                case 1: return [2 /*return*/, (_a.token = _b.sent(), _a.tokenType = 'skype', _a)];\n            }\n        });\n    }); };\n}\nfunction authTokenProviderProtector(logger, provider) {\n    var _this = this;\n    var previousToken;\n    return function (req) { return __awaiter(_this, void 0, void 0, function () {\n        var requestTime, timerId, rsp;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    requestTime = new Date();\n                    timerId = setInterval(function () {\n                        var delay = Math.round((Date.now() - requestTime.getTime()) / 60000);\n                        logger.warn(\"Note: Trouter auth token request promise from \".concat(requestTime.toISOString(), \" has not been resolved for \").concat(delay, \" minutes. The client is blocked from operating properly\"));\n                    }, 5 * 60000);\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, , 3, 4]);\n                    return [4 /*yield*/, provider(req)];\n                case 2:\n                    rsp = _a.sent();\n                    if (req.needFresh && rsp.token === previousToken) {\n                        logger.error('API violation: Trouter auth token provider got a request with needRefresh=true, but returned the same token as last time anyway. Please fix the host app');\n                    }\n                    previousToken = rsp.token;\n                    return [2 /*return*/, rsp];\n                case 3:\n                    clearInterval(timerId);\n                    return [7 /*endfinally*/];\n                case 4: return [2 /*return*/];\n            }\n        });\n    }); };\n}\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_21__;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// tstrouter.js","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { LogProvider } from './Interfaces';\r\n\r\n/**\r\n * Logging function\r\n */\r\nexport type LogFunc = (msg: string) => void;\r\n\r\n/**\r\n * Simple logger\r\n */\r\nexport class Logger {\r\n    public constructor(private name: string, private logger: LogProvider) { }\r\n\r\n    public debug(message: string) {\r\n        this.logger.debug(`[${this.name}] ${message}`);\r\n    }\r\n    public info(message: string) {\r\n        this.logger.info(`[${this.name}] ${message}`);\r\n    }\r\n    public warn(message: string) {\r\n        this.logger.warn(`[${this.name}] ${message}`);\r\n    }\r\n    public error(message: string) {\r\n        this.logger.error(`[${this.name}] ${message}`);\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/Logger.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nexport const constants = {\r\n    TROUTER_INIT: 'trouterinit',\r\n    TROUTER_READY_EVENT: 'trouterReadyEvent',\r\n    TROUTER_READY_TIMEOUT: 'trouterReadyTimeout',\r\n    TROUTER_TOKEN_REQUEST: 'trouterTokenRequest',\r\n    TROUTER_TOKEN_GET_SUCCEEDED: 'trouterTokenGetSucceeded',\r\n    TROUTER_TOKEN_GET_FAILED: 'trouterTokenGetFailed',\r\n    TROUTER_RECONNECTING: 'trouterReconnecting',\r\n    RENEWAL: 'renewal',\r\n    NEW_CONNECTION: 'newConnection',\r\n    ENDPOINT_REGISTRATION_FAILED: 'endpointRegistrationFailed'\r\n};\r\n\r\nexport const CLIENT_VERSION: string = '2024.14.01.55';\r\nexport const HANDLED_MESSAGE_ACK = 200;\r\nexport const UNHANDLED_MESSAGE_ACK = 404;\r\nexport const FAILED_MESSAGE_ACK = 500;\r\nexport const SUPPORTED_TOKEN_TYPES = <const>['skype', 'aad', 'cae'];\r\nexport const USER_AUTHENTICATE_EVENT_NAME = 'user.authenticate';\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/Constants.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n * Type definitions for Trouter JavaScript Client 2024.14.01.55\r\n */\r\n\r\n/**\r\n * Trouter HTTP-like headers\r\n */\r\nexport type Headers = {\r\n    [name: string]: string;\r\n};\r\n\r\n/**\r\n * Trouter HTTP-like request (service -> Trouter -> app)\r\n *\r\n * Represents one incoming request received by Trouter Client. Its content is\r\n * mostly a verbatim copy of what was sent by the originating service to\r\n * Trouter Service.\r\n */\r\nexport interface Request {\r\n    readonly id: number;        /// Request/response ID, useful for\r\n                                /// logging/debugging/tracing purposes\r\n    readonly method: string;    /// HTTP method (GET, POST, ...)\r\n    readonly path: string;      /// HTTP path, including listener's prefix and\r\n                                /// any provided query parameters\r\n    readonly headers: Headers;  /// HTTP headers\r\n    readonly body: string;      /// HTTP body/content\r\n}\r\n\r\n/**\r\n * Possible return values of Response.send()\r\n */\r\nexport const enum SendResponseResult {\r\n    OK           = 0,  /// Response accepted, will be sent back to the service\r\n    Timeout      = 1,  /// Too late, 504 (Timeout) has been already sent back\r\n    Duplicate    = 2,  /// send() was called multiple times on one Response\r\n    Incomplete   = 3,  /// Mandatory parameters (status code) are not set\r\n    Disconnected = 4   /// Trouter connection dropped, cannot reply now\r\n}\r\n\r\n/**\r\n * Trouter HTTP-like response (app -> Trouter -> service)\r\n *\r\n * Represents one outgoing response to be sent by Trouter Client. Always set\r\n * the status code, add any extra headers or body, then call `send()`.\r\n */\r\nexport interface Response {\r\n    readonly id: number;  /// Request/response ID, useful for\r\n    /// logging/debugging/tracing purposes\r\n    status: number;       /// HTTP status code (200, 404, ...), mandatory\r\n    headers: Headers;     /// HTTP headers, optional\r\n    body: string;         /// HTTP body/content, optional\r\n\r\n    /**\r\n     * Send the response\r\n     *\r\n     * Trouter will add just a few of its own headers and otherwise forward the\r\n     * response to the originating service that had sent the request.\r\n     *\r\n     * A successful return value `OK` means only that the response message has\r\n     * been accepted and prepared for sending back. The actual transmission will\r\n     * happen asynchronously later and might still fail for various reasons.\r\n     *\r\n     * @return SendResponseResult.OK if successful, other code if not\r\n     */\r\n    send(): SendResponseResult;\r\n}\r\n\r\n/**\r\n * Information about the current Trouter connection\r\n *\r\n * Received in `Listener.onTrouterConnected()` every time the connection\r\n * parameters change.\r\n */\r\nexport interface ConnectionInfo {\r\n    readonly baseEndpointUrl: string;   /// Base URL used for routing messages\r\n                                        /// from services to this client\r\n                                        /// instance, i.e. not specific to\r\n                                        /// a particular listener\r\n    readonly newEndpointUrl: boolean;   /// Tells if this `baseEndpointUrl` is\r\n                                        /// different from the previous one and\r\n                                        /// therefore if any dependent service\r\n                                        /// registrations need to be updated to\r\n                                        /// know where to send data\r\n    readonly c2cUrlBase: string;        /// Base URL prefix used for routing\r\n                                        /// messages from clients to this client\r\n                                        /// - replace the URL base (protocol +\r\n                                        /// hostname) of `baseEndpointUrl` (or\r\n                                        /// another per-listener endpoint URL)\r\n                                        /// with this value to obtain the full\r\n                                        /// client-to-client URL\r\n    readonly clientId: string;          /// ID of this Trouter client, should\r\n                                        /// stay the same between reconnects\r\n    readonly connectionId: string;      /// ID of the current Trouter\r\n                                        /// connection, can change between\r\n                                        /// reconnects\r\n    readonly connectionTtlSec: number;  /// Expected lifetime of the current\r\n                                        /// connection (ID) in seconds, as\r\n                                        /// determined by Trouter Service\r\n}\r\n\r\n/**\r\n * Trouter listener\r\n *\r\n * Interface implemented by application to receive Trouter callbacks\r\n */\r\nexport interface Listener {\r\n    /**\r\n     * Called when Trouter connection is (re-)established\r\n     *\r\n     * This is important mostly because of the `endpointUrl` as the URL where\r\n     * messages are sent to by the originating service(s). Only after receiving\r\n     * this callback and learning the Endpoint URL can the application register\r\n     * the established channel for receiving messages.\r\n     *\r\n     * The Endpoint URL is intended for service-to-service communication, only\r\n     * whitelisted authenticated services can access it and initiate Trouter\r\n     * requests. Use `c2cUrlBase` from `connectionInfo` to obtain a similar URL\r\n     * for client-to-client communication - see also `replaceTrouterUrlBase()`.\r\n     *\r\n     * @param endpointUrl    A URL used for routing messages from services to\r\n     *                       this listener\r\n     * @param connectionInfo Additional Trouter connection information\r\n     */\r\n    onTrouterConnected(endpointUrl: string, connectionInfo: ConnectionInfo): void;\r\n\r\n    /**\r\n     * Called when Trouter connection drops\r\n     *\r\n     * No incoming requests can be received for now, no outgoing responses can\r\n     * be sent either. Trouter client will reconnect as soon as possible.\r\n     *\r\n     * This state is most commonly caused by some temporary network issues\r\n     * (switching from Wi-Fi to a wired network, bad signal etc.) or things\r\n     * like a sleep/resume transition on the device.\r\n     *\r\n     * @note This method does not need to be implemented.\r\n     */\r\n    onTrouterDisconnected?(): void;\r\n\r\n    /**\r\n     * Called when Trouter receives a request intended for this listener\r\n     *\r\n     * Application can inspect the contents of the incoming message by looking\r\n     * at `request`, then fill in the outgoing `reponse` and send it back by\r\n     * invoking its method `send()`.\r\n     *\r\n     * This can be done both synchronously when this method is called, or at a\r\n     * later time asynchronously from any other context, if the application\r\n     * stores the `response` object aside.\r\n     *\r\n     * In any case, a response ought to be sent to every received request. If\r\n     * it is not, Trouter client will send a 504 (Timeout) message itself after\r\n     * a configured time, but that will needlessly show up as an error on the\r\n     * service side, even if you have processed the message successfully.\r\n     *\r\n     * For most simple applications, just sending a response with 200 (OK) right\r\n     * away should be good enough.\r\n     *\r\n     * @param request  Incoming request object (read-only)\r\n     * @param response Outgoing response object (to be filled in and sent)\r\n     */\r\n    onTrouterRequest(request: Request, response: Response): void;\r\n\r\n    /**\r\n     * Called when some messages have been dropped on Trouter\r\n     *\r\n     * This can be called at any time by Trouter server\r\n     *\r\n     * Some of the examples of the message loss:\r\n     * The message loss might occur when client queues got full and messages are rejected\r\n     * The message to be delivered are already expired.\r\n     *\r\n     * @param flowTags String array of flows representing the type of messages being lost\r\n     *\r\n     * returns true in case that the flow tags has been processed and the information can be dropped\r\n     */\r\n    onTrouterMessageLoss?(flowTags: string[]): boolean;\r\n\r\n    /**\r\n     * Called when the user activity state has been delivered and accepted by the service\r\n     * The value of correlation vector will be extended,\r\n     * and so only the prefix passed in should be compared, if necessary.\r\n     *\r\n     * @param cv Correlation vector of user activity state update.\r\n     */\r\n    onTrouterUserActivityStateAccepted?(cv: string): void;\r\n\r\n    /**\r\n     * Called on automatic re-subscription of audiences after trouter connection failed and reconnected.\r\n     * \r\n     * @param audienceSubscriptionsResponse Server response containing result for individual audience subscription attempts.\r\n     * @param cv Correlation vector of the audience subscription operation.\r\n     */\r\n    onAudiencesSetResolved?(audienceSubscriptionsResponse: IAudienceSubscriptionsResponse, cv: string): void;\r\n}\r\n\r\n/**\r\n * States that a user can reach\r\n *\r\n * Use with the `setUserActivityState()` method.\r\n */\r\nexport enum UserActivityState {\r\n    Unknown  = 0,  /// Initial state\r\n    Active   = 1,  /// User is active according to the application\r\n    Inactive = 2   /// User is not active according to the application\r\n}\r\n\r\n/**\r\n * Trouter client\r\n *\r\n * Use to register and unregister your listeners. Calls are forwarded to the\r\n * underlying implementation, whatever that is on the current platform.\r\n */\r\nexport interface Client {\r\n    /**\r\n     * Register a listener\r\n     *\r\n     * The specified listener will now be notified about any Trouter events. An\r\n     * initial `onTrouterConnected()` callback will be received automatically\r\n     * right away if Trouter is already connected, so that the listener can\r\n     * learn the Endpoint URL etc.\r\n     *\r\n     * There can be only one listener registered for each `path`, but the path\r\n     * can naturally comprise of multiple levels separated with a slash. The\r\n     * listener with the longest, most specific matching path prefix for an\r\n     * incoming message will be invoked to handle it.\r\n     *\r\n     * If a matching listener is found, the incoming message is not passed\r\n     * further to any registered legacy MessageHandler callbacks.\r\n     *\r\n     * This method is very light-weight and can be called at any time.\r\n     *\r\n     * @param listener Listener object to register\r\n     * @param path     HTTP-like relative path to register (e.g. '/foo')\r\n     * @return `true` if successfully registered,\r\n     *         `false` if there already is a registered listener for this exact\r\n     *         path or if the given path is invalid\r\n     */\r\n    registerListener(listener: Listener, path: string): boolean;\r\n\r\n    /**\r\n     * Unregister a listener\r\n     *\r\n     * The specified listener will not be notified about any Trouter events\r\n     * anymore. `onTrouterDisconnected()` will not be called automatically\r\n     * during unregistration.\r\n     *\r\n     * All registrations of this `Listener` object (i.e. possibly more than one,\r\n     * registered with different paths) will be unregistered.\r\n     *\r\n     * This method is very light-weight and can be called at any time.\r\n     *\r\n     * @param listener Listener object to unregister\r\n     * @return `true` if successfully unregistered,\r\n     *         `false` if not registered in the first place\r\n     */\r\n    unregisterListener(listener: Listener): boolean;\r\n\r\n    /**\r\n     * Set user activity state\r\n     *\r\n     * Sets the state of the user activity that is then sent to trouter if it\r\n     * is different from the previous state (including Unknown), or upon\r\n     * reconnect, or under other circumstances fully in the discretion of the\r\n     * client. Can throw an instance of Error if that's not possible.\r\n     *\r\n     * @param state The new state of user activity\r\n     * @param correlationVector Correlation vector for end to end tracking\r\n     */\r\n    setUserActivityState(state: UserActivityState, correlationVector?: string): void;\r\n\r\n    /**\r\n     * Sets new state of the audience subscriptions for given connection\r\n     * \r\n     * When called the input value is understood as a definitive new state of \r\n     * connections audience subscriptions. That means user will be only subscribed to audiences\r\n     * currently presented. Any previously subscribed audience that is not present in \r\n     * the new state will be no longer considered as valid and user will be usubscribed\r\n     * from it.\r\n     * \r\n     * @param audienceSubscriptionModel New state of user audience subscriptions\r\n     * @param correlationVector Correlation vector for end to end tracking\r\n     */\r\n    setAudienceSubscriptions(audienceSubscriptionModel: IAudienceSubscriptionModel, correlationVector?: string): Promise<IAudienceSubscriptionsResponse>\r\n}\r\n\r\nexport type LogProvider = {\r\n    log(...message: string[]): void;\r\n    warn(...message: string[]): void;\r\n    error(...message: string[]): void;\r\n    debug(...message: string[]): void;\r\n    info(...message: string[]): void;\r\n};\r\n\r\n/** Headers for HTTP request */\r\nexport interface HttpHeaders {\r\n    [name: string]: string;\r\n}\r\n\r\nexport type TrouterMessage = {\r\n    eventId: number | null;\r\n    url?: string;\r\n    headers?: HttpHeaders;\r\n    body?: TrouterRequestBody;\r\n    rawBody?: string;\r\n};\r\n\r\nexport type TrouterRequestBody = {\r\n    evt?: number;\r\n    eventId?: number;\r\n    gp?: string;\r\n    nsp?: string;\r\n};\r\n\r\n\r\nexport interface MessageHandler {\r\n    handleMessage(message: TrouterMessage): HandleMessageResult | undefined;\r\n}\r\n\r\nexport interface HandleMessageResult {\r\n    /**\r\n     * @deprecated, return 'undefined' from MessageHandler.handleMessage\r\n     * if you want to indicate the message was not handled\r\n     */\r\n    isHandled?: boolean;\r\n\r\n    resultCode: number;\r\n    responseBody?: string;\r\n    responseHeaders?: HttpHeaders;\r\n}\r\n\r\nexport enum TrouterState {\r\n    /** Initial state */\r\n    Unknown = 0,\r\n\r\n    /** ready to work */\r\n    Connected = 2,\r\n\r\n    /** \r\n     * waiting for 'connected' event\r\n     * Might also be in Terminal State. Users should call `isInTerminalState` to check.\r\n     * For legacy reasons, we cannot change the TrouterState enum any longer.\r\n     */\r\n    Disconnected = 3,\r\n\r\n    /** waiting for 'register' from second connection */\r\n    Switching = 9,\r\n}\r\n\r\nexport interface TelemetryEvent {\r\n    name: string;\r\n    properties: {\r\n        [name: string]: {\r\n            value: string | number | boolean | undefined;\r\n        }\r\n    };\r\n}\r\n\r\nexport interface ITelemetrySender {\r\n    logEvent(clientEvent: TelemetryEvent): void;\r\n}\r\n\r\n/**\r\n * Called once token is required.\r\n * Trouter can cache token - it's defined by config option in TrouterSettings\r\n */\r\nexport type SkypeTokenProvider = (forceRefresh: boolean) => Promise<string>;\r\n\r\nexport type TokenType = 'skype' | 'cae' | 'aad';\r\nexport type TokenRequest = {\r\n    /**\r\n     * Value of the WWW-Authenticate header, passed if this TokenRequest\r\n     * is made immediately after an authentication failure that contained the WWW-Authenticate header\r\n     */\r\n    wwwAuthenticateHeader?: string\r\n\r\n    /** Token types that the client library knows how to use */\r\n    supportedTokenTypes: ReadonlyArray<TokenType>\r\n\r\n    /**\r\n     * A hint signaling that there was a recent authentication failure with the last known token,\r\n     * meaning that a cached token should probably not be returned here\r\n     */\r\n    needFresh: boolean\r\n\r\n    /** Information about which service the requested token is going to be sent to */\r\n    purpose?: 'trouter'|'registrar'\r\n};\r\n\r\nexport type TokenResult = {\r\n    token: string\r\n    tokenType: TokenType\r\n};\r\n\r\nexport type AuthTokenProvider = (request: TokenRequest) => Promise<TokenResult>;\r\n\r\n/**\r\n * Stores timeout values to simplify switch between in-call and normal modes\r\n */\r\nexport interface TimeoutOptions {\r\n    /** Timeout for connection to trouter service, i.e. for whole allocation + socket.io connection (all transports together) */\r\n    connectionTimeoutMs: number;\r\n\r\n    /** Timeout for fetch requests, i.e. for allocation, health, registration, unregistration */\r\n    fetchTimeoutMs: number;\r\n\r\n    /** Interval between ping requests */\r\n    pingTimeoutMs: number;\r\n\r\n    /** Timeout for waiting for pong response (websockets) */\r\n    pongTimeoutMs: number;\r\n\r\n    /** Maximal value for backoff timeout */\r\n    maxBackoffMs: number;\r\n\r\n    /** Timeout for handling of an incoming request before a 504 response is sent back automatically */\r\n    requestTimeoutMs: number;\r\n\r\n    /** For how long to wait for response to activity update event. */\r\n    userActivityResponseTimeoutMs?: number;\r\n}\r\n\r\nexport interface TrouterSettings {\r\n    /**\r\n     * GO allocation url of trouter for V4 - like https://go.trouter.teams.microsoft.com/v4/a\r\n     */\r\n    trouterServiceUrl: string;\r\n    version: string;\r\n    productName: string;\r\n    /**\r\n     * aka Client Correlation ID - for correlation between Trouter and other components. It makes sense to persist it if possible\r\n     */\r\n    sessionId: string;\r\n    /**\r\n     * Environment for telemetry, e.g. \"latest\", \"liveint\", \"dogfood\", \"prod\"\r\n     */\r\n    environment: string;\r\n\r\n    /**\r\n     * full URL of EDF registrar service (like https://prod.registrar.skype.com/v2/registrations), if left undefined then Trouter does not\r\n     * register its connection and other registration params can be left undefined as well\r\n     */\r\n    registrarServiceUrl?: string;\r\n    /** mandatory parameter if registration is required */\r\n    registrationId?: string;\r\n    /**\r\n     * @deprecated and will be removed in next versions. Use maxRegistrationTimeInMs instead\r\n     */\r\n    registrarRefreshTimeoutInMs?: number;\r\n    /** mandatory parameter if registration is required */\r\n    pnhAppId?: string;\r\n    /** mandatory parameter if registration is required */\r\n    pnhTemplate?: string;\r\n    /** optional product context to set with the registration */\r\n    pnhProductContext?: string;\r\n    /** optional context to set with the Trouter transport registration */\r\n    pnhContext?: string;\r\n    /** mandatory parameter if registration is required */\r\n    platform?: string;\r\n    /** mandatory parameter if registration is required */\r\n    platformUIVersion?: string;\r\n    /**\r\n     * @deprecated and will be removed in next versions. Use maxRegistrationTimeInMs instead\r\n     */\r\n    registrarTtlInSeconds?: number;\r\n    /** optional, if set - limits registration TTL in EDF. If not - value from Trouter server is used */\r\n    maxRegistrationTimeInMs?: number;\r\n\r\n    /** Timeouts for normal mode */\r\n    timeoutOptions?: TimeoutOptions;\r\n    /**\r\n     * For historical reasons it exists here and in 'timeoutOptions', but if 'timeoutOptions' is\r\n     * specified - this value will be ignored\r\n     */\r\n    trouterConnectTimeoutInMs?: number;\r\n\r\n    /** Timeout for being in 'in-call' mode, i.e. with aggressive ping/retry policy. If it's zero/undefined - in-call mode is disabled */\r\n    incallModeTimeoutMs?: number;\r\n    /** Timeouts for in-call mode, i.e. with more aggressive timeouts/reconnect policy */\r\n    incallTimeoutOptions?: TimeoutOptions;\r\n\r\n    /** Flag to disable internal token cache and always call provided SkypeTokenProvider */\r\n    disableInternalSkypeTokenCache?: boolean;\r\n\r\n    /** After how long to send the user activity second time after reconnect. */\r\n    userActivitySecondResendDelayMs?: number;\r\n\r\n    retryLimitOnTokenFetch?: number;\r\n\r\n    /**\r\n     * Additional headers to send with Trouter connection requests and Registrar registration requests,\r\n     * originally meant for SEAL telemetry purposes.\r\n     */\r\n    extraConnectionHeaders?: HttpHeaders;\r\n\r\n    /**\r\n     * Will be called to determine whether Trouter shouldn't be report itself as connected\r\n     * (onTrouterConnected in listeners, onStateChanged)\r\n     * until the connection has been successfully registered,\r\n     * and will disconnect if an existing registration expires or gets revoked.\r\n     */\r\n    connectionDependsOnRegistration?: () => boolean;\r\n\r\n    /**\r\n     * Will be called to determine whether Trouter should hold back events (onTrouterRequest, onTrouterMessageLoss),\r\n     * until it's connected and registered. Meant to be used with connectionDependsOnRegistration.\r\n     */\r\n    delayEventsUntilRegistered?: () => boolean;\r\n}\r\n\r\nexport interface TrouterTelemetrySettings {\r\n    enabled: boolean;\r\n\r\n    trouter_js_client_connected?: boolean;\r\n    trouter_js_client_disconnected?: boolean;\r\n    trouter_js_client_error?: boolean;\r\n    trouter_js_client_progress?: boolean;\r\n    trouter_js_client_response?: boolean;\r\n    trouter_js_client_request?: boolean;\r\n    trouter_js_client_registration?: boolean;\r\n    trouter_js_client_unregistration?: boolean;\r\n    trouter_js_client_check_connection?: boolean;\r\n\r\n    /** Send trouter_js_client_progress once this number of steps is accumulated */\r\n    numberOfStepsToMaintain?: number;\r\n    /** Send trouter_js_client_progress with current steps after a given timeout */\r\n    sendProgressTimeoutSecs?: number;\r\n\r\n    /**\r\n     * true if health requests should be sent in telemetry events\r\n     */\r\n    logHealthCheckError?: boolean;\r\n    /**\r\n     * True if ping errors should be sent in telemetry events\r\n     */\r\n    logSendPingError?: boolean;\r\n    /**\r\n     * @deprecated and will be removed in next versions\r\n     */\r\n    maxBackoffInMs?: number;\r\n}\r\n\r\nexport interface TrouterTelemetryConfig {\r\n    eventLogger: ITelemetrySender;\r\n    settings: TrouterTelemetrySettings;\r\n}\r\n\r\n/**\r\n * Connection parameters cache\r\n *\r\n * Implement to allow saving connection parameters across sessions (e.g. in\r\n * window.localStorage) and thus retaining the same Trouter URL longer.\r\n */\r\nexport interface IConnectionCache {\r\n    /** Called when the library is asking the host app for any cached connection data */\r\n    onGetTrouterConnectionCache(): Promise<string | undefined>;\r\n    /** Called when the library has updated data to be externally cached */\r\n    onSetTrouterConnectionCache(content: string): void;\r\n}\r\n\r\n/**\r\n * The main configuration of a Trouter client.\r\n *\r\n * One token provider (either `skypeTokenProvider` or `authTokenProvider`) must be supplied in the config.\r\n */\r\nexport type ITrouterServiceConfig = {\r\n    trouterSettings: TrouterSettings;\r\n    telemetryConfig: TrouterTelemetryConfig;\r\n    connectionCache?: IConnectionCache;\r\n    registrationStateCallbackForAcsDoNotUse?(isRegistered: boolean): void;\r\n    proxyUrlRewrite?(url: string): string;\r\n} & ({\r\n    /**\r\n     * Legacy token provider supporting only Skypetokens, provided for backwards compatibility.\r\n     * Will be used if `authTokenProvider` is not passed, otherwise will be ignored.\r\n     */\r\n    skypeTokenProvider: SkypeTokenProvider;\r\n    authTokenProvider?: never;\r\n} | {\r\n    /**\r\n     * Token provider supporting multiple types of tokens. Should be preferred over `skypeTokenProvider`.\r\n     */\r\n    authTokenProvider: AuthTokenProvider;\r\n    skypeTokenProvider?: never;\r\n});\r\n\r\n/**\r\n * Information about trouter connection\r\n */\r\nexport interface IConnectionInfo {\r\n    /** Secure Trouter url at which client can be reached */\r\n    url: string;\r\n\r\n    /** Return connection TTL, i.e. number of seconds till expiration */\r\n    getRemainingTtlInSec(): number;\r\n}\r\n\r\nexport interface IAudienceSubscription {\r\n    readonly id: string;\r\n}\r\n\r\nexport interface IAudienceSubscriptionModel {\r\n    readonly audienceSubscriptions: IAudienceSubscription[];\r\n}\r\n\r\nexport type AudienceSubscriptionResult =\r\n    { audienceSubscriptionState: 'Subscribed', responseStatus?: number } |\r\n    { audienceSubscriptionState: 'Error', responseStatus?: number } |\r\n    { audienceSubscriptionState: 'Unsubscribed', responseStatus?: number } |\r\n    { audienceSubscriptionState: 'Timeout' } |\r\n    { audienceSubscriptionState: 'BadRequest'}\r\n\r\nexport interface IAudienceSubscriptionResponse{\r\n    audienceId: string;\r\n    result: AudienceSubscriptionResult\r\n}\r\n\r\nexport interface IAudienceSubscriptionsResponse{\r\n    responses: IAudienceSubscriptionResponse[];\r\n}\r\n\r\nexport type StateChangedListener = (state: TrouterState, url: string) => void;\r\n\r\nexport type TrouterConnectionListener = (state: TrouterState, info?: IConnectionInfo) => void;\r\n\r\nexport interface ITrouterServiceBase extends Client {\r\n    start(options: ITrouterServiceConfig): void;\r\n    stop(dontUnregister?: boolean): void;\r\n\r\n    setEcsConfig(fullEcsData: Record<string, unknown>): Promise<void>;\r\n\r\n    /**\r\n     * Can be called in two cases:\r\n     * - either network is down (disconnectDetected === true) - trouter will verify that\r\n     *      connection is really down and will start to restoring it;\r\n     * - network is restored (disconnectDetected === false) - trouter will try to restore connection immediately;\r\n     */\r\n    checkConnection(disconnectDetected?: boolean): void;\r\n\r\n    /**\r\n     * Invalidates current registration state and considers the connection \"not registered\"\r\n     * from now on.\r\n     * This will trigger a re-send of endpoint registration to Registrar if registration is being\r\n     * handled by the Trouter Client internally.\r\n     * Can throw an instance of Error if that's not possible.\r\n     */\r\n    resendRegistration(): Promise<void>;\r\n\r\n    /** If trouter is in the terminal state */\r\n    isInTerminalState(): boolean;\r\n\r\n    // Everything below is legacy API, deprecated, do not use\r\n    registerMessageHandler(handler: MessageHandler): void;\r\n    clearMessageHandlers(): void;\r\n    state(): TrouterState;\r\n    /**\r\n     * Reports information about the current Trouter states as a string. Intended for telemetry and not for acting upon\r\n     */\r\n    reportStateInfo(): string;\r\n    getTrouterUrlAsync(): Promise<string>;\r\n    onStateChanged(callback: StateChangedListener | undefined): void;\r\n    offStateChanged(callback: StateChangedListener): boolean;\r\n    addCallback(callback: TrouterConnectionListener): void;\r\n    removeCallback(callback: TrouterConnectionListener): boolean;\r\n}\r\n\r\n/**\r\n * Creates instance of trouter implementation\r\n */\r\nexport declare function createTrouterService(logger: LogProvider): ITrouterServiceBase;\r\n\r\n/**\r\n * Creates instance of trouter implementation\r\n */\r\nexport declare function getTrouterServiceVersion(): string;\r\n\r\n/**\r\n * Helper function to replace URL base (protocol + hostname)\r\n *\r\n * Useful when converting Trouter Endpoint URL to its client-to-client variant\r\n * with `ConnectionInfo.c2cUrlBase`.\r\n */\r\nexport declare function replaceTrouterUrlBase(existingUrl: string, newBase: string): string;\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/Interfaces.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nexport function toJson(obj: unknown): string {\r\n    try {\r\n        return JSON.stringify(obj);\r\n    } catch (error) {\r\n        return `Unable to serialize object of type ${typeof obj}`;\r\n    }\r\n}\r\n\r\nexport function calculateTtlInSec(expirationTsInSec: number | undefined): number {\r\n    const now = Math.round(new Date().getTime() / 1000);\r\n\r\n    return expirationTsInSec !== undefined && expirationTsInSec > now\r\n        ? expirationTsInSec - now\r\n        : 0;\r\n}\r\n\r\nexport function calculateExpireTsInSec(ttlInSec: number): number {\r\n    return Math.round(new Date().getTime() / 1000) + ttlInSec;\r\n}\r\n\r\n/** Wrapper to send request with specified timeout */\r\nexport async function fetchWithTimeout(request: Request, timeoutMs: number): Promise<Response> {\r\n    let timeoutId: Timeout | undefined;\r\n    const fetchPromise = new Promise<Response>((resolve, reject) => {\r\n        fetch(request).then((response) => {\r\n            clearTimeout(timeoutId);\r\n            resolve(response);\r\n        }).catch((error) => {\r\n            clearTimeout(timeoutId);\r\n            reject(error);\r\n        });\r\n    });\r\n    if (timeoutMs !== 0) {\r\n        const timeoutPromise = new Promise<Response>((resolve, reject) => {\r\n            // We make a compromise on how much information to show in the error message.\r\n            // Having the URL there is useful, but including any query parameters is both\r\n            // cumbersome (millions of different errors in telemetry) and unsafe (secret\r\n            // fields that would need to be redacted). \"Origin\" and \"pathname\" achieve that.\r\n            const url = new URL(request.url);\r\n            const error = new Error(`${request.method} ${url.origin}${url.pathname} timed out`);\r\n            timeoutId = setTimeout(reject, timeoutMs, error);\r\n        });\r\n\r\n        return Promise.race([fetchPromise, timeoutPromise]);\r\n    }\r\n\r\n    return fetchPromise;\r\n}\r\n\r\n/***\r\n * Correlation vector\r\n */\r\nexport class CorrelationVector {\r\n    private base: string;\r\n    private extension: number;\r\n\r\n    private constructor(correlationVector?: string) {\r\n        this.base = (correlationVector !== undefined) ? correlationVector : this.createCorrelationVectorBase();\r\n        this.extension = 0;\r\n    }\r\n\r\n    public static extend(correlationVector?: string): CorrelationVector {\r\n        return new CorrelationVector(correlationVector);\r\n    }\r\n\r\n    public increase() {\r\n        this.extension++;\r\n    }\r\n\r\n    public value(): string {\r\n        return `${this.base}.${this.extension}`;\r\n    }\r\n\r\n    private createCorrelationVectorBase(): string {\r\n        const length = 21;\r\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0987654321/+';\r\n        const endChars = 'AQgw';\r\n        let result = '';\r\n        for (let i = 0; i < length; i++) {\r\n            result += chars.charAt(Math.floor(Math.random() * chars.length));\r\n        }\r\n        result += endChars.charAt(Math.floor(Math.random() * endChars.length));\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Simplify calculation of time intervals\r\n */\r\nexport class Timespan {\r\n    private start: number;\r\n\r\n    constructor() {\r\n        this.start = Date.now();\r\n    }\r\n\r\n    /**\r\n     * Returns number of milliseconds from start\r\n     */\r\n    public get duration(): number {\r\n        return Date.now() - this.start;\r\n    }\r\n\r\n    /**\r\n     * Returns start time\r\n     */\r\n    public get startTime() {\r\n        return this.start;\r\n    }\r\n\r\n    /**\r\n     * Reset start of interval to current timestamp\r\n     */\r\n    public reset() {\r\n        this.start = Date.now();\r\n    }\r\n}\r\n\r\n\r\n// Browser vs. @types/node compatibility - browser (where the client is mainly used) uses `number` as return type of setTimeout,\r\n// node.js (where the tests run) uses its own type.\r\n// The types are compatible at runtime for our purposes, e.g. you can just look at the result of `t + 0` of a node.js-returned timeout,\r\n// and then call clearTimeout with the same number literal, and it will work, so they can still be used as object keys, etc.,\r\nexport type Timeout = ReturnType<typeof setTimeout>;\r\nexport type Interval = ReturnType<typeof setInterval>;\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/Common.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n * Internal type definitions for Trouter JavaScript Client\r\n */\r\n\r\nimport { calculateTtlInSec } from './Common';\r\nimport {\r\n    HttpHeaders, IConnectionCache, IConnectionInfo, ITelemetrySender, SendResponseResult,\r\n    TimeoutOptions, TrouterTelemetrySettings\r\n} from './Interfaces';\r\n\r\n\r\nexport interface ITrouterRequest {\r\n    startTS: number;\r\n    url: string;\r\n    shortUrl: string;\r\n    body: string;\r\n    headers: HttpHeaders;\r\n    id: number;\r\n    method: string;\r\n    correlationVector: string;\r\n}\r\n\r\nexport interface IMessageLossIndicator {\r\n    /** flow tag representing the type of lost messages */\r\n    tag: string;\r\n\r\n    /**\r\n     * etag of the particular flow tag, the etag is used to identify the\r\n     * flow tag on the server when sending trouter.processed_message_loss event\r\n     * to be able to determine if new message loss happened after this one or not\r\n     */\r\n    etag: string;\r\n}\r\n\r\n/**\r\n * Response to downstream service\r\n */\r\nexport interface ITrouterResponse {\r\n    writeHead(status: number, headers?: HttpHeaders): void;\r\n    write(chunk: string): void;\r\n    end(chunk?: string): SendResponseResult;\r\n}\r\n\r\n/**\r\n * Data to generate TC query param and for telemetry\r\n */\r\nexport interface IClientInfo {\r\n    /** User-Agent string, for telemetry tracking */\r\n    ua: string;\r\n    /** Application client version, for telemetry tracking */\r\n    v: string;\r\n    /** Trouter client version */\r\n    cv?: string;\r\n}\r\n\r\n/**\r\n * Socket.IO (aka \"transport\") options\r\n */\r\nexport interface ISocketIoOptions {\r\n    'force new connection'?: boolean;\r\n    'reconnect'?: boolean;\r\n    'query'?: string;\r\n    /** timeout for each transport */\r\n    'connect timeout'?: number;\r\n    transports?: string[];\r\n    /**\r\n     * Timeout for waiting for ACK from server for trouter response (i.e. POST HTTP request) in XHR mode\r\n     */\r\n    ackTimeoutMs: number;\r\n\r\n    /**\r\n     * Additional request headers that will be added both to the socket.io handshake request,\r\n     * and to every longpoll GET/POST request\r\n     */\r\n    requestHeaders?: Record<string, string>;\r\n    /**\r\n     * When using the /v4/c protocol, the socket.io handshake request will not be sent, instead\r\n     * the values that would normally be part of the response to it will be provided\r\n     * by the client in this option. Only the WebSocket transport will be available, fallback to longpoll\r\n     * will be performed in a different way (restarting the connection process from the beginning)\r\n     * @property websocketUrl needs to be a wss:// URL, not https://\r\n     */\r\n    'skipped handshake data'?: { timeout: number, websocketUrl: string };\r\n    rewriteUrlForProxy(url: string): string;\r\n}\r\n\r\n/**\r\n * EDF registrar options\r\n */\r\nexport interface IRegistrarOptions {\r\n    registrarUrl: string;\r\n    registrationId: string;\r\n\r\n    pnhAppId: string;\r\n    platform: string;\r\n    pnhTemplateKey: string;\r\n    platformUIVersion: string;\r\n    productContext?: string;\r\n    context: string;\r\n\r\n    /** If set - limits registration TTL in EDF. If not - value from Trouter is used */\r\n    registrarTtlSec?: number;\r\n}\r\n\r\n/**\r\n * Options passed from outside\r\n */\r\nexport interface IConfiguration {\r\n    clientInfo: IClientInfo;\r\n\r\n    eventLogger: ITelemetrySender;\r\n    telemetrySettings: TrouterTelemetrySettings;  // Client telemetry configuration settings\r\n\r\n    clientCorrelationID: string;  // Client telemetry correlation ID, for correlation between Trouter and other components\r\n    environment: string;  // Environment for telemetry, e.g. \"latest\", \"liveint\", \"dogfood\", \"prod\"\r\n\r\n    ioOptions?: ISocketIoOptions;  // Socket.IO options\r\n    io?: Record<string, unknown>;  // Socket.IO override; for tests only\r\n}\r\n\r\n/**\r\n * Options passed from outside\r\n */\r\nexport interface ITrouterOptions extends IConfiguration {\r\n    endpointId?: string;\r\n    trouterUrl: string;\r\n    registration?: IRegistrarOptions;\r\n    connectionDependsOnRegistration: () => boolean;\r\n    delayEventsUntilRegistered: () => boolean;\r\n\r\n    /**\r\n     * timeouts for normal mode\r\n     */\r\n    timeoutOptions: TimeoutOptions;\r\n\r\n    /**\r\n     * timeouts for in-call mode, i.e. with more aggressive timeouts/reconnect policy\r\n     */\r\n    incallTimeoutOptions: TimeoutOptions;\r\n\r\n    /**\r\n     * Timeout for being in 'in-call' mode, i.e. with aggressive ping/retry policy. If it's zero - in-call mode is disabled\r\n     */\r\n    incallModeTimeoutMs: number;\r\n\r\n    /**\r\n     * Delay for keeping a previous connection open after connection switching.\r\n     */\r\n    lingeringConnectionDelayMs: number;\r\n\r\n    /**\r\n     * After how long to send the user activity second time after reconnect.\r\n     */\r\n    userActivitySecondResendDelayMs: number;\r\n\r\n    /**\r\n     * How soon after a connection is established must a disconnect packet with\r\n     * the \"dup\" reason come to be recognized as a \"duplicate loop/storm\" with\r\n     * another client sharing the same connection cache and trigger recovery.\r\n     */\r\n    duplicateDisconnectThresholdMs: number;\r\n\r\n    connectionCache?: IConnectionCache;\r\n\r\n    /**\r\n     * Optional setting to put a limit on maximum number of token fetch retries\r\n     */\r\n    retryLimitOnTokenFetch?: number;\r\n\r\n    /**\r\n     * The goal is that normally, getting an AAD token will make the client use the /v4/c protocol.\r\n     * This setting can be used by tests to make sure that even the /v4/a protocol works with AAD tokens.\r\n     * It can also be used to delay the rollout of the /v4/c protocol until we want to use it everywhere.\r\n     */\r\n    forceV4aProtocol?: boolean;\r\n\r\n    /** See TrouterSettings.extraConnectionHeaders */\r\n    extraConnectionHeaders?: Record<string, string>;\r\n\r\n    /**\r\n     * When calling start() when Trouter is already running, any pending backoffs will be reset.\r\n     * To avoid resetting it too often (e.g. when an event that triggers start() is called too often),\r\n     * this behavior is additionally throttled to only once per time period specified here.\r\n     */\r\n    expediteBackoffOnStartMinimumDelayMs?: number;\r\n\r\n    registrationStateCallback?(isRegistered: boolean): void;\r\n\r\n    rewriteUrlForProxy(this: void, url: string): string;\r\n\r\n    toJSON?(): unknown;\r\n}\r\n\r\n/**\r\n * Information about server connection\r\n */\r\nexport class ServerState implements IConnectionInfo {\r\n    public constructor(\r\n        /** Trouter client connection ID */\r\n        public connectionId: string,\r\n        /** Trouter client connected client ID */\r\n        public connectedClientId: string,\r\n        /** window.location.hostname */\r\n        public domId: string,\r\n        /** Unsecure Trouter url at which client can be reached */\r\n        public unsecureUrl: string,\r\n        /** Secure Trouter url at which client can be reached */\r\n        public url: string,\r\n        /** URL base to use for client-to-client requests */\r\n        public c2cUrlBase: string,\r\n        /** expiration timestamp for connection in seconds */\r\n        public expirationTsSec?: number\r\n    ) {\r\n    }\r\n\r\n    /** Return connection TTL, i.e. number of seconds till expiration */\r\n    public getRemainingTtlInSec(): number {\r\n        return calculateTtlInSec(this.expirationTsSec);\r\n    }\r\n}\r\n\r\n/**\r\n * Interface for trouter URL promise resolver\r\n */\r\nexport interface ITrouterUrlPromise {\r\n    resolveUrl(url: string): void;\r\n    resetUrl(): void;\r\n}\r\n\r\nexport enum UserActivityEventReason {\r\n    Unknown = 0,\r\n    Modified = 1,\r\n    Snapshot = 2,\r\n    Connected = 3\r\n}\r\n\r\nexport type SignatureData = {\r\n    sr: string,\r\n    issuer: string,\r\n    sp: string,\r\n    se: string,\r\n    st: string,\r\n    scae?: string,\r\n    sig: string\r\n};\r\n\r\nexport type AnonymousWebsocketAuthentication = {\r\n    headers: Record<string, string>\r\n    connectparams?: Partial<SignatureData>\r\n};\r\n\r\n/**\r\n * Duplicating TrouterState since too many parts of SCC depend on it for us to change it internally.\r\n * Don't expose this to the outside world, to avoid another repeat of this issue.\r\n */\r\nexport enum TrouterManagerState {\r\n    /** Initial state */\r\n    Unknown = 0,\r\n\r\n    /** ready to work */\r\n    Connected = 2,\r\n\r\n    /** waiting for 'connected' event */\r\n    Disconnected = 3,\r\n\r\n    /** waiting for 'register' from second connection */\r\n    Switching = 9,\r\n\r\n    /** Unable to continue, in final state. */\r\n    TerminalError = 10,\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/InternalInterfaces.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { TokenType } from './Interfaces';\r\nimport { SignatureData } from './InternalInterfaces';\r\nimport { IReconnectParameters, ITrouterConnectedEventArgs, ITrouterConnectedEventArgsV4c } from './TrouterConnection';\r\nimport { FallbackReason } from './TrouterFsm';\r\n\r\nexport type Protocol = 'v4a' | 'v4c';\r\n\r\nexport function usedProtocol(tokenType: TokenType, reconnectParams: IReconnectParameters | undefined): Protocol {\r\n    return (tokenType === 'skype' && safeToString(reconnectParams?.scae) !== '1') ? 'v4a' : 'v4c';\r\n}\r\n\r\nfunction safeToString(value: unknown) {\r\n    if (typeof value === 'string') {\r\n        return value;\r\n    } else if (typeof value === 'number') {\r\n        return value.toString();\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function usedProtocolAfterFallback(protocol: Protocol, fallbackReason?: FallbackReason): Protocol {\r\n    if (fallbackReason?.kind === 'v4c-websocket-failure') {\r\n        return 'v4a';\r\n    }\r\n\r\n    return protocol;\r\n}\r\n\r\nexport function isV4ConnectEvent(args: ITrouterConnectedEventArgs | ITrouterConnectedEventArgsV4c) {\r\n    return Object.prototype.hasOwnProperty.call(args, 'connectparams');\r\n}\r\n\r\n/**\r\n * Needed because we want to have cache with reconnectUrl, serviceUrl working\r\n * independent of protocol (see IReconnectParameters and its uses)\r\n */\r\nexport function adaptUrl(url: string, protocol: Protocol): string {\r\n    if (protocol === 'v4a') {\r\n        // The insecure (http://, ws://) versions would only ever be used by a test application,\r\n        // the connection URL is normally determined by the consumer of the library.\r\n        // eslint-disable-next-line @microsoft/sdl/no-insecure-url\r\n        return url.replace(/\\/v4\\/c\\b/, '/v4/a').replace('wss://', 'https://').replace('ws://', 'http://');\r\n    } else {\r\n        // eslint-disable-next-line @microsoft/sdl/no-insecure-url\r\n        return url.replace(/\\/v4\\/a\\b/, '/v4/c').replace('https://', 'wss://').replace('http://', 'ws://');\r\n    }\r\n}\r\n\r\n/**\r\n * Unfortunately the pre-existing cache format doesn't separate connectparams into its own property so it could be easily sent back,\r\n * instead it manually removes `reconnectUrl` and `serviceUrl` and send everything else, so we need to do the same here\r\n */\r\nexport function reconnectParamsWithoutUrls(reconnectParams: IReconnectParameters | undefined) {\r\n    if (reconnectParams === undefined) {\r\n        return undefined;\r\n    }\r\n\r\n    return <Partial<SignatureData>>{ ...reconnectParams, reconnectUrl: undefined, serviceUrl: undefined };\r\n}\r\n\r\nexport function ensureNumber(value: string | number): number {\r\n    return typeof value === 'string' ? parseInt(value, 10) : value;\r\n}\r\n\r\nexport function redirectUrlIfPresent(reason: FallbackReason | undefined): string | undefined {\r\n    if (reason?.kind !== 'redirect' || reason.host === undefined) {\r\n        return undefined;\r\n    }\r\n\r\n    let redirectHost = reason.host;\r\n    if (redirectHost.endsWith('/')) {\r\n        redirectHost = redirectHost.substring(0, redirectHost.length - 1);\r\n    }\r\n\r\n    if (!redirectHost.endsWith('/v4/c') && !redirectHost.endsWith('/v4/a')) {\r\n        redirectHost += '/v4/c';\r\n    }\r\n\r\n    return redirectHost;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/ProtocolAdapters.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { DisconnectReason } from './DisconnectReason';\r\nimport { LogProvider, TokenResult } from './Interfaces';\r\nimport { IMessageLossIndicator, ITrouterRequest, UserActivityEventReason } from './InternalInterfaces';\r\nimport { Logger } from './Logger';\r\nimport { usedProtocol, usedProtocolAfterFallback } from './ProtocolAdapters';\r\nimport { IReconnectParameters, ITrouterReconnectEventArgs, ReconnectReason } from './TrouterConnection';\r\n\r\nexport type FallbackReason = { kind: 'redirect', host: string } | { kind: 'redirect-no-host' } | { kind: 'v4c-websocket-failure' };\r\n\r\nexport interface IWorker {\r\n    getToken(useCache: boolean, backoff: boolean, claimsChallenge: string | undefined, reason?: FallbackReason): void;\r\n\r\n    startConnectionTimer(): void;\r\n    stopConnectionTimer(): void;\r\n    startPingTimer(): void;\r\n    stopPingTimer(): void;\r\n\r\n    /** Returns true if config mandates to not register connection URL with EDF Registrar */\r\n    shouldSkipRegistration(): boolean;\r\n    /** Returns true if user specified a custom TTL for registration */\r\n    hasCustomRegistrationTtl(): boolean;\r\n    startRegistrationTimer(): void;\r\n    startRegistrationRetryTimer(): void;\r\n    stopRegistrationTimer(): void;\r\n\r\n    startSocketIo(token: TokenResult): void;\r\n    stopSocketIo(): void;\r\n    isIncallMode(): boolean;\r\n    restartIncallModeTimer(): void;\r\n    enterIncallMode(): void;\r\n    exitIncallMode(): void;\r\n\r\n    dispatchConnected(): void;\r\n    dispatchRegistered(): void;\r\n    dispatchUnregistered(): void;\r\n    dispatchDownstreamRequest(request: ITrouterRequest): void;\r\n    /** Start reconnecting due to socket error */\r\n    dispatchReconnecting(): void;\r\n    /** Reconnection is requested by server (current connection is still valid) */\r\n    dispatchReconnectIsRequired(useConnectParamsFromCache: boolean, reason: ReconnectReason): void;\r\n    dispatchDisconnected(): void;\r\n    dispatchTerminalError(): void;\r\n    dispatchTrouterMessageLost(flowTags: IMessageLossIndicator[]): void;\r\n    /** Notify the connection that the client has failed to connect. */\r\n    countDisconnectBeforeConnectionEstablishment(): void;\r\n\r\n    sendAllocateRequest(token: TokenResult): void;\r\n    sendPingRequest(): void;\r\n\r\n    connectV4c(token: TokenResult, reason?: FallbackReason): void;\r\n    sendV4cAuthenticationEvent(token: TokenResult): void;\r\n\r\n    sendUserActivityState(reason: UserActivityEventReason, connected: boolean, correlationVector?: string): void;\r\n\r\n    sendRegisterRequest(): void;\r\n    sendUnregisterRequest(): void;\r\n\r\n    /** Reset planned token request (if any) and backoff interval */\r\n    resetTokenBackoff(): void;\r\n    /** Cancel pending registration requests (if any) */\r\n    cancelPendingRegistrationRequests(): void;\r\n    /** Cancel all pending downstream events related timers. */\r\n    clearSentEventTimers(): void;\r\n    sendDisconnectTelemetryEvent(error?: string): void;\r\n}\r\n\r\nexport enum State {\r\n    Initial,\r\n    /** waiting for token from User */\r\n    RetrievingToken,\r\n    /** waiting for allocation response from service */\r\n    Allocating,\r\n    /**\r\n     * waiting for Socket.IO handshake to be finished. After that Socket.IO will\r\n     * start to try transports and send 'connecting' event\r\n     */\r\n    Handshaking,\r\n    /**\r\n     * waiting for 'connected' event - socket.io is trying different transports.\r\n     * onSocketError event should be ignored, as it's expected event. So, only ConnectFailed or\r\n     * connection timeout meas failed connection\r\n     */\r\n    Connecting,\r\n    /**\r\n     * connecting to a websocket /v4/c URL\r\n     *\r\n     * this is the equivalent of the \"Allocating -> Handshaking -> Connecting\" chain\r\n     * from the /v4/a protocol\r\n     */\r\n    AnonymousConnecting,\r\n    /**\r\n     * connected to a websocket /v4/c URL, sending the authentication message,\r\n     * and waiting to receive a `trouter.connected` event back\r\n     */\r\n    WebsocketAuthenticating,\r\n    /** ready to work */\r\n    Connected,\r\n    /** waiting for a successful 'unregister' response */\r\n    Unregistering,\r\n    /**\r\n     * Unrecoverable state\r\n     * Trouter cannot start once in this state\r\n     */\r\n    TerminalError\r\n}\r\n\r\nenum RegistrationState {\r\n    Initial,\r\n    /** Waiting for a successful 'register' response */\r\n    Registering,\r\n    /** like the above, but another registration must happen when done because of resendRegistration() */\r\n    RegisteringButResendPending,\r\n    /** Registration failed, waiting to retry */\r\n    Retrying,\r\n    /** Registration succeeded */\r\n    Registered,\r\n    /** Registration is skipped */\r\n    RegistrationDisabled\r\n}\r\n\r\ntype ReconnectOptions = { backoff: boolean, allowCachedToken: boolean, claimsChallenge?: string, fallbackReason?: FallbackReason };\r\n\r\n/**\r\n * State machine for trouter\r\n */\r\nexport class TrouterFsm {\r\n    private logger: Logger;\r\n    private state: State = State.Initial;\r\n    private registrationState: RegistrationState;\r\n    private autoReconnect = true;\r\n\r\n    constructor(\r\n        logfunc: LogProvider,\r\n        private worker: IWorker,\r\n        private incallModeEnabled: boolean,\r\n        private protocolSelector: typeof usedProtocol\r\n    ) {\r\n        this.logger = new Logger('ConnectionFsm', logfunc);\r\n        this.registrationState = RegistrationState.Initial;\r\n    }\r\n\r\n    /** Returns current state */\r\n    public getState(): State {\r\n        return this.state;\r\n    }\r\n\r\n    public isActive(): boolean {\r\n        return this.state === State.Allocating\r\n            || this.state === State.Connected\r\n            || this.state === State.Handshaking\r\n            || this.state === State.Connecting\r\n            || this.state === State.RetrievingToken\r\n            || this.state === State.AnonymousConnecting\r\n            || this.state === State.WebsocketAuthenticating;\r\n    }\r\n\r\n    public isConnecting(): boolean {\r\n        return this.state === State.Allocating\r\n            || this.state === State.Handshaking\r\n            || this.state === State.Connecting\r\n            || this.state === State.AnonymousConnecting;\r\n    }\r\n\r\n    //////////// Events ////////////\r\n    /**\r\n     * Start trouter\r\n     */\r\n    public start(): boolean {\r\n        if (this.state === State.Initial) {\r\n            this.setState(State.RetrievingToken);\r\n            this.worker.getToken(true, false, undefined);\r\n\r\n            return true;\r\n        } else {\r\n            this.showIgnored('start');\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop trouter\r\n     * @param dontUnregister    if true, FSM will not unregister. It's needed in case of two simultaneous\r\n     *                          connections, to replace first connection with second - registrar just updates\r\n     *                          the existing record for the user, by registrationId (see their API docs),\r\n     *                          that id does not change during the lifetime of a TrouterService instance.\r\n     * @param isTerminalError   if true, FSM will transition into the terminal state\r\n     */\r\n    public stop(\r\n       dontUnregister: boolean,\r\n       isTerminalError?: boolean,\r\n    ) {\r\n        if (dontUnregister) {\r\n            this.registrationState = RegistrationState.Initial;\r\n        }\r\n\r\n        if (this.worker.isIncallMode()) {\r\n            this.worker.exitIncallMode();\r\n        }\r\n\r\n        this.worker.resetTokenBackoff();\r\n        this.worker.cancelPendingRegistrationRequests();\r\n        this.worker.stopConnectionTimer();\r\n        this.worker.stopPingTimer();\r\n        this.worker.clearSentEventTimers();\r\n        this.worker.stopRegistrationTimer();\r\n        this.worker.stopSocketIo();\r\n\r\n        if (this.state === State.Connected) {\r\n            this.worker.sendDisconnectTelemetryEvent('connection stopped');\r\n        }\r\n\r\n        // Stop can happen in any state - the only difference is if registration exists or not.\r\n        // It can be also called a second time, just to stop a stuck unregistration.\r\n        if ((this.registrationState === RegistrationState.Registered\r\n             || this.registrationState === RegistrationState.Registering\r\n             || this.registrationState === RegistrationState.RegisteringButResendPending)\r\n            && this.state !== State.Unregistering\r\n        ) {\r\n            this.registrationState = RegistrationState.Initial;\r\n            this.setState(State.Unregistering);\r\n            this.worker.sendUnregisterRequest();\r\n        } else {\r\n            if (isTerminalError) {\r\n                this.setState(State.TerminalError);\r\n                this.worker.dispatchTerminalError();\r\n            } else {\r\n                this.setState(State.Initial);\r\n                this.worker.dispatchDisconnected();\r\n            }\r\n        }\r\n    }\r\n\r\n    public onTokenReceived(token: TokenResult, reason?: FallbackReason, reconnectParams?: IReconnectParameters) {\r\n        if (this.state === State.RetrievingToken) {\r\n            if (usedProtocolAfterFallback(this.protocolSelector(token.tokenType, reconnectParams), reason) === 'v4c') {\r\n                this.setState(State.AnonymousConnecting);\r\n                this.worker.startConnectionTimer();\r\n                this.worker.connectV4c(token, reason);\r\n            } else {\r\n                this.setState(State.Allocating);\r\n                this.worker.startConnectionTimer();\r\n                this.worker.sendAllocateRequest(token);\r\n            }\r\n        } else {\r\n            this.showIgnored('onTokenReceived');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * if disconnectDetected - need to send ping to check if connection is really dead,\r\n     * otherwise - network is available\r\n     */\r\n    public checkConnection(disconnectDetected: boolean) {\r\n        if (disconnectDetected) {\r\n            this.onPingInterval();\r\n        }\r\n    }\r\n\r\n    /** Allocation request succeed with 200 */\r\n    public onAllocationSucceed(token: TokenResult): boolean {\r\n        // Call to dispatchUnregistered a little bit earlier takes into account the case when the state\r\n        // of the state machine can change inside the callback, for example if Trouter.stop() is called inside the callback.\r\n        if (this.state === State.Allocating && this.registrationState === RegistrationState.Registered) {\r\n            this.worker.dispatchUnregistered();\r\n        }\r\n\r\n        if (this.state === State.Allocating) {\r\n            this.setState(State.Handshaking);\r\n            this.registrationState = RegistrationState.Initial;\r\n            this.worker.startSocketIo(token);\r\n\r\n            return true;\r\n        } else {\r\n            this.showIgnored('onAllocationSucceed');\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /** Allocation request failed */\r\n    public onAllocationFailed(unauthorized: boolean, claimsChallenge: string | undefined) {\r\n        if (this.state === State.Allocating) {\r\n            this.cleanUpAndInitiateReconnect({ backoff: true, allowCachedToken: !unauthorized, claimsChallenge });\r\n        } else {\r\n            this.showIgnored('onAllocationFailed');\r\n        }\r\n    }\r\n\r\n    public onV4cException() {\r\n        if (this.state === State.AnonymousConnecting || this.state === State.WebsocketAuthenticating) {\r\n            this.logger.error('v4c exception, falling back to longpoll');\r\n            this.cleanUpAndInitiateReconnect({ backoff: true, allowCachedToken: true, fallbackReason: { kind: 'v4c-websocket-failure' }});\r\n        }\r\n    }\r\n\r\n    /** Connection didn't succeed in given timeout */\r\n    public onConnectingTimeout() {\r\n        // implementation note: this also called from onConnectingFailed\r\n        if (this.state === State.Allocating\r\n            || this.state === State.Connecting\r\n            || this.state === State.Handshaking\r\n            || this.state === State.AnonymousConnecting\r\n            || this.state === State.WebsocketAuthenticating\r\n        ) {\r\n            this.cleanUpAndInitiateReconnect({ backoff: false, allowCachedToken: true });\r\n        } else {\r\n            this.showIgnored('onConnectingTimeout');\r\n        }\r\n    }\r\n\r\n    /** socket.io handshake succeed and socket.io is trying next transport */\r\n    public onConnecting() {\r\n        if (this.state === State.Handshaking) {\r\n            this.setState(State.Connecting);\r\n        } else {\r\n            this.showIgnored('onConnecting');\r\n        }\r\n    }\r\n\r\n    /** socket.io connected (1::), but trouter.connected event has not arrived yet */\r\n    public onSocketConnect(token: TokenResult) {\r\n        if (this.state === State.AnonymousConnecting) {\r\n            this.setState(State.WebsocketAuthenticating);\r\n            this.worker.sendV4cAuthenticationEvent(token);\r\n        } else {\r\n            this.showIgnored('onSocketConnect');\r\n        }\r\n    }\r\n\r\n    /** Socket.io connection wasn't established */\r\n    public onConnectingFailed() {\r\n        // This callback will be called when all transports failed to connect, i.e. socket.io can't proceed\r\n        if (this.state === State.Connecting) {\r\n            this.onConnectingTimeout();\r\n        } else if (this.state === State.Handshaking) {\r\n            // It should never happen, because socket.io should try at least one transport\r\n            this.logger.error('Unexpected error in Socket.io - no valid transports');\r\n            this.onConnectingTimeout();\r\n        } else if (this.state === State.AnonymousConnecting || this.state === State.WebsocketAuthenticating) {\r\n            this.logger.info('/v4/c falling back to longpoll');\r\n            this.cleanUpAndInitiateReconnect({ backoff: true, allowCachedToken: true, fallbackReason: { kind: 'v4c-websocket-failure' }});\r\n        } else {\r\n            this.showIgnored('onConnectingFailed');\r\n        }\r\n    }\r\n\r\n    /** Socket.io error (or disconnect) */\r\n    public onSocketDisconnect(disconnectReason?: DisconnectReason) {\r\n        if (this.state === State.Handshaking || this.state === State.Connected || this.state === State.WebsocketAuthenticating) {\r\n            if (this.state === State.Connected) {\r\n                this.worker.sendDisconnectTelemetryEvent(disconnectReason?.toTelemetryString());\r\n            }\r\n            if (this.state === State.WebsocketAuthenticating) {\r\n                this.worker.countDisconnectBeforeConnectionEstablishment();\r\n            }\r\n            if (disconnectReason?.reason === 'skypetoken-deprecated') {\r\n                this.logger.error('Skypetoken deprecated response, not retrying any further');\r\n                this.onTerminalError();\r\n            } else {\r\n                this.cleanUpAndInitiateReconnect({\r\n                    // If client was already successfully connected, no backoff is needed (we want to reconnect quickly).\r\n                    // If however connection failed before the `trouter.connected` event arrived,\r\n                    // that means some sort of error where we don't want to retry immediately.\r\n                    backoff: this.state !== State.Connected && disconnectReason?.reason !== 'dup',\r\n                    allowCachedToken: disconnectReason?.reason !== 'unauthorized',\r\n                    claimsChallenge: disconnectReason?.claims});\r\n            }\r\n        } else {\r\n            // Disconnect can be called because of an error.\r\n            // Such error can happen in Connecting state, which means that\r\n            // websocket transport failed to establish connection\r\n            this.showIgnored('onSocketDisconnect');\r\n        }\r\n    }\r\n\r\n    /** Received 'trouter.connected' event from service */\r\n    public onTrouterConnected() {\r\n        if (this.state === State.Connecting || this.state === State.WebsocketAuthenticating) {\r\n            this.setState(State.Connected);\r\n            this.worker.resetTokenBackoff();\r\n            this.worker.stopConnectionTimer();\r\n            this.worker.sendUserActivityState(UserActivityEventReason.Connected, true);\r\n            this.worker.startPingTimer();\r\n            this.worker.dispatchConnected();\r\n            if (this.worker.shouldSkipRegistration()) {\r\n                this.registrationState = RegistrationState.RegistrationDisabled;\r\n                this.worker.dispatchRegistered();\r\n            } else {\r\n                this.registrationState = RegistrationState.Registering;\r\n                this.worker.sendRegisterRequest();\r\n            }\r\n        } else {\r\n            this.showIgnored('onTrouterConnected');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Received 'trouter.reconnect' event from service, or URL in configuration has changed,\r\n     * need to establish a new connection\r\n     */\r\n    public onReconnectRequired(useConnectParamsFromCache: boolean, reason: ReconnectReason, eventArgs?: ITrouterReconnectEventArgs) {\r\n        if (this.state === State.AnonymousConnecting || this.state === State.WebsocketAuthenticating) {\r\n            if (eventArgs === undefined || eventArgs.target !== 'host' || eventArgs.url === undefined || eventArgs.url === '') {\r\n                this.logger.error(`unexpected reconnect arguments: ${eventArgs?.target} ${eventArgs?.url}, reconnecting without cache`);\r\n                this.cleanUpAndInitiateReconnect({ backoff: true, allowCachedToken: true, fallbackReason: { kind: 'redirect-no-host' }});\r\n            } else {\r\n                this.cleanUpAndInitiateReconnect({ backoff: true, allowCachedToken: true, fallbackReason: { kind: 'redirect', host: eventArgs.url }});\r\n            }\r\n        } else {\r\n            this.worker.dispatchReconnectIsRequired(useConnectParamsFromCache, reason);\r\n        }\r\n    }\r\n\r\n    public disableAutoReconnect() {\r\n        this.autoReconnect = false;\r\n    }\r\n\r\n    /** Request from downstream is received */\r\n    public onDownstreamRequest(request: ITrouterRequest) {\r\n        if (this.state === State.Connected) {\r\n            this.switchToIncallModeIfEnabled();\r\n            this.worker.dispatchDownstreamRequest(request);\r\n        } else {\r\n            this.showIgnored('onDownstreamRequest');\r\n        }\r\n    }\r\n\r\n    public onTrouterMessageLost(messageLossIndicators: IMessageLossIndicator[]) {\r\n        if (this.state === State.Connected) {\r\n            this.worker.dispatchTrouterMessageLost(messageLossIndicators);\r\n        } else {\r\n            this.showIgnored('onTrouterMessageLost');\r\n        }\r\n    }\r\n\r\n    /** Timer for ping request fired */\r\n    public onPingInterval() {\r\n        if (this.state === State.Connected) {\r\n            this.worker.sendPingRequest();\r\n        } else {\r\n            this.showIgnored('onPingInterval');\r\n        }\r\n    }\r\n\r\n    /** No pong response from service within timeout */\r\n    public onPingResponseTimeout() {\r\n        this.onMissedResponse('onPingResponseTimeout');\r\n    }\r\n\r\n    /** Pong response */\r\n    public onPingResponse() {\r\n        if (this.state === State.Connected) {\r\n            // do nothing\r\n        } else {\r\n            this.showIgnored('onPingResponse');\r\n        }\r\n    }\r\n\r\n    public onRegistrationFailed() {\r\n        if (this.state === State.Connected && this.registrationState === RegistrationState.Registering) {\r\n            this.worker.dispatchUnregistered();\r\n            this.registrationState = RegistrationState.Retrying;\r\n            this.worker.startRegistrationRetryTimer();\r\n        } else if (this.state === State.Connected && this.registrationState === RegistrationState.RegisteringButResendPending) {\r\n            this.registrationState = RegistrationState.Registering;\r\n            this.worker.sendRegisterRequest();\r\n        } else {\r\n            this.showIgnored('onRegistrationFailed');\r\n        }\r\n    }\r\n\r\n    public onRetryRegistration() {\r\n        if (this.state === State.Connected && this.registrationState === RegistrationState.Retrying) {\r\n            this.registrationState = RegistrationState.Registering;\r\n            this.worker.sendRegisterRequest();\r\n        } else {\r\n            this.showIgnored('onRetryRegistration');\r\n        }\r\n    }\r\n\r\n    public onRegistrationSucceeded() {\r\n        if (this.state === State.Connected && this.registrationState === RegistrationState.Registering) {\r\n            this.registrationState = RegistrationState.Registered;\r\n            this.worker.dispatchRegistered();\r\n            this.worker.startRegistrationTimer();\r\n        } else if (this.state === State.Connected && this.registrationState === RegistrationState.RegisteringButResendPending) {\r\n            this.registrationState = RegistrationState.Registering;\r\n            this.worker.sendRegisterRequest();\r\n        } else {\r\n            this.showIgnored('onRegistrationSucceeded');\r\n        }\r\n    }\r\n\r\n    /** Registration TTL is about to expire */\r\n    public onRegistrationNearExpiry() {\r\n        if (this.state === State.Connected && this.registrationState === RegistrationState.Registered) {\r\n            this.registrationState = RegistrationState.Registering;\r\n            this.worker.sendRegisterRequest();\r\n        } else {\r\n            this.showIgnored('onRegistrationNearExpiry');\r\n        }\r\n    }\r\n\r\n    public onUnregistrationDone() {\r\n        if (this.state === State.Unregistering) {\r\n            this.setState(State.Initial);\r\n            this.worker.dispatchUnregistered();\r\n            this.worker.dispatchDisconnected(); // TODO: only sending \"disconneted\" upon unregistration makes no sense\r\n        } else {\r\n            this.showIgnored('onUnregistrationDone');\r\n        }\r\n    }\r\n\r\n    public onResendRegistration() {\r\n        this.worker.dispatchUnregistered();\r\n\r\n        if (this.state === State.Connected && this.registrationState === RegistrationState.Registered) {\r\n            this.registrationState = RegistrationState.Registering;\r\n            this.worker.stopRegistrationTimer();\r\n            this.worker.sendRegisterRequest();\r\n        } else if (this.state === State.Connected && this.registrationState === RegistrationState.Registering) {\r\n            this.registrationState = RegistrationState.RegisteringButResendPending;\r\n        }\r\n    }\r\n\r\n    public onIncallModeTimer() {\r\n        this.worker.exitIncallMode();\r\n\r\n        if (this.state === State.Connected) {\r\n            this.worker.stopPingTimer();\r\n            this.worker.startPingTimer();\r\n        } else {\r\n            this.showIgnored('onIncallModeTimer');\r\n        }\r\n    }\r\n\r\n    public onSetNewUserActivityState() {\r\n        this.worker.sendUserActivityState(UserActivityEventReason.Modified, this.state === State.Connected);\r\n    }\r\n\r\n    public onActivityStateResponseTimeout() {\r\n        this.onMissedResponse('onActivityStateResponseTimeout');\r\n    }\r\n\r\n    public forceReconnect(reason: string) {\r\n        if (this.state === State.Connected) {\r\n            this.worker.sendDisconnectTelemetryEvent(reason);\r\n        }\r\n        this.worker.resetTokenBackoff();\r\n        this.cleanUpAndInitiateReconnect({ backoff: false, allowCachedToken: true });\r\n    }\r\n\r\n    public onTerminalError() {\r\n        this.logger.error(`Cannot proceed, reached terminal state. Switching from state '${State[this.state]}' to ${State[State.TerminalError]}`);\r\n        this.stop(\r\n            /* dontUnregister */ true,\r\n            /* isTerminalError */ true\r\n        );\r\n        this.setState(State.TerminalError);\r\n    }\r\n\r\n    private onMissedResponse(onResponseHandlerName: string) {\r\n        if (this.state === State.Connected) {\r\n            this.worker.sendDisconnectTelemetryEvent(onResponseHandlerName);\r\n            this.cleanUpAndInitiateReconnect({ backoff: false, allowCachedToken: true });\r\n        } else {\r\n            this.showIgnored(onResponseHandlerName);\r\n        }\r\n    }\r\n\r\n    private showIgnored(event: string) {\r\n        this.logger.debug(`Ignoring event '${event}' in state '${State[this.state]}'`);\r\n    }\r\n\r\n    private setState(state: State) {\r\n        this.logger.info(`Switching from state '${State[this.state]}' to state '${State[state]}'`);\r\n        if (this.state === state) {\r\n            this.logger.error(`Attempt to switch to the current state '${State[state]}'`);\r\n\r\n            return;\r\n        }\r\n        this.state = state;\r\n    }\r\n\r\n    private switchToIncallModeIfEnabled() {\r\n        if (this.incallModeEnabled) {\r\n            if (!this.worker.isIncallMode()) {\r\n                this.worker.enterIncallMode();\r\n                this.worker.stopPingTimer();\r\n                this.worker.startPingTimer();\r\n            }\r\n            this.worker.restartIncallModeTimer();\r\n        }\r\n    }\r\n\r\n    private cleanUpAndInitiateReconnect(options: ReconnectOptions)\r\n    {\r\n        if (!this.autoReconnect) {\r\n            this.logger.info('Automatic reconnect is disabled, stopping this connection');\r\n            this.stop(true);\r\n            return;\r\n        }\r\n\r\n        this.worker.cancelPendingRegistrationRequests();\r\n        this.worker.stopConnectionTimer();\r\n        this.worker.stopPingTimer();\r\n        this.worker.clearSentEventTimers();\r\n        this.worker.stopRegistrationTimer();\r\n        this.worker.stopSocketIo();\r\n\r\n        this.setState(State.RetrievingToken);\r\n        this.worker.dispatchReconnecting();\r\n        this.worker.getToken(options.allowCachedToken, options.backoff, options.claimsChallenge, options.fallbackReason);\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/TrouterFsm.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { createRegistrarClient, IRegistrarClient, IRegistrarClientOptions } from '@skype/tsregistrar';\r\nimport { calculateExpireTsInSec, calculateTtlInSec, fetchWithTimeout, Interval, Timeout, Timespan, toJson } from './Common';\r\nimport { ClientEventName, ConnectionTracker, Properties, ResponseData } from './ConnectionTracker';\r\nimport { CLIENT_VERSION, SUPPORTED_TOKEN_TYPES, USER_AUTHENTICATE_EVENT_NAME } from './Constants';\r\nimport { DisconnectReason } from './DisconnectReason';\r\nimport { ExponentialBackoff } from './ExponentialBackoff';\r\nimport {\r\n    AuthTokenProvider,\r\n    HttpHeaders, LogProvider, SendResponseResult, TimeoutOptions,\r\n    TokenRequest,\r\n    TokenResult,\r\n    UserActivityState,\r\n    IAudienceSubscriptionsResponse, IAudienceSubscriptionResponse, AudienceSubscriptionResult, IAudienceSubscription, TrouterState\r\n} from './Interfaces';\r\nimport {\r\n    AnonymousWebsocketAuthentication,\r\n    IClientInfo, IMessageLossIndicator, ISocketIoOptions, ITrouterOptions, ITrouterRequest, ITrouterResponse,\r\n    ServerState, UserActivityEventReason\r\n} from './InternalInterfaces';\r\nimport { Logger } from './Logger';\r\nimport { adaptUrl, ensureNumber, isV4ConnectEvent, reconnectParamsWithoutUrls, redirectUrlIfPresent, usedProtocol } from './ProtocolAdapters';\r\nimport { FallbackReason, IWorker, TrouterFsm, State } from './TrouterFsm';\r\nimport { UserActivityObject, UserActivitySnapshot, AudienceSubscriptionState, AudienceSubscriptionSnapshot } from './TrouterManager';\r\n\r\n// This is the current API version\r\nconst VERSION: string = 'v4';\r\n\r\n// Default value for registration timeout\r\nconst DEFAULT_REGISTRATION_TIMEOUT_SEC = 3600;\r\n\r\n// socket.io library is very much disconnected from the rest of the project\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\ndeclare function require(arg: string): any;\r\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\r\nconst io: any = require('./socket.io');\r\n\r\n/**\r\n * Stub for IClientInfo\r\n */\r\nclass ClientInfo implements IClientInfo {\r\n    public cv: string = CLIENT_VERSION;\r\n    public ua: string = '';\r\n    public hr: string = '';\r\n    public v: string = '';\r\n}\r\n\r\n/**\r\n * Stub for ISocketIoOptions\r\n */\r\nclass SocketIoOptions implements ISocketIoOptions {\r\n    public 'force new connection'?: boolean = true;\r\n    public 'reconnect'?: boolean = false;\r\n    public 'query'?: string = '';\r\n    public ackTimeoutMs = 5000;\r\n    public rewriteUrlForProxy(url: string) { return url; }\r\n}\r\n\r\n/**\r\n * Interface to work with SocketIO library\r\n */\r\ninterface ISocketIo {\r\n    socketNumber: number;\r\n    socket: { options: ISocketIoOptions };\r\n\r\n    emit(event: string, handler?: () => void): void;\r\n    emit(event: string, args: Record<string, unknown>, handler?: (name: string, args?: unknown) => void): void;\r\n    // Some event arguments are from the socket.io library, others are directly coming from the server,\r\n    // we currently don't type check them.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    on(event: string, handler: (...eventArgs: any[]) => void): void;\r\n    disconnect(): void;\r\n    send(msg: string): void;\r\n    removeAllListeners(event: string): void;\r\n}\r\n\r\n/**\r\n * Params received during handshake\r\n */\r\nexport interface ITrouterConnectedEventArgs {\r\n    // Time it took Trouter to perform the handshake request internally, in milliseconds. Number in quotes, e.g. \"123\"\r\n    dur: string;\r\n    // Connection valid TTL in seconds as returned by service.\r\n    ttl: number;\r\n}\r\n\r\n/**\r\n * As there is no separate allocation request in /v4/c, all of the information comes as part of the trouter.connected event\r\n */\r\nexport type ITrouterConnectedEventArgsV4c = IAllocateResult & Omit<ITrouterConnectedEventArgs, 'ttl'> & { reconnectUrl: string };\r\n\r\n/**\r\n * Params received during trouter.reconnect event\r\n */\r\nexport interface ITrouterReconnectEventArgs {\r\n    // Reconnect target: self, host or global\r\n    target: string;\r\n    // Url of the deployment to reconnect to\r\n    url?: string;\r\n}\r\n\r\n/**\r\n * Params received on message lost event\r\n */\r\ninterface ITrouterMessageLossEventArgs {\r\n    droppedIndicators: IMessageLossIndicator[];\r\n}\r\n\r\ntype TrouterRequestCallbackType = (val: string) => void;\r\n\r\nconst cvHeader: string = 'MS-CV';\r\n\r\n/**\r\n * Request from downstream service\r\n */\r\nclass TrouterRequest implements ITrouterRequest {\r\n    public startTS: number;\r\n    public url: string;\r\n    public shortUrl: string;\r\n    public body: string;\r\n    public headers: HttpHeaders;\r\n    public id: number;\r\n    public method: string;\r\n    public replied: boolean;\r\n    public timedout: boolean;\r\n    public timeoutTimerId: Timeout | undefined;\r\n\r\n    private dataCallback: TrouterRequestCallbackType | undefined;\r\n    private cvCounter: number = 0;\r\n    private receivedCv: string;\r\n\r\n    public constructor(requestJson: string, private logger?: Logger) {\r\n        const json: unknown = JSON.parse(requestJson);\r\n\r\n        this.startTS = this.safeJsonNumber(json, 'startTS', 0);\r\n        this.url = this.safeJsonString(json, 'url', '');\r\n        this.shortUrl = this.safeJsonString(json, 'shortUrl', '');\r\n        this.body = this.safeJsonString(json, 'body', '');\r\n        this.headers = this.safeJsonRecord(json, 'headers', {});\r\n        this.id = this.safeJsonNumber(json, 'id', -1);\r\n        this.method = this.safeJsonString(json, 'method', '');\r\n\r\n        this.replied = false;\r\n        this.timedout = false;\r\n\r\n        this.receivedCv = this.headers[cvHeader];\r\n        this.updateCvHeader();\r\n    }\r\n\r\n    public get correlationVector(): string {\r\n        return this.receivedCv ? `${this.receivedCv}.${this.cvCounter}` : '';\r\n    }\r\n\r\n    public on(target: string, targetCallback: (val?: string) => void) {\r\n        if (target === 'data') {\r\n            this.dataCallback = targetCallback;\r\n        } else if (target === 'end') {\r\n            if (typeof this.dataCallback === 'function') {\r\n                this.dataCallback(this.body);\r\n            }\r\n            targetCallback();\r\n        }\r\n    }\r\n\r\n    public incrementCorrelationVector() {\r\n        ++this.cvCounter;\r\n        this.updateCvHeader();\r\n    }\r\n\r\n    private updateCvHeader(): void {\r\n        const cv: string = this.correlationVector;\r\n        if (cv) {\r\n            this.headers[cvHeader] = cv;\r\n        }\r\n    }\r\n\r\n    private safeJsonNumber(json: unknown, property: string, defaultValue: number) {\r\n        if (json !== null && json !== undefined && Object.prototype.hasOwnProperty.call(json, property)) {\r\n            const jsonRecord = <Record<string, unknown>>json;\r\n            if (typeof jsonRecord[property] === 'number') {\r\n                return <number>(jsonRecord[property]);\r\n            } else if (typeof jsonRecord[property] === 'string') {\r\n                return parseFloat(<string>(jsonRecord[property]));\r\n            } else {\r\n                this.logger?.warn(`unexpected type of '${property}': ${typeof jsonRecord[property]}`);\r\n            }\r\n        }\r\n        return defaultValue;\r\n    }\r\n\r\n    private safeJsonString(json: unknown, property: string, defaultValue: string) {\r\n        if (json !== null && json !== undefined && Object.prototype.hasOwnProperty.call(json, property)) {\r\n            const jsonRecord = <Record<string, unknown>>json;\r\n            if (typeof jsonRecord[property] === 'string') {\r\n                return <string>(jsonRecord[property]);\r\n            } else {\r\n                this.logger?.warn(`unexpected type of '${property}': ${typeof jsonRecord[property]}`);\r\n            }\r\n        }\r\n        return defaultValue;\r\n    }\r\n\r\n    private safeJsonRecord(json: unknown, property: string, defaultValue: Record<string, string>) {\r\n        if (json !== null && json !== undefined && Object.prototype.hasOwnProperty.call(json, property)) {\r\n            const jsonRecord = <Record<string, unknown>>json;\r\n            if (typeof jsonRecord[property] === 'object') {\r\n                return <Record<string, string>>(jsonRecord[property]);\r\n            } else {\r\n                this.logger?.warn(`unexpected type of '${property}': ${typeof jsonRecord[property]}`);\r\n            }\r\n        }\r\n        return defaultValue;\r\n    }\r\n}\r\n\r\n/**\r\n * Response to downstream service\r\n */\r\nclass TrouterResponse implements ITrouterResponse {\r\n    public constructor(\r\n        private request: TrouterRequest,\r\n        private responseData: ResponseData,\r\n        private sendResponse: (request: TrouterRequest, responseData: ResponseData) => SendResponseResult) {\r\n    }\r\n\r\n    public writeHead(status: number, headers?: HttpHeaders) {\r\n        this.responseData.status = status;\r\n        this.responseData.headers = headers;\r\n    }\r\n\r\n    public write(chunk: string) {\r\n        this.responseData.body += chunk;\r\n    }\r\n\r\n    public end(chunk?: string): SendResponseResult {\r\n        if (chunk) {\r\n            this.responseData.body += chunk;\r\n        }\r\n\r\n        return this.sendResponse(this.request, this.responseData);\r\n    }\r\n}\r\n\r\n/**\r\n * An client-initiated event that is to be sent to trouter.\r\n */\r\nclass DownstreamEvent {\r\n    public name: string;\r\n    public args: Record<string, unknown>;\r\n    public timeoutTimerId: Timeout;\r\n\r\n    public constructor(name: string) {\r\n        this.name = name;\r\n        this.args = {};\r\n        this.timeoutTimerId = <Timeout><unknown>0;\r\n    }\r\n}\r\n\r\n/**\r\n * Reason why a connection switch is happening.\r\n */\r\nexport enum ReconnectReason {\r\n    /** Configuration change coming from ECS, containing different URL */\r\n    Configuration,\r\n\r\n    /** In response to a `trouter.reconnect` socket.io event */\r\n    ServerInitiated\r\n}\r\n\r\n/**\r\n * Interface to be implemented by Trouter consumer\r\n */\r\nexport interface IManagerConsumer {\r\n    /** Called on received request */\r\n    onDownstreamRequest(connection: TrouterConnection, request: ITrouterRequest, response: ITrouterResponse): void;\r\n    /** Called once connection is established */\r\n    onConnected(connection: TrouterConnection): void;\r\n    /** Called once registration in EDF is succeed */\r\n    onRegistered(connection: TrouterConnection): void;\r\n    /** Called if registration in EDF fails or expires */\r\n    onUnregistered(connection: TrouterConnection): void;\r\n    /** Called once connection failed */\r\n    onReconnecting(connection: TrouterConnection): void;\r\n    /** Called when server asked to reconnect */\r\n    onReconnectIsRequired(connection: TrouterConnection, useConnectParamsFromCache: boolean, reason: ReconnectReason): void;\r\n    /** Called once connection is unregistered and closed */\r\n    onDisconnected(connection: TrouterConnection): void;\r\n    /** Called once connection is reaches the terminal state */\r\n    onTerminalError(connection: TrouterConnection): void;\r\n    /** Called when connection parameters are updated */\r\n    onConnectionParametersUpdated(connectParams: Record<string, unknown>): void;\r\n    /** Called when message loss indicator received */\r\n    onTrouterMessageLost(flowTags: IMessageLossIndicator[]): void;\r\n    /** Called once user activity state is accepted */\r\n    onUserActivityStateAccepted(cv: string): void;\r\n    /** Called when audience subscription set finishes */\r\n    onAudiencesSetResolved(audienceSubscriptionsResponse: IAudienceSubscriptionsResponse, cv: string): void;\r\n    /** Returns the current state of the connection state machine */\r\n    getState(): TrouterState;\r\n}\r\n\r\n/**\r\n * Allocation result from Trouter server.\r\n * With /v4/a protocol, this corresponds to the data returned from the /v4/a HTTP request\r\n * With /v4/c protocol, this is returned as part of the `trouter.connected` event\r\n */\r\nexport interface IAllocateResult {\r\n    url: string;\r\n    surl: string;\r\n    curlb: string;\r\n    connectparams: Record<string, unknown>;\r\n    socketio: string;\r\n    id: string;\r\n    ccid: string;\r\n    ttl: string;\r\n}\r\n\r\n/**\r\n * Locally cached reconnection parameters\r\n *\r\n * Allows reconnecting to the same deployment and retaining the\r\n * allocated Connection ID, Trouter Endpoint URL, etc.\r\n * Consists of IAllocateResult.connectparams (opaque to the client)\r\n * extended with a bit more info about the deployment it came from.\r\n */\r\nexport type IReconnectParameters = {\r\n    /** URL that was sent by the server during a previous connection, typically URL of a specific Trouter deployment */\r\n    reconnectUrl?: string\r\n\r\n    /** URL that was passed to the client in settings, typically a \"go URL\" (load balancer) */\r\n    serviceUrl?: string\r\n\r\n    /** connectparams / signature data */\r\n    [param: string]: unknown\r\n};\r\n\r\ntype PendingAudienceSubscription = {\r\n    readonly audienceSetResolve: (response: IAudienceSubscriptionsResponse) => void;\r\n    readonly timeoutId: Timeout;\r\n}\r\n\r\n/**\r\n * Trouter + registration flow implementation\r\n */\r\nexport class TrouterConnection implements IWorker {\r\n    private readonly WEBSOCKET_TRANSPORT_NAME = 'websocket';\r\n    private readonly XHR_POLLING_TRANSPORT_NAME = 'xhr-polling';\r\n\r\n    private readonly AUDIENCE_SUBSCRIPTION_RESULT_ERROR = 'Error';\r\n    private readonly AUDIENCE_SUBSCRIPTION_RESULT_UNSUBSCRIBED = 'Unsubscribed';\r\n    private readonly AUDIENCE_SUBSCRIPTION_RESULT_TIMEOUT = 'Timeout';\r\n    private readonly AUDIENCE_SUBSCRIPTION_RESULT_BAD_REQUEST = \"BadRequest\";\r\n\r\n    private readonly AUDIENCE_SUBSCRIPTION_STATE_QUERY_PARAM_REGEX = /&audienceSubscriptionState=[^&]*|^audienceSubscriptionState=[^&]*&?/;\r\n\r\n    private readonly logger: Logger;\r\n    private readonly tokenBackoff: ExponentialBackoff;\r\n    private readonly fsm: TrouterFsm;\r\n    private readonly connectionTracker: ConnectionTracker;\r\n    private readonly registrarClient?: IRegistrarClient;\r\n\r\n    private connectionId = '';\r\n\r\n    private inIncallMode = false;\r\n    private timeoutOptions: TimeoutOptions;\r\n    private connectionTimeoutId?: Timeout;\r\n    private pingTimerId?: Interval;\r\n    private pingResponseTimerId?: Timeout;\r\n    private registrationTimerId?: Timeout;  // Used for three kinds of registration-related timers:\r\n                                            // 1) TTL near expiration, 2) TTL fully expired, 3) retry after failure\r\n    private incallModeTimerId?: Timeout;\r\n\r\n    private socket?: ISocketIo;\r\n    private allocateResult?: IAllocateResult;\r\n    /** expiration's timestamp of allocated connectionID */\r\n    private connectionExpireTimestampInSecs?: number;\r\n    /** Seeded by externally cached connection parameters at startup, updated by each successful allocation result.\r\n     *  The contents might be mangled in various ways (especially if coming from the external connection cache),\r\n     *  so all code working with it must make no assumptions about which fields are actually present etc.\r\n     */\r\n    private reconnectParams?: IReconnectParameters;\r\n\r\n    /** Allocated URL where library was able to successfully connect */\r\n    private connectedUrl?: string;\r\n\r\n    /** Name of currently used transport */\r\n    private transportTypeName: string | undefined;\r\n\r\n    private clientID: number;\r\n    private connectionAttempt = 0;\r\n    private connectedClientId = '';\r\n    private domId: string | undefined;\r\n    private isNavigatorOnline: boolean = true;\r\n    private onNavigatorOnlineStatusUpdateBound = this.onNavigatorOnlineStatusUpdate.bind(this);  // Bound to allow removing the listener\r\n    private c2cUrlBase: string = '';\r\n    private connectingErrorsInRow = 0;\r\n\r\n    /** Keeps track of 401s */\r\n    private unauthorizedErrorCount = 0;\r\n\r\n    private readonly clientInfo: Readonly<IClientInfo>;\r\n    /** Used to calculate short URL in requests */\r\n    private urlPath: string | undefined;\r\n    private userActivityState: UserActivityObject;\r\n    private pendingSentEventTimers: { [id: number]: string; } = {};\r\n\r\n    private lastDisconnectReason: string = '';\r\n\r\n    private readonly UNKNOWN_TRANSPORT = 'unknown_transport';\r\n    private readonly connectingErrorsThreshold = 3;\r\n\r\n    // this variable represents and ongoing audience subscription operation that has been initiated by user\r\n    // if the operation value exists it means that user requested a subscription but there has not been an answer from server yet\r\n    // valid only for longpoll \r\n    private pendingAudienceSubscription?: PendingAudienceSubscription = undefined;\r\n\r\n    constructor(\r\n        logProvider: LogProvider,\r\n        private options: ITrouterOptions,\r\n        private manager: IManagerConsumer,\r\n        private tokenProvider: AuthTokenProvider,\r\n        private usingLegacyTokenApi: boolean,\r\n        initialUserActivityState: UserActivityObject,\r\n        private protocolSelector: typeof usedProtocol,\r\n        private audienceSubscriptionState?: AudienceSubscriptionState\r\n    ) {\r\n        this.logger = new Logger('Connection', logProvider);\r\n        this.timeoutOptions = this.options.timeoutOptions;\r\n        this.tokenBackoff = new ExponentialBackoff(this.logger, this.timeoutOptions.maxBackoffMs);\r\n        this.clientID = Date.now();\r\n\r\n        if ((typeof window !== 'undefined') && window.location) {\r\n            this.domId = window.location.hostname;\r\n        }\r\n\r\n        const clientInfo = new ClientInfo();\r\n        clientInfo.cv = CLIENT_VERSION;\r\n        clientInfo.ua = '';\r\n\r\n        if (this.options?.clientInfo) {\r\n            clientInfo.ua = this.safeString(this.options.clientInfo.ua);\r\n            clientInfo.v = this.safeString(this.options.clientInfo.v);\r\n        }\r\n\r\n        this.clientInfo = clientInfo;\r\n\r\n        this.connectionTracker = new ConnectionTracker(\r\n            logProvider,\r\n            this.clientID,\r\n            this.clientInfo,\r\n            () => { return this.getServerState(); },\r\n            this.options.endpointId,\r\n            this.options.clientCorrelationID,\r\n            this.options.environment\r\n        );\r\n        this.applyConnectionTrackerOptions(options);\r\n\r\n        const useIncallMode = this.options.incallModeTimeoutMs > 0;\r\n        this.fsm = new TrouterFsm(logProvider, this, useIncallMode, this.protocolSelector);\r\n\r\n        if (options.registration) {\r\n            const registrarOptions: IRegistrarClientOptions = {\r\n                registrarUrl: options.registration.registrarUrl,\r\n                proxyUrlRewrite: options.rewriteUrlForProxy,\r\n                registrationId: options.registration.registrationId,\r\n                requestTimeoutMs: options.timeoutOptions.fetchTimeoutMs,\r\n                initialRetryDelayMs: 1000,\r\n                maxRetryDelayMs: options.timeoutOptions.maxBackoffMs,\r\n                usingLegacyTokenApi: this.usingLegacyTokenApi,\r\n                maxRetriesForGetToken: options.retryLimitOnTokenFetch,\r\n                extraRegistrationHeaders: options.extraConnectionHeaders\r\n            };\r\n            this.registrarClient = createRegistrarClient(logProvider, this.tokenProvider, registrarOptions);\r\n        }\r\n\r\n        this.userActivityState = initialUserActivityState;\r\n    }\r\n\r\n    public start(externalConnectParams?: IReconnectParameters) {\r\n        this.logger.info('Starting');\r\n\r\n        this.reconnectParams = externalConnectParams;\r\n\r\n        if (typeof window !== 'undefined' && window.navigator && window.addEventListener) {\r\n            this.isNavigatorOnline = window.navigator.onLine;\r\n            window.addEventListener('online', this.onNavigatorOnlineStatusUpdateBound);\r\n            window.addEventListener('offline', this.onNavigatorOnlineStatusUpdateBound);\r\n            this.logger.debug(`Registered for browser online notifications - current state: ${this.isNavigatorOnline}`);\r\n        } else {\r\n            this.isNavigatorOnline = true;  // Assume always online if the API is not available\r\n        }\r\n\r\n        this.fsm.start();\r\n    }\r\n\r\n    public stop(dontUnregister: boolean) {\r\n        this.logger.info('Stopping');\r\n\r\n        if (typeof window !== 'undefined' && window.navigator) {\r\n            window.removeEventListener('online', this.onNavigatorOnlineStatusUpdateBound);\r\n            window.removeEventListener('offline', this.onNavigatorOnlineStatusUpdateBound);\r\n        }\r\n\r\n        this.fsm.stop(dontUnregister);\r\n        this.connectionTracker.close();\r\n    }\r\n\r\n    public configure(options: ITrouterOptions) {\r\n        // Currently only baseUrl and telemetrySettings options are supported for reconfiguration\r\n        const urlChanged = this.options.trouterUrl !== options.trouterUrl;\r\n        this.options = options;\r\n\r\n        this.applyConnectionTrackerOptions(options);\r\n\r\n        if (urlChanged) {\r\n            this.logger.info('Configuration changed. Reconnection required.');\r\n            this.fsm.onReconnectRequired(false, ReconnectReason.Configuration);\r\n        }\r\n    }\r\n\r\n    public checkConnection(disconnectDetected: boolean) {\r\n        this.logger.info(`checkConnection called with ${disconnectDetected}`);\r\n\r\n        this.fsm.checkConnection(disconnectDetected);\r\n\r\n        // Don't send on disconnectDetected === false, because Teams client calls it on timer\r\n        if (disconnectDetected) {\r\n            this.connectionTracker.sendTelemetry(ClientEventName.CheckConnection, {\r\n                disconnectDetected: disconnectDetected\r\n            }, []);\r\n        }\r\n    }\r\n\r\n    public disableRegistrationsAndAutoReconnect() {\r\n        this.stopRegistrationTimer();\r\n        this.cancelPendingRegistrationRequests();\r\n        this.fsm.disableAutoReconnect();\r\n    }\r\n\r\n    /** Returns info about connection */\r\n    public getServerState(): ServerState {\r\n        return new ServerState(\r\n            this.connectionId,\r\n            this.connectedClientId,\r\n            this.domId ? this.domId : '',\r\n            this.allocateResult ? this.allocateResult.url : '',\r\n            this.allocateResult ? this.allocateResult.surl : '',\r\n            this.c2cUrlBase,\r\n            this.connectionExpireTimestampInSecs);\r\n    }\r\n\r\n    public getState(): State {\r\n        return this.fsm.getState();\r\n    }\r\n\r\n    //////// Implement IWorker ////////\r\n\r\n    public getToken(\r\n        useCache: boolean,\r\n        backoff: boolean,\r\n        claimsChallenge: string | undefined,\r\n        reason?: FallbackReason,\r\n        retryCounter: number = 0\r\n    ) {\r\n        this.logger.info(`Getting token ${backoff ? 'with backoff' : 'without backoff'}`);\r\n\r\n        const requestFunction = () => {\r\n            this.connectionTracker.trackStart('token');\r\n            const tokenRequest: TokenRequest = {\r\n                needFresh: !useCache,\r\n                wwwAuthenticateHeader: claimsChallenge,\r\n                supportedTokenTypes: SUPPORTED_TOKEN_TYPES,\r\n                purpose: 'trouter'\r\n            };\r\n            this.logger.info(\r\n                `Requesting token: needFresh=${tokenRequest.needFresh} ` +\r\n                `types=[${SUPPORTED_TOKEN_TYPES}], ` +\r\n                `wwwAuthenticateHeader is ${tokenRequest.wwwAuthenticateHeader ? 'non empty' : 'empty'}`);\r\n\r\n            this.tokenProvider(tokenRequest).then((token) => {\r\n                this.logger.debug(`${token.tokenType} token is received`);\r\n                this.connectionTracker.trackEnd('token');\r\n                this.fsm.onTokenReceived(token, reason, this.reconnectParams);\r\n            }).catch((error: Error) => {\r\n                const msg = toJson(error.stack);\r\n                this.logger.error(`Getting token failed, will retry after timeout. Error: ${msg}`);\r\n                this.connectionTracker.trackError('token', msg);\r\n\r\n                // Can't retry getToken request, which means client would not receive any notifications from trouter.\r\n                // Unrecoverable error unless client tries to reconnect with Trouter\r\n                //     - retryCounter tracks internal loop\r\n                //     - unauthorizedErrorCount tracks external loop (consecutive number of sendAllocationFailures as a result of 401s)\r\n                if (!this.canRetryTokenFetchRequest(retryCounter + this.unauthorizedErrorCount)) {\r\n                    const errorMessage = 'getToken retry limit hit, reached terminal error state';\r\n                    this.connectionTracker.trackError('token', errorMessage);\r\n                    this.resetTokenBackoff();\r\n                    this.fsm.onTerminalError();\r\n\r\n                    return;\r\n                }\r\n                this.getToken(useCache, true, claimsChallenge, reason, retryCounter + 1);\r\n            });\r\n        };\r\n\r\n        if (backoff) {\r\n            this.tokenBackoff.backoff('getting token', requestFunction);\r\n        } else {\r\n            this.resetTokenBackoff();\r\n            requestFunction();\r\n        }\r\n    }\r\n\r\n    public startConnectionTimer() {\r\n        this.stopConnectionTimer();\r\n        this.logger.debug(`Starting connection timeout for ${this.timeoutOptions.connectionTimeoutMs} ms`);\r\n        this.connectionTimeoutId = setTimeout(() => {\r\n            this.logger.info('Connection timeout is fired');\r\n            this.fsm.onConnectingTimeout();\r\n        }, this.timeoutOptions.connectionTimeoutMs);\r\n    }\r\n\r\n    public stopConnectionTimer() {\r\n        if (this.connectionTimeoutId) {\r\n            this.logger.debug('Stopping connection timeout');\r\n            clearTimeout(this.connectionTimeoutId);\r\n            this.connectionTimeoutId = undefined;\r\n        }\r\n    }\r\n\r\n    public startPingTimer() {\r\n        if (this.transportTypeName === 'websocket') {\r\n            this.logger.debug(`Starting ping timeout for ${this.timeoutOptions.pingTimeoutMs} ms`);\r\n            this.pingTimerId = setInterval(() => {\r\n                this.logger.info('Ping interval fired');\r\n                this.fsm.onPingInterval();\r\n            }, this.timeoutOptions.pingTimeoutMs);\r\n        } else {\r\n            this.logger.debug(`Not starting ping for transport ${this.transportTypeName}`);\r\n        }\r\n    }\r\n\r\n    public stopPingTimer() {\r\n        if (this.pingTimerId) {\r\n            this.logger.debug('Stopping ping timeout');\r\n            this.clearPingResponseTimer();\r\n            clearInterval(this.pingTimerId);\r\n            this.pingTimerId = undefined;\r\n        }\r\n    }\r\n\r\n    public shouldSkipRegistration() {\r\n        return this.options.registration === undefined;\r\n    }\r\n\r\n    public hasCustomRegistrationTtl() {\r\n        return this.options.registration?.registrarTtlSec !== undefined && this.options.registration?.registrarTtlSec !== 0;\r\n    }\r\n\r\n    public startRegistrationTimer() {\r\n        this.stopRegistrationTimer();\r\n\r\n        const timeForReregistrationSec = 30;\r\n        const [ttl, isTtlReduced] = this.getRegistrationTtl();\r\n\r\n        if (ttl <= timeForReregistrationSec || !isTtlReduced) {\r\n            this.logger.debug(`Starting registration expiration timer (TTL ${ttl} sec)`);\r\n\r\n            this.registrationTimerId = setTimeout(() => {\r\n                this.registrationTimerId = undefined;\r\n                this.logger.warn('Registration expired but the connection is still alive. Should never happen');\r\n                this.dispatchUnregistered();\r\n            }, ttl * 1000);\r\n\r\n            return;\r\n        }\r\n\r\n        const delay = ttl - timeForReregistrationSec;\r\n        this.logger.debug(`Starting registration extension timer for ${delay} sec`);\r\n        this.registrationTimerId = setTimeout(() => {\r\n            this.logger.info('Registration extension timer fired');\r\n            this.registrationTimerId = setTimeout(() => {\r\n                this.registrationTimerId = undefined;\r\n                this.logger.debug('Registration extension did not happen in time');\r\n                this.dispatchUnregistered();\r\n            }, timeForReregistrationSec * 1000);\r\n            this.fsm.onRegistrationNearExpiry();\r\n        }, delay * 1000);\r\n    }\r\n\r\n    public startRegistrationRetryTimer() {\r\n        this.stopRegistrationTimer();\r\n\r\n        // A simple static delay for now, per discussion in PR 870422.\r\n        const registrationRetryDelaySec = 123;\r\n        this.registrationTimerId = setTimeout(() => {\r\n            this.registrationTimerId = undefined;\r\n            this.fsm.onRetryRegistration();\r\n        }, registrationRetryDelaySec * 1000);\r\n    }\r\n\r\n    public stopRegistrationTimer() {\r\n        if (this.registrationTimerId) {\r\n            this.logger.debug('Stopping registration timeout');\r\n            clearTimeout(this.registrationTimerId);\r\n            this.registrationTimerId = undefined;\r\n        }\r\n    }\r\n\r\n    public resendRegistration(): Promise<void> {\r\n        if (!this.registrarClient) {\r\n            throw new Error('Trouter Client not configured to handle registrations');\r\n        }\r\n\r\n        this.fsm.onResendRegistration();\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public buildSocketIoUrlParams(userActivitySnapshot?: UserActivitySnapshot, audienceSubscriptionSnapshot?: AudienceSubscriptionSnapshot): string {\r\n        if (!this.allocateResult) {\r\n            throw new Error('Allocate result is undefined in buildSocketIoUrlParams()');\r\n        }\r\n\r\n        const urlParams: Record<string, string | number> = {};\r\n\r\n        // Copy connection parameters (i.e. signature) from allocation response\r\n        const signatureData = this.allocateResult.connectparams;\r\n        for (const i of Object.keys(signatureData)) {\r\n            if (signatureData[i] !== undefined) {\r\n                const value = signatureData[i];\r\n                if (typeof value === 'string' || typeof value === 'number') {\r\n                    urlParams[i] = value;\r\n                } else {\r\n                    this.logger.error(`signatureData[${i}] has unsupported type ${typeof value}`);\r\n                }\r\n            }\r\n        }\r\n\r\n        // And add some more fields\r\n        urlParams.v = VERSION;\r\n        urlParams.tc = encodeURI(toJson(this.clientInfo));\r\n        urlParams.timeout = this.timeoutOptions.pingTimeoutMs / 1000;\r\n        urlParams.auth = 'true';\r\n\r\n        if (this.options.endpointId) {\r\n            urlParams.epid = this.options.endpointId;\r\n        }\r\n\r\n        if (userActivitySnapshot) {\r\n            urlParams.userActivity = encodeURI(toJson(userActivitySnapshot));\r\n        }\r\n\r\n        if (audienceSubscriptionSnapshot) {\r\n            urlParams.audienceSubscriptionState = encodeURIComponent(toJson(audienceSubscriptionSnapshot));\r\n        }\r\n\r\n        return this.appendConnectedClientIds(this.buildQuery(urlParams), true);\r\n    }\r\n\r\n    public startSocketIo(token: TokenResult) {\r\n        this.logger.debug('Starting socket io');\r\n        this.connectionTracker.trackStart('connectSocket');\r\n        if (!this.allocateResult) {\r\n            throw new Error('Allocate result is undefined in startSocketIo()');\r\n        }\r\n\r\n        const options: ISocketIoOptions = this.options.ioOptions ? { ...this.options.ioOptions } : new SocketIoOptions();\r\n        // Take user activity snapshot (if a state isn't unknown) to make sure it's consistent between the function calls below.\r\n        const userActivitySnapshot = this.userActivityState.state !== UserActivityState.Unknown\r\n            ? this.userActivityState.increaseCvAndGetEventObject()\r\n            : undefined;\r\n\r\n        const audienceSubscriptionStateSnapshot = this.audienceSubscriptionState?.increaseCvAndGetEventObject();\r\n\r\n        // Regardless of any passed in socket.io options, force the following settings.\r\n        options['force new connection'] = true;\r\n        options.reconnect = false;\r\n        options.rewriteUrlForProxy = this.options.rewriteUrlForProxy;\r\n        options.requestHeaders = {\r\n            ...this.options.extraConnectionHeaders,\r\n            ...headersFromToken(token, this.usingLegacyTokenApi)\r\n        };\r\n\r\n        // Query params to each socket.io request\r\n        options.query = this.buildSocketIoUrlParams(userActivitySnapshot, audienceSubscriptionStateSnapshot);\r\n        this.logger.info(`connecting to ${this.allocateResult.socketio}?${options.query}`);\r\n\r\n        // msg868 - clear all events and disconnect\r\n        this.stopSocketIo();\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call\r\n        this.socket = (this.options.io ?? io).connect(this.allocateResult.socketio, options);\r\n        if (this.socket === undefined) {\r\n            throw new Error('Can\\'t create Socket.io object');\r\n        }\r\n\r\n        this.attachSocketIoHandlers(this.socket, token, userActivitySnapshot, audienceSubscriptionStateSnapshot);\r\n    }\r\n\r\n    public stopSocketIo() {\r\n        if (this.socket) {\r\n            this.logger.debug('clearing socket.io');\r\n            try {\r\n                for (const event of [\r\n                    'connecting', 'connect', 'connect_failed', 'close_during_connecting', 'disconnect', 'reconnect', 'reconnect_failed',\r\n                    'reconnecting', 'error', 'message', 'trouter.connected', 'trouter.reconnect', 'trouter.message_loss'\r\n                ]) {\r\n                    this.socket.removeAllListeners(event);\r\n                }\r\n\r\n                this.socket.disconnect();\r\n                this.logger.debug('cleared socket');\r\n                this.socket = undefined;\r\n            } catch (error) {\r\n                this.logger.error(`exception in disconnecting previous socket. Error: ${errorStackToJson(error)}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    public dispatchConnected() {\r\n        this.logger.info('dispatching connected');\r\n        this.manager.onConnected(this);\r\n    }\r\n\r\n    public dispatchRegistered() {\r\n        this.logger.info('dispatching registered');\r\n        this.manager.onRegistered(this);\r\n    }\r\n\r\n    public dispatchUnregistered() {\r\n        this.logger.info('dispatching unregistered');\r\n        this.manager.onUnregistered(this);\r\n    }\r\n\r\n    public dispatchDownstreamRequest(request: ITrouterRequest) {\r\n        this.logger.debug('dispatching downstream request');\r\n\r\n        try {\r\n            const response = new TrouterResponse(<TrouterRequest>request, new ResponseData(request.id),\r\n                (req: TrouterRequest, responseData: ResponseData) => {\r\n                    this.logger.debug('sending response to downstream');\r\n\r\n                    return this.sendResponse(req, responseData);\r\n                });\r\n            this.manager.onDownstreamRequest(this, request, response);\r\n        } catch (error) {\r\n            this.logger.error(`exception in socket.on message. Error : ${errorStackToJson(error)}`);\r\n        }\r\n    }\r\n\r\n    public dispatchReconnecting() {\r\n        this.logger.info('dispatching reconnecting');\r\n        this.manager.onReconnecting(this);\r\n    }\r\n\r\n    public dispatchReconnectIsRequired(useConnectParamsFromCache: boolean, reason: ReconnectReason) {\r\n        this.logger.info('dispatching reconnect is required by server');\r\n        this.manager.onReconnectIsRequired(this, useConnectParamsFromCache, reason);\r\n    }\r\n\r\n    public dispatchDisconnected() {\r\n        this.logger.info('dispatching disconnected');\r\n        this.manager.onDisconnected(this);\r\n    }\r\n\r\n    public dispatchTerminalError() {\r\n        this.logger.info('dispatching terminal error');\r\n        this.manager.onTerminalError(this);\r\n    }\r\n\r\n    public dispatchTrouterMessageLost(messageLossIndicators: IMessageLossIndicator[]) {\r\n        this.logger.info('dispatching trouter message lost');\r\n        this.manager.onTrouterMessageLost(messageLossIndicators);\r\n    }\r\n\r\n    public countDisconnectBeforeConnectionEstablishment() {\r\n        this.logger.warn('counting disconnect before connection was fully established as a connection failure');\r\n        this.connectingErrorsInRow++;\r\n        if (this.connectingErrorsInRow >= this.connectingErrorsThreshold) {\r\n            this.resetReconnectParamsOnErrorThreshold();\r\n        }\r\n    }\r\n\r\n    public sendProcessedDroppedIndicators(messageLossIndicators: IMessageLossIndicator[]) {\r\n        try {\r\n            this.logger.debug('emitting processed flow tags to the server');\r\n            const processedMessageLossEvent = new DownstreamEvent('trouter.processed_message_loss');\r\n            processedMessageLossEvent.args = { droppedIndicators: messageLossIndicators };\r\n            this.sendDownstreamEvent(processedMessageLossEvent, () => {\r\n                this.logger.info('emitted processed flow tags to the server');\r\n            });\r\n        } catch (error) {\r\n            const msg = errorStackToJson(error);\r\n            this.logger.error(`unable to send processed message loss event. Error: ${msg}`);\r\n            this.connectionTracker.trackError('trouter.processed_message_loss', msg, false);\r\n        }\r\n    }\r\n\r\n    public sendAllocateRequest(token: TokenResult) {\r\n        this.connectionAttempt++;\r\n        this.connectionTracker.trackNewConnection();\r\n\r\n        let url = this.options.trouterUrl;\r\n        let connectParams: Record<string, unknown> | null;\r\n\r\n        let rp = this.reconnectParams;\r\n        const expiration = typeof rp?.se === 'string' ? parseInt(rp.se, 10) : (typeof rp?.se === 'number' ? rp.se : undefined);\r\n        if (expiration && expiration <= Date.now() + 3600000) {  // 1 hour\r\n            this.logger.warn(`Dropping expired cached connection parameters: ${new Date(expiration)}`);\r\n            this.reconnectParams = rp = undefined;\r\n        }\r\n        if (rp && rp.serviceUrl !== url) {\r\n            this.logger.warn(`Dropping cached connection parameters for a different environment (${rp.serviceUrl}, now ${url})`);\r\n            this.reconnectParams = rp = undefined;\r\n        }\r\n        if (rp?.reconnectUrl) {\r\n            url = rp.reconnectUrl;\r\n        }\r\n        if (rp) {\r\n            // Do not append serviceUrl and reconnectUrl as query parameters\r\n            connectParams = { ...rp, serviceUrl: undefined, reconnectUrl: undefined };\r\n        } else {\r\n            connectParams = null;\r\n        }\r\n\r\n        url = adaptUrl(url, 'v4a');\r\n        url = this.appendCorrelationIds(url, false);\r\n        url = this.appendEndpointId(url, false);\r\n        if (connectParams) {\r\n            url += `&${this.buildQuery(connectParams)}`;\r\n            // Currently server doesn't return \"v\" in allocate result, but it\r\n            // can be changed, so implement it this way just in case\r\n            if (!connectParams.v) {\r\n                url += `&v=${VERSION}`;\r\n            }\r\n        }\r\n\r\n        url = this.options.rewriteUrlForProxy(url);\r\n\r\n        const allocateRequest = new Request(url, {\r\n            method: 'POST',\r\n            mode: 'cors',\r\n            headers: new Headers({\r\n                'Content-Type': 'text/plain',\r\n                ...this.options.extraConnectionHeaders,\r\n                ...headersFromToken(token, this.usingLegacyTokenApi),\r\n            })\r\n        });\r\n\r\n        this.logger.info(`sendAllocateRequest: POST ${url}`);\r\n        this.connectionTracker.trackStart('allocation');\r\n        const startTimestamp = Date.now();\r\n        let responseStatusCode = -1;\r\n        let responseClaimsChallenge: string | undefined;\r\n        let responseSkypetokenDeprecated = false;\r\n        fetchWithTimeout(allocateRequest, this.timeoutOptions.fetchTimeoutMs).then((response: Response) => {\r\n            responseStatusCode = response.status;\r\n            if (!response.ok) {\r\n                responseClaimsChallenge = response.headers.get('www-authenticate') ?? undefined;\r\n                responseSkypetokenDeprecated = response.headers.get('x-trouter-skypetoken-deprecated') === '1';\r\n                this.logger.warn(`Allocation request got response status ${response.status}, www-authenticate header was ${responseClaimsChallenge ? 'not empty' : 'empty'}`);\r\n                throw new Error(response.statusText);\r\n            }\r\n\r\n            const contentType = response.headers.get('content-type');\r\n            if (!contentType || (contentType !== 'application/json' && !contentType.startsWith('application/json;'))) {\r\n                throw new Error(`Content-type '${contentType}' is unexpected`);\r\n            }\r\n            this.connectionTracker.trackEnd('allocation');\r\n\r\n            return response.json();\r\n        }).then((responseObj) => {\r\n            this.unauthorizedErrorCount = 0;\r\n            // We perform no parsing/validation of the response received from server\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\r\n            this.onAllocationResponse(responseObj, token);\r\n        }).catch((error: Error) => {\r\n            this.connectingErrorsInRow++;\r\n            const msg = `${error}${responseStatusCode >= 0 ? `, status code ${responseStatusCode}` : ''}`;\r\n            this.logger.error(`${this.connectingErrorsInRow} failed connecting attempt(s) in a row. ${msg}`);\r\n            this.connectionTracker.trackError('allocation', msg);\r\n\r\n            if (responseSkypetokenDeprecated) {\r\n                const errorMessage = 'Skypetoken deprecated response, not retrying any further';\r\n                this.logger.error(errorMessage);\r\n                this.connectionTracker.trackError('allocation', errorMessage);\r\n                this.fsm.onTerminalError();\r\n\r\n                return;\r\n            }\r\n            if (responseStatusCode === 401) {\r\n                this.unauthorizedErrorCount++;\r\n            }\r\n            if (!this.canRetryTokenFetchRequest(this.unauthorizedErrorCount)) {\r\n                const errorMessage = 'getToken retry limit hit, reached terminal error state';\r\n                this.connectionTracker.trackError('allocation', errorMessage);\r\n                this.fsm.onTerminalError();\r\n\r\n                return;\r\n            }\r\n\r\n            if (responseStatusCode === -1 && !this.isNavigatorOnline) {\r\n                this.logger.info('Expected failure, the browser says it is not online at the moment');\r\n            } else if (this.reconnectParams && this.connectingErrorsInRow >= this.connectingErrorsThreshold) {\r\n                if (responseStatusCode >= 400 && responseStatusCode <= 599) {\r\n                    this.resetReconnectParamsOnErrorThreshold();\r\n                } else if (this.reconnectParams.reconnectUrl && this.connectingErrorsInRow % 3 === 0) {\r\n                    this.logger.warn(`${this.connectingErrorsInRow} connection attempts, testing nominal service URL`);\r\n                    // Make sure to finish the check before connection timeout passes to avoid unexpected FSM calls\r\n                    const timeoutMs = Math.min(\r\n                        this.timeoutOptions.connectionTimeoutMs - (Date.now() - startTimestamp) - 500,\r\n                        this.timeoutOptions.fetchTimeoutMs);\r\n                    this.testNominalUrlConnectivity(timeoutMs)\r\n                        .then(result => {\r\n                            this.connectionTracker.trackProgress('nomcheck', result ? 'ok' : 'failed');\r\n                            if (result) {\r\n                                this.logger.warn('Nominal service URL is reachable, erasing cached reconnect URL');\r\n                                if (this.reconnectParams) {\r\n                                    delete this.reconnectParams.reconnectUrl;\r\n                                }\r\n                            } else {\r\n                                this.logger.warn('Nominal service URL is not reachable either, keeping cached reconnect URL');\r\n                            }\r\n\r\n                            this.fsm.onAllocationFailed(false, undefined);\r\n                        }, () => {\r\n                            // Should not happen, but removes no-floating-promises warning\r\n                            this.fsm.onAllocationFailed(false, undefined);\r\n                        });\r\n\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this.fsm.onAllocationFailed(responseStatusCode === 401, responseClaimsChallenge);\r\n        });\r\n    }\r\n\r\n    public testNominalUrlConnectivity(timeoutMs: number): Promise<boolean> {\r\n        if (timeoutMs < 1000) {\r\n            this.logger.warn(`There is no time left to reasonably perform the nominal service URL connectivity check (${timeoutMs} ms), falling back to assuming that the connectivity is fine`);\r\n\r\n            return Promise.resolve(true);\r\n        }\r\n\r\n        let testRequest: Request;\r\n        try {\r\n            const url = new URL(this.options.trouterUrl);\r\n            // Modify the URL to reach the root page (which returns a plain text string \"Trouter\")\r\n            url.pathname = '/';\r\n            // Add a few query parameters for possible classification and troubleshooting\r\n            url.search = '?' + this.buildQuery({\r\n                check: Date.now(),\r\n                cor_id: encodeURIComponent(this.options.clientCorrelationID),\r\n                epid: encodeURIComponent(this.options.endpointId ? this.options.endpointId : ''),\r\n                tc: encodeURIComponent(toJson(this.clientInfo))\r\n            });\r\n            testRequest = new Request(this.options.rewriteUrlForProxy(url.toString()), {\r\n                method: 'GET',\r\n                headers: { Accept: 'text/plain' }\r\n            });\r\n        } catch (error) {\r\n            this.logger.warn(`Nominal service URL connectivity test request could not be created (${error}), falling back to assuming that the connectivity is fine`);\r\n\r\n            return Promise.resolve(true);\r\n        }\r\n\r\n        return fetchWithTimeout(testRequest, timeoutMs)\r\n            .then((response: Response) => {\r\n                if (response.status !== 200) {\r\n                    throw new Error(`Not 200 OK: ${response.status} ${response.statusText}`);\r\n                }\r\n\r\n                return response.text();\r\n            })\r\n            .then((body: string) => {\r\n                if (body !== 'Trouter') {\r\n                    throw new Error(`Not \"Trouter\": ${body.substring(0, 16)}${body.length > 16 ? '...' : ''}`);\r\n                }\r\n\r\n                return true;\r\n            })\r\n            .catch((error) => {\r\n                this.logger.error(`Nominal service URL connectivity test failed: ${error}`);\r\n\r\n                return false;\r\n            });\r\n    }\r\n\r\n    public sendPingRequest() {\r\n        if (this.socket && this.pingResponseTimerId === undefined) {\r\n            try {\r\n                this.logger.debug('emitting ping event');\r\n                let timeoutReached = false;\r\n                this.socket.emit('ping', () => {\r\n                    if (timeoutReached === true) {\r\n                        return;\r\n                    }\r\n                    this.onPingResponse();\r\n                });\r\n                this.pingResponseTimerId = setTimeout(() => {\r\n                    this.logger.error('Ping response timeout is fired');\r\n                    timeoutReached = true;\r\n                    this.clearPingResponseTimer();\r\n                    this.fsm.onPingResponseTimeout();\r\n                }, this.timeoutOptions.pongTimeoutMs);\r\n            } catch (error) {\r\n                const msg = errorStackToJson(error);\r\n                this.logger.error(`unable to send ping. Error: ${msg}`);\r\n                this.connectionTracker.trackError('ping', msg, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    public connectV4c(token: TokenResult, reason?: FallbackReason) {\r\n        const options: ISocketIoOptions = this.options.ioOptions ? { ...this.options.ioOptions } : new SocketIoOptions();\r\n\r\n        // Regardless of any passed in socket.io options, force the following settings.\r\n        options['force new connection'] = true;\r\n        options.reconnect = false;\r\n\r\n        if (\r\n            this.reconnectParams?.serviceUrl &&\r\n            // previous input URL != current input URL (passed via `start()`)\r\n            adaptUrl(this.reconnectParams.serviceUrl, 'v4c') !== adaptUrl(this.options.trouterUrl, 'v4c')\r\n        ) {\r\n            this.logger.warn(`Dropping cached connection parameters for a different environment (${this.reconnectParams.serviceUrl}, now ${this.options.trouterUrl})`);\r\n            this.reconnectParams = undefined;\r\n        }\r\n\r\n        const inputUrl =\r\n            redirectUrlIfPresent(reason) ??\r\n            (reason?.kind !== 'redirect-no-host' ? this.reconnectParams?.reconnectUrl : undefined) ??\r\n            this.options.trouterUrl;\r\n\r\n        const url = adaptUrl(inputUrl, 'v4c');\r\n\r\n        options['skipped handshake data'] = {\r\n            timeout: 70,\r\n            websocketUrl: url\r\n        };\r\n\r\n        options.query = this.buildV4cUrlParams();\r\n        options.rewriteUrlForProxy = this.options.rewriteUrlForProxy;\r\n\r\n        try {\r\n            this.stopSocketIo();\r\n\r\n            this.transportTypeName = 'websocket';\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-assignment\r\n            this.socket = (this.options.io ?? io).connect(this.options.trouterUrl, options);\r\n            if (this.socket === undefined) {\r\n                throw new Error('failed to create Socket.io object');\r\n            }\r\n\r\n            const audienceSubscriptionStateSnapshot = this.audienceSubscriptionState?.increaseCvAndGetEventObject();\r\n\r\n            this.attachSocketIoHandlers(this.socket, token, undefined, audienceSubscriptionStateSnapshot);\r\n        } catch (e: unknown) {\r\n            this.logger.error(`${e}`);\r\n            this.connectionTracker.trackError('v4c', `${e}`);\r\n            this.fsm.onV4cException();\r\n        }\r\n    }\r\n\r\n    public sendV4cAuthenticationEvent(token: TokenResult): void {\r\n        const payload: AnonymousWebsocketAuthentication = {\r\n            headers: {\r\n                ...this.options.extraConnectionHeaders,\r\n                ...headersFromToken(token, this.usingLegacyTokenApi)\r\n            },\r\n            connectparams: reconnectParamsWithoutUrls(this.reconnectParams)\r\n        };\r\n        this.socket?.emit(USER_AUTHENTICATE_EVENT_NAME, payload);\r\n    }\r\n\r\n    public setUserActivityState(userActivityObject: UserActivityObject) {\r\n        const changed: boolean = (userActivityObject.state !== this.userActivityState.state);\r\n        this.userActivityState = userActivityObject;\r\n        if(changed) {\r\n            this.logger.info(`Changing user activity state to '${userActivityObject.toEventJSON()}'`);\r\n            this.fsm.onSetNewUserActivityState();\r\n        } else {\r\n            this.logger.debug(`Not changing the same user activity state '${userActivityObject.toEventJSON()}'`);\r\n            this.manager.onUserActivityStateAccepted(userActivityObject.correlationVector.value());\r\n        }\r\n    }\r\n\r\n    public sendUserActivityState(reason: UserActivityEventReason, connected: boolean) {\r\n        if (this.userActivityState.state === UserActivityState.Unknown) {\r\n            return;\r\n        }\r\n        if (this.transportTypeName === 'websocket' && connected) {\r\n            if (reason === UserActivityEventReason.Connected) {\r\n                this.sendUserActivityStateMultiple(2);\r\n            } else {\r\n                this.sendUserActivityStateMultiple(1);\r\n            }\r\n        } else if (this.transportTypeName === 'xhr-polling') { // ignoring the connected flag\r\n            if (reason === UserActivityEventReason.Modified) {\r\n                this.fsm.forceReconnect('user activity/force reconnect');\r\n            }\r\n        }\r\n    }\r\n\r\n    public setAudienceSubscriptionsAsync(audienceSubscriptionState: AudienceSubscriptionState, timeoutInMs: number): Promise<IAudienceSubscriptionsResponse> {\r\n        const previousAudienceSubscriptionState = this.audienceSubscriptionState;\r\n        this.audienceSubscriptionState = audienceSubscriptionState;\r\n\r\n        if (this.transportTypeName === this.WEBSOCKET_TRANSPORT_NAME) {\r\n            return this.setAudienceSubscriptionsInternalAsync(audienceSubscriptionState.increaseCvAndGetEventObject(), timeoutInMs);\r\n        }\r\n\r\n        if (this.transportTypeName === this.XHR_POLLING_TRANSPORT_NAME) {\r\n            const setAudienceSubscriptionsPromise = this.setAudienceSubscriptionsLongpollInternalAsync(audienceSubscriptionState.increaseCvAndGetEventObject(), timeoutInMs, previousAudienceSubscriptionState);\r\n            this.fsm.forceReconnect('set audience subscription force reconnect');\r\n            return setAudienceSubscriptionsPromise;\r\n        }\r\n\r\n        throw new Error('set audience subscription executed on an unknown transport');\r\n    }\r\n\r\n    private setAudienceSubscriptionsUnsafeAsync(audienceSubscriptionSnapshot?: AudienceSubscriptionSnapshot): Promise<IAudienceSubscriptionsResponse> | undefined {\r\n        if (!audienceSubscriptionSnapshot) {\r\n            return undefined;\r\n        }\r\n\r\n        if (this.transportTypeName === this.WEBSOCKET_TRANSPORT_NAME) {\r\n            return this.setAudienceSubscriptionsInternalAsync(audienceSubscriptionSnapshot, 15000);\r\n        }\r\n    }\r\n\r\n    private async setAudienceSubscriptionsInternalAsync(audienceSubscriptionSnapshot: AudienceSubscriptionSnapshot, timeoutInMs: number): Promise<IAudienceSubscriptionsResponse> {\r\n        this.logger.info('[WebSocket] Audience subscription set requested.');\r\n\r\n        const audienceSubscriptionEvent = new DownstreamEvent('audience.subscribe');\r\n        audienceSubscriptionEvent.args = audienceSubscriptionSnapshot;\r\n\r\n        const result = await new Promise((resolve: (response: IAudienceSubscriptionsResponse) => void) => {\r\n            let hasTimedOut = false;\r\n\r\n            const timeoutId = setTimeout(() => {\r\n                hasTimedOut = true;\r\n                return resolve(this.buildAudienceSubscriptionsTimeoutResponse(audienceSubscriptionSnapshot));\r\n            }, timeoutInMs);\r\n\r\n            this.sendDownstreamEvent(audienceSubscriptionEvent, (_: string, args?: unknown) => {\r\n                if (hasTimedOut) {\r\n                    return;\r\n                }\r\n\r\n                clearTimeout(timeoutId);\r\n                this.logger.debug(`[Websocket] Audience subscription response: ${args}`);\r\n\r\n                if (this.pendingAudienceSubscription) {\r\n                    this.onAudienceSubscriptionResult(args as IAudienceSubscriptionsResponse);\r\n                }\r\n\r\n                resolve(args as IAudienceSubscriptionsResponse);\r\n            });\r\n        });\r\n\r\n        this.manager.onAudiencesSetResolved(result, audienceSubscriptionSnapshot.cv);\r\n        return result;\r\n    }\r\n\r\n    private async setAudienceSubscriptionsLongpollInternalAsync(audienceSubscriptionSnapshot: AudienceSubscriptionSnapshot, timeoutInMs: number, previousSubscriptionState?: AudienceSubscriptionState): Promise<IAudienceSubscriptionsResponse> {\r\n        this.logger.info('[XHR Polling] Audience subscription set requested.');\r\n\r\n        if (this.pendingAudienceSubscription) {\r\n            this.logger.error('Racing audience subscriptions occured. This situation resolves into undefined scenario and/or nasal demons.');\r\n            clearTimeout(this.pendingAudienceSubscription.timeoutId);\r\n        }\r\n\r\n        if (audienceSubscriptionSnapshot.audiences.length === 0) {\r\n            return this.handleAudienceUnsubscribeLongpoll(audienceSubscriptionSnapshot.cv, previousSubscriptionState);\r\n        }\r\n\r\n        const result = await new Promise((resolve: (response: IAudienceSubscriptionsResponse) => void) => {\r\n            const timeoutId = setTimeout(() => {\r\n                this.pendingAudienceSubscription = undefined;\r\n                return resolve(this.buildAudienceSubscriptionsTimeoutResponse(audienceSubscriptionSnapshot));\r\n            }, timeoutInMs);\r\n\r\n            this.pendingAudienceSubscription = {\r\n                audienceSetResolve: resolve,\r\n                timeoutId\r\n            };\r\n        });\r\n\r\n        if (this.manager.getState() === TrouterState.Unknown || this.transportTypeName === this.WEBSOCKET_TRANSPORT_NAME) {\r\n            return result;\r\n        }\r\n\r\n        const currentResponse = result.responses[0];\r\n        if (currentResponse?.result.audienceSubscriptionState === this.AUDIENCE_SUBSCRIPTION_RESULT_BAD_REQUEST) {\r\n            this.clearAudienceSubscriptionStateQueryParam();\r\n\r\n            this.manager.onAudiencesSetResolved(result, audienceSubscriptionSnapshot.cv);\r\n            return result;\r\n        }\r\n\r\n        const currentAudienceResponse = result.responses.find(r => r.audienceId === audienceSubscriptionSnapshot.audiences[0].id);\r\n        if (currentAudienceResponse?.result.audienceSubscriptionState === this.AUDIENCE_SUBSCRIPTION_RESULT_ERROR) {\r\n            this.clearAudienceSubscriptionStateQueryParam();\r\n\r\n            this.manager.onAudiencesSetResolved(result, audienceSubscriptionSnapshot.cv);\r\n            return result;\r\n        }\r\n\r\n        // only notify user abount un-subscription if the target audience actually changed\r\n        const subscribesToDifferentAudience = previousSubscriptionState?.audienceSubscriptionModel.audienceSubscriptions[0]?.id !== currentResponse?.audienceId;\r\n        if (previousSubscriptionState && subscribesToDifferentAudience) {\r\n            const synthResponses = this.mapToSyntheticAudienceSubscriptionResponses(previousSubscriptionState.audienceSubscriptionModel.audienceSubscriptions, this.AUDIENCE_SUBSCRIPTION_RESULT_UNSUBSCRIBED, 200);\r\n            result.responses.push(...synthResponses);\r\n        }\r\n\r\n        this.manager.onAudiencesSetResolved(result, audienceSubscriptionSnapshot.cv);\r\n        return result;\r\n    }\r\n\r\n    // remove the `audienceSubscriptionState` param from longpoll query string so the subscription is not attempted over and over creating loop\r\n    private clearAudienceSubscriptionStateQueryParam() {\r\n        if (this.socket?.socket?.options?.query) {\r\n            this.socket.socket.options.query = this.socket.socket.options.query.replace(this.AUDIENCE_SUBSCRIPTION_STATE_QUERY_PARAM_REGEX, '');\r\n        }\r\n    }\r\n\r\n    private handleAudienceUnsubscribeLongpoll(correlationVector: string, previousSubscriptionState?: AudienceSubscriptionState): IAudienceSubscriptionsResponse {\r\n        this.audienceSubscriptionState = undefined;\r\n\r\n        const result = {\r\n            responses: []\r\n        } as IAudienceSubscriptionsResponse;\r\n\r\n        if (previousSubscriptionState) {\r\n            const synthResponses = this.mapToSyntheticAudienceSubscriptionResponses(previousSubscriptionState.audienceSubscriptionModel.audienceSubscriptions, this.AUDIENCE_SUBSCRIPTION_RESULT_UNSUBSCRIBED, 200);\r\n            result.responses.push(...synthResponses);\r\n        }\r\n\r\n        this.manager.onAudiencesSetResolved(result, correlationVector);\r\n        return result;\r\n    }\r\n\r\n    private buildAudienceSubscriptionsTimeoutResponse(audienceSubscriptionSnapshot: AudienceSubscriptionSnapshot) {\r\n        this.logger.error(\"Audience subscription attempt has timed out.\");\r\n\r\n        return {\r\n            responses: this.mapToSyntheticAudienceSubscriptionResponses(audienceSubscriptionSnapshot.audiences, this.AUDIENCE_SUBSCRIPTION_RESULT_TIMEOUT)\r\n        } as IAudienceSubscriptionsResponse;\r\n    }\r\n\r\n    private mapToSyntheticAudienceSubscriptionResponses(audiences: IAudienceSubscription[], synthState: string, synthResponseStatus?: number): IAudienceSubscriptionResponse[] {\r\n        return audiences\r\n            .map(audSub => ({\r\n                audienceId: audSub.id,\r\n                result: {\r\n                    audienceSubscriptionState: synthState,\r\n                    responseStatus: synthResponseStatus\r\n                } as AudienceSubscriptionResult\r\n            } as IAudienceSubscriptionResponse));\r\n    }\r\n\r\n    public expediteBackoff() {\r\n        this.tokenBackoff.expediteIfPending();\r\n    }\r\n\r\n    public sendRegisterRequest() {\r\n        if (!this.options.registration || !this.registrarClient) {\r\n            throw new Error('Internal error - options.registration is undefined');\r\n        }\r\n        if (!this.allocateResult) {\r\n            throw new Error('Allocate result is undefined in sendRegisterRequest()');\r\n        }\r\n\r\n        this.logger.info('sending register request');\r\n        const span = new Timespan();\r\n        this.connectionTracker.trackStart('registration');\r\n        const [registrationTtl,] = this.getRegistrationTtl();\r\n        this.registrarClient.register({\r\n            appId: this.options.registration.pnhAppId,\r\n            aesKey: '',\r\n            languageId: 'en-US',\r\n            platform: this.options.registration.platform,\r\n            templateKey: this.options.registration.pnhTemplateKey,\r\n            platformUIVersion: this.options.registration.platformUIVersion,\r\n            productContext: this.options.registration.productContext\r\n        }, {\r\n            TROUTER: [{\r\n                context: this.options.registration.context,\r\n                path: this.allocateResult.surl,\r\n                ttl: registrationTtl\r\n            }]\r\n        }).then(() => {\r\n            this.logger.info('Register request successful');\r\n            this.connectionTracker.trackEnd('registration');\r\n            this.fsm.onRegistrationSucceeded();\r\n            this.connectionTracker.sendTelemetry(ClientEventName.Registration, {\r\n                duration: span.duration\r\n            }, []);\r\n        }).catch(error => {\r\n            this.logger.error(`Register request failed. Error: ${error}`);\r\n            this.connectionTracker.trackError('registration', errorMessageToString(error));\r\n            this.fsm.onRegistrationFailed();\r\n            this.connectionTracker.sendTelemetry(ClientEventName.Registration, {\r\n                duration: span.duration\r\n            }, []);\r\n        });\r\n    }\r\n\r\n    public sendUnregisterRequest() {\r\n        this.logger.info('sending unregister request');\r\n        const span = new Timespan();\r\n        if (!this.options.registration || !this.registrarClient) {\r\n            throw new Error('Internal error - options.registration is undefined');\r\n        }\r\n\r\n        this.connectionTracker.trackStart('unregistration');\r\n        this.registrarClient.unregister().then(() => {\r\n            this.logger.info('Unregister request successful');\r\n            this.connectionTracker.trackEnd('unregistration');\r\n            this.fsm.onUnregistrationDone();\r\n            this.connectionTracker.sendTelemetry(ClientEventName.Unregistration, {\r\n                duration: span.duration\r\n            }, []);\r\n        }).catch(error => {\r\n            this.logger.error(`Unregister request failed. Error: ${error}`);\r\n            this.connectionTracker.trackError('unregistration', errorMessageToString(error));\r\n\r\n            // The Registrar Client library already does internal retries on 5xx HTTP responses etc.\r\n            // So if we end up here, something more exceptional must have happened. There is little\r\n            // point delaying the stopping further by trying again, just finish as if successful.\r\n            this.fsm.onUnregistrationDone();\r\n\r\n            this.connectionTracker.sendTelemetry(ClientEventName.Unregistration, {\r\n                duration: span.duration\r\n            }, []);\r\n        });\r\n    }\r\n\r\n    public resetTokenBackoff() {\r\n        this.tokenBackoff.reset();\r\n    }\r\n\r\n    public cancelPendingRegistrationRequests() {\r\n        if (this.registrarClient) {\r\n            this.registrarClient.cancelPendingRequests();\r\n        }\r\n    }\r\n\r\n    public clearSentEventTimers() {\r\n        const keys = Object.keys(this.pendingSentEventTimers);\r\n        if (keys.length > 0) {\r\n            this.logger.debug('Clearing all pending downstream events related timers');\r\n            for (const key of keys) {\r\n                this.clearSentEventTimer(<Timeout><unknown>Number(key));\r\n            }\r\n        }\r\n    }\r\n\r\n    public restartIncallModeTimer() {\r\n        this.clearIncallModeTimerId();\r\n        this.logger.debug('Restarting incall mode timer');\r\n        this.incallModeTimerId = setTimeout(() => {\r\n            this.logger.info('Call mode timer fired');\r\n            this.fsm.onIncallModeTimer();\r\n        }, this.options.incallModeTimeoutMs);\r\n    }\r\n\r\n    public enterIncallMode() {\r\n        this.logger.info('Entering incall mode');\r\n        this.timeoutOptions = this.options.incallTimeoutOptions;\r\n        this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs);\r\n        // Uncomment to enable change of timeout in XHR mode - do it once server start to support it\r\n        // if (this.socket) {\r\n        //     this.socket.socket.options.query = this.buildSocketIoUrlParams();\r\n        // }\r\n        this.inIncallMode = true;\r\n    }\r\n\r\n    public exitIncallMode() {\r\n        this.logger.info('Exiting incall mode');\r\n        this.clearIncallModeTimerId();\r\n        this.timeoutOptions = this.options.timeoutOptions;\r\n        this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs);\r\n        // Uncomment to enable change of timeout in XHR mode - do it once server start to support it\r\n        // if (this.socket) {\r\n        //     this.socket.socket.options.query = this.buildSocketIoUrlParams();\r\n        // }\r\n        this.inIncallMode = false;\r\n    }\r\n\r\n    public isIncallMode() {\r\n        return this.inIncallMode;\r\n    }\r\n\r\n    public sendDisconnectTelemetryEvent(reason?: string) {\r\n        const props = <Properties>{ reason: reason, serverClosed: !this.fsm.isActive() };\r\n        this.connectionTracker.trackDisconnected(props);\r\n        this.connectionTracker.clearConnectedInfo();\r\n    }\r\n\r\n    public forceReconnectDueToNoRegistration() {\r\n        this.fsm.forceReconnect('force reconnect due to no registration');\r\n    }\r\n\r\n    private resetReconnectParamsOnErrorThreshold() {\r\n        this.logger.warn(`${this.connectingErrorsInRow} connection attempts, server-side failure: erasing cached connection parameters`);\r\n        this.reconnectParams = undefined;\r\n    }\r\n\r\n    ////////// SocketIO callbacks //////////\r\n    private onSocketConnecting(transportTypeName: string) {\r\n        this.logger.info(`onSocketConnecting(${transportTypeName})`);\r\n        this.transportTypeName = transportTypeName;\r\n        this.connectionTracker.trackProgress('connecting', this.transportTypeName);\r\n        this.fsm.onConnecting();\r\n    }\r\n    private onSocketConnect(token: TokenResult) {\r\n        this.logger.info('onSocketConnect');\r\n        this.fsm.onSocketConnect(token);\r\n    }\r\n    private onSocketConnectFailed(reason: string): void {\r\n        this.logger.error('onSocketConnectFailed');\r\n        this.connectionTracker.trackError(\r\n            'connect_failed', reason, true, this.transportTypeName ? this.transportTypeName : this.UNKNOWN_TRANSPORT);\r\n        this.fsm.onConnectingFailed();\r\n    }\r\n    private onSocketDisconnect(rawReason: string): void {\r\n        const sessionLengthMs = this.connectionTracker.getSessionLength() || 0;\r\n        const reason = DisconnectReason.fromRawReason(rawReason);\r\n\r\n        this.logger.error(`onSocketDisconnect, reason: ${reason.reason}`);\r\n\r\n        if (reason.reason === 'dup' && this.lastDisconnectReason === 'dup' &&\r\n            sessionLengthMs < this.options.duplicateDisconnectThresholdMs) {\r\n            this.logger.warn(\r\n                'Socket was closed by server as Duplicate for the second time in a row ' +\r\n                `after ${sessionLengthMs} ms which is below the threshold of ` +\r\n                `${this.options.duplicateDisconnectThresholdMs} ms. Resetting cached ` +\r\n                'connection parameters and making a new allocation.');\r\n            this.reconnectParams = undefined;\r\n        }\r\n        this.lastDisconnectReason = reason.reason;\r\n\r\n        this.fsm.onSocketDisconnect(reason);\r\n        this.connectionExpireTimestampInSecs = undefined;\r\n    }\r\n\r\n    private onSocketReconnect(): void {\r\n        // this callback should not be called, because reconnect on socket.io is disabled, but\r\n        // leave it here in case error in socket.io\r\n        this.logger.error('onSocketReconnect');\r\n        this.fsm.onTrouterConnected();\r\n    }\r\n    private onSocketReconnectFailed(reason: unknown): void {\r\n        // this callback should not be called, because reconnect on socket.io is disabled, but\r\n        // leave it here in case error in socket.io\r\n        this.logger.error(`onSocketReconnectFailed with '${reason}'`);\r\n        this.fsm.onSocketDisconnect(DisconnectReason.fromSocketIoEventData('reconnecterror', reason));\r\n    }\r\n    private onSocketReconnecting(): void {\r\n        // this callback should not be called, because reconnect on socket.io is disabled, but\r\n        // leave it here in case error in socket.io\r\n        this.logger.error('onSocketReconnecting');\r\n    }\r\n    private onSocketError(errorObject: unknown): void {\r\n        this.logger.error(`onSocketError with '${toJson(errorObject)}'`);\r\n        if (this.fsm.isConnecting()) {\r\n            this.connectingErrorsInRow++;\r\n            if (this.connectingErrorsInRow >= this.connectingErrorsThreshold) {\r\n                this.resetReconnectParamsOnErrorThreshold();\r\n            }\r\n        }\r\n        this.connectionTracker.trackError('connectSocket', safeToStringOrType(errorObject));\r\n        this.fsm.onSocketDisconnect(DisconnectReason.fromSocketIoEventData('socketerror', errorObject));\r\n    }\r\n    private onSocketMessage(requestJson: string): void {\r\n        this.logger.debug('onSocketMessage');\r\n\r\n        let request: TrouterRequest;\r\n        try {\r\n            request = new TrouterRequest(requestJson, this.logger);\r\n            const chainId = request.headers?.['X-Microsoft-Skype-Chain-ID'];\r\n            const chainIdLogText = chainId ? ` Chain-Id ${chainId}` : '';\r\n            this.logger.info(`Received request N ${request.id}${chainIdLogText} CV ${request.correlationVector} to '${request.url}'`);\r\n            request.startTS = Date.now();\r\n\r\n            if (request.url && this.urlPath && request.url.startsWith(this.urlPath)) {\r\n                request.shortUrl = request.url.substring(this.urlPath.length);\r\n            }\r\n        } catch (error) {\r\n            const msg = errorStackToJson(error);\r\n            this.logger.error(`unable to parse request. Error: ${msg}`);\r\n            this.connectionTracker.trackRequest(undefined, msg);\r\n            this.connectionTracker.sendResponseError(`unable to parse request, error: ${error}`);\r\n\r\n            return;\r\n        }\r\n\r\n        request.timeoutTimerId = setTimeout(() => {\r\n            if (request.replied) {\r\n                return;\r\n            }\r\n            this.logger.error(`Request ${request.id} timed out`);\r\n            const responseData = new ResponseData(request.id);\r\n            responseData.status = 504;\r\n            responseData.headers = { 'Trouter-Responder': 'ClientLib' };\r\n            this.sendResponse(request, responseData);\r\n            request.timedout = true;\r\n        }, this.timeoutOptions.requestTimeoutMs);\r\n\r\n        try {\r\n            this.connectionTracker.trackRequest(request);\r\n            this.fsm.onDownstreamRequest(request);\r\n        } catch (error) {\r\n            this.logger.error(`exception in socket.on message. Error: ${errorStackToJson(error)}`);\r\n            this.connectionTracker.sendResponseError(errorMessageToString(error), request, undefined);\r\n        }\r\n    }\r\n    private onTrouterConnected(\r\n        eventArgs: ITrouterConnectedEventArgs | ITrouterConnectedEventArgsV4c,\r\n        userActivitySnapshot?: UserActivitySnapshot,\r\n        audienceSubscriptionSnapshot?: AudienceSubscriptionSnapshot\r\n    ): void {\r\n        if (isV4ConnectEvent(eventArgs)) {\r\n            const v4cArgs = <ITrouterConnectedEventArgsV4c>eventArgs;\r\n            this.allocateResult = { ...v4cArgs, ttl: eventArgs.ttl.toString() };\r\n            this.populateAndCacheReconnectParams(v4cArgs, v4cArgs.reconnectUrl);\r\n            this.populateConnectionStateFields(v4cArgs);\r\n        } else if (!this.allocateResult) {\r\n            this.logger.error('Invalid internal state - received onTrouterConnected while allocateResult is not set');\r\n\r\n            return;\r\n        }\r\n\r\n        this.connectingErrorsInRow = 0;\r\n        this.logger.info(`onTrouterConnected: ${this.allocateResult.url}`);\r\n\r\n        if (this.transportTypeName === 'xhr-polling' && userActivitySnapshot) {\r\n            this.manager.onUserActivityStateAccepted(userActivitySnapshot.cv);\r\n        }\r\n\r\n        // Prevent next 'trouter.connected' responses from other trouter nodes\r\n        // hackish way, since socket.io doesn't have API for that\r\n        if (this.socket?.socket?.options?.query) {\r\n            this.socket.socket.options.query += '&connected=true';\r\n        }\r\n\r\n        // Strip off the first part of the URL, up to the path\r\n        // eslint-disable-next-line no-useless-escape\r\n        this.urlPath = this.allocateResult.url.replace(/https?:\\/\\/([A-z0-9\\:\\$\\-\\_\\.\\+\\!\\*\\\"\\(\\)\\,]*)\\//, '/');\r\n\r\n        const isNewUrl = (this.connectedUrl !== this.allocateResult.url);\r\n        this.connectedUrl = this.allocateResult.url;\r\n        this.connectionExpireTimestampInSecs = calculateExpireTsInSec(ensureNumber(eventArgs.ttl));\r\n\r\n        this.connectionTracker.trackEnd('connectSocket');\r\n        this.connectionTracker.trackConnected(isNewUrl, this.transportTypeName ? this.transportTypeName : this.UNKNOWN_TRANSPORT);\r\n\r\n        this.setAudienceSubscriptionsUnsafeAsync(audienceSubscriptionSnapshot)?.catch(reason => this.logger.error(`Re-subscribe to audiences has failed with ${reason}`));\r\n\r\n        this.fsm.onTrouterConnected();\r\n    }\r\n\r\n    private onTrouterReconnect(eventArgs: ITrouterReconnectEventArgs): void {\r\n        const target = eventArgs.target;\r\n\r\n        this.logger.info(`onTrouterReconnect target: ${target}`);\r\n\r\n        if (target === 'self') {\r\n            this.fsm.onReconnectRequired(true, ReconnectReason.ServerInitiated);\r\n        } else {\r\n            this.fsm.onReconnectRequired(false, ReconnectReason.ServerInitiated, eventArgs);\r\n        }\r\n    }\r\n\r\n    private onTrouterMessageLoss(eventArgs: ITrouterMessageLossEventArgs): void {\r\n        this.logger.debug('onTrouterMessageLoss');\r\n\r\n        // Send only array of tags for further processing\r\n        this.fsm.onTrouterMessageLost(eventArgs.droppedIndicators);\r\n    }\r\n\r\n    private onAudienceSubscriptionResult(eventArgs: IAudienceSubscriptionsResponse): void {\r\n        this.logger.info('onAudienceSubscriptionResult');\r\n\r\n        if (!this.pendingAudienceSubscription) {\r\n            return;\r\n        }\r\n\r\n        clearTimeout(this.pendingAudienceSubscription.timeoutId);\r\n        this.pendingAudienceSubscription.audienceSetResolve(eventArgs);\r\n        this.pendingAudienceSubscription = undefined;\r\n    }\r\n\r\n    ////////// Other functions //////////\r\n\r\n    private buildV4cUrlParams(): string {\r\n        const urlParams: Record<string, string | number> = {};\r\n\r\n        urlParams.tc = encodeURI(toJson(this.clientInfo));\r\n        urlParams.timeout = Math.floor(this.timeoutOptions.pingTimeoutMs / 1000);\r\n\r\n        if (this.options.endpointId) {\r\n            urlParams.epid = this.options.endpointId;\r\n        }\r\n\r\n        return this.appendConnectedClientIds(this.buildQuery(urlParams), true);\r\n    }\r\n\r\n    private attachSocketIoHandlers(socket: ISocketIo, token: TokenResult, userActivitySnapshot?: UserActivitySnapshot, audienceSubscriptionSnapshot?: AudienceSubscriptionSnapshot) {\r\n        socket.on('connecting', (transportTypeName: string) => { this.onSocketConnecting(transportTypeName); });\r\n        socket.on('connect', () => { this.onSocketConnect(token); });\r\n        socket.on('connect_failed', (reason: string) => { this.onSocketConnectFailed(reason); });\r\n        socket.on('close_during_connecting', (reason: string) => { this.onSocketConnectFailed(reason); });\r\n        socket.on('disconnect', (reason: string) => { this.onSocketDisconnect(reason); });\r\n        socket.on('reconnect', () => { this.onSocketReconnect(); });\r\n        socket.on('reconnect_failed', (reason: unknown) => { this.onSocketReconnectFailed(reason); });\r\n        socket.on('reconnecting', () => { this.onSocketReconnecting(); });\r\n        socket.on('error', (error: unknown) => { this.onSocketError(error); });\r\n        socket.on('message', (request: string) => { this.onSocketMessage(request); });\r\n        socket.on('trouter.connected',\r\n            (eventArgs: ITrouterConnectedEventArgs) => { this.onTrouterConnected(eventArgs, userActivitySnapshot, audienceSubscriptionSnapshot); });\r\n        socket.on('trouter.reconnect',\r\n            (eventArgs: ITrouterReconnectEventArgs) => { this.onTrouterReconnect(eventArgs); });\r\n        socket.on('trouter.message_loss',\r\n            (eventArgs: ITrouterMessageLossEventArgs) => { this.onTrouterMessageLoss(eventArgs); });\r\n\r\n        // event valid only for long polling\r\n        // when user subscribes for audience events a query param `audienceSubscriptionState` is added to all long poll GETs \r\n        // if the audience subscription state differs from the one defined on server, it will adjust its state to be identical\r\n        // after audience set opeartion finished server side `audience.subscriptionresult` is fired marking the end of asynchronous operation\r\n        socket.on('audience.subscriptionresult',\r\n            (_: string, eventArgs: IAudienceSubscriptionsResponse) => { this.onAudienceSubscriptionResult(eventArgs); });\r\n    }\r\n\r\n    private onNavigatorOnlineStatusUpdate() {\r\n        const state = window.navigator.onLine;\r\n        this.logger.debug(`Browser online status update - new state: ${state}, previously: ${this.isNavigatorOnline}`);\r\n        if (state && !this.isNavigatorOnline) {\r\n            this.isNavigatorOnline = true;\r\n            this.tokenBackoff.expediteIfPending();\r\n            this.connectionTracker.trackProgress('browserNet', 'online');\r\n        } else if (!state && this.isNavigatorOnline) {\r\n            this.isNavigatorOnline = false;\r\n            this.connectionTracker.trackProgress('browserNet', 'offline');\r\n        }\r\n    }\r\n\r\n    private onAllocationResponse(allocateResult: IAllocateResult, token: TokenResult) {\r\n        this.logger.info(`Received allocation response ${JSON.stringify(allocateResult)}`);\r\n        this.allocateResult = allocateResult;\r\n        this.populateAndCacheReconnectParams(this.allocateResult, `${this.allocateResult.socketio}v4/a`);\r\n        this.populateConnectionStateFields(this.allocateResult);\r\n        this.fsm.onAllocationSucceed(token);\r\n    }\r\n\r\n    private populateAndCacheReconnectParams(args: ITrouterConnectedEventArgsV4c | IAllocateResult, reconnectUrl: string) {\r\n        this.reconnectParams = {\r\n            serviceUrl: this.options.trouterUrl,\r\n            reconnectUrl,\r\n            ...args.connectparams\r\n        };\r\n        this.manager.onConnectionParametersUpdated(this.reconnectParams);\r\n    }\r\n\r\n    private populateConnectionStateFields(args: IAllocateResult | ITrouterConnectedEventArgsV4c) {\r\n        const ttl: number = typeof args.ttl === 'string' ? parseInt(args.ttl, 10) : args.ttl;\r\n        // Don't use allocateResult.connectparams.se here since system clock can be\r\n        // incorrect on client's machine, so using TTL is safer\r\n        this.connectionExpireTimestampInSecs = calculateExpireTsInSec(ttl);\r\n        this.connectionId = args.id ?? '';\r\n\r\n        this.connectedClientId = args.ccid;\r\n        this.logger.debug(`connected client id set {connectedClientId:${this.connectedClientId}}`);\r\n\r\n        this.c2cUrlBase = args.curlb ?? '';\r\n        if (this.c2cUrlBase === '') {\r\n            // Try to just remove the port as a fallback if the service didn't provide anything\r\n            let pos = args.surl.indexOf('://');\r\n            if (pos >= 0) {\r\n                pos = args.surl.indexOf('/', pos + 3);\r\n                if (pos >= 5 && args.surl.substr(pos - 5, 5) === ':3443') {\r\n                    this.c2cUrlBase = args.surl.substr(0, pos - 5);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onPingResponse() {\r\n        this.logger.debug('onPingResponse');\r\n        this.connectionTracker.increasePingResponseCount();\r\n        this.clearPingResponseTimer();\r\n        this.fsm.onPingResponse();\r\n    }\r\n\r\n    private clearPingResponseTimer() {\r\n        if (this.pingResponseTimerId !== undefined) {\r\n            clearTimeout(this.pingResponseTimerId);\r\n            this.pingResponseTimerId = undefined;\r\n        }\r\n    }\r\n\r\n    private buildQuery(map: Record<string, unknown>): string {\r\n        // TO-DO: Replace this and all other similar functions around with URLSearchParams\r\n        const components: string[] = [];\r\n        for (const i of Object.keys(map)) {\r\n            if (map[i] !== undefined) {\r\n                components.push(`${i}=${map[i]}`);\r\n            }\r\n        }\r\n\r\n        return components.join('&');\r\n    }\r\n\r\n    private appendConnectedClientIds(url: string, isParamsOnly: boolean) {\r\n        let params = '';\r\n        if (!url.includes('ccid=')) {\r\n            params = `ccid=${this.connectedClientId}&`;\r\n        }\r\n        if (this.domId) {\r\n            params += `dom=${this.domId}&`;\r\n        }\r\n        if (params.length > 0) {\r\n            params = params.slice(0, -1);\r\n        }\r\n        const sep = (isParamsOnly || url.includes('?')) ? ('&') : ('?');\r\n\r\n        return this.appendCorrelationIds(url + sep + params, isParamsOnly);\r\n    }\r\n\r\n    private appendEndpointId(url: string, isParamsOnly: boolean): string {\r\n        const sep = (isParamsOnly || url.includes('?')) ? ('&') : ('?');\r\n\r\n        return (!url.includes('epid') && this.options.endpointId)\r\n            ? `${url}${sep}epid=${this.options.endpointId}`\r\n            : url;\r\n    }\r\n\r\n    private appendCorrelationIds(url: string, isParamsOnly: boolean): string {\r\n        const sep = (isParamsOnly || url.includes('?')) ? ('&') : ('?');\r\n\r\n        return (!url.includes('cor_id'))\r\n            ? `${url}${sep}cor_id=${this.options.clientCorrelationID}`\r\n            + `&con_num=${this.clientID}_${this.connectionAttempt}`\r\n            : url;\r\n    }\r\n\r\n    private safeString(str: unknown): string {\r\n        return (typeof str === 'string') ? str : '';\r\n    }\r\n\r\n    private sendResponse(request: TrouterRequest, responseData: ResponseData): SendResponseResult {\r\n        if (request.timedout) {\r\n            this.logger.error(`Request ${request.id} already timed out`);\r\n\r\n            return SendResponseResult.Timeout;\r\n        }\r\n        if (request.replied) {\r\n            this.logger.error(`Response for request ${request.id} already sent`);\r\n\r\n            return SendResponseResult.Duplicate;\r\n        }\r\n        clearTimeout(request.timeoutTimerId);\r\n        request.timeoutTimerId = undefined;\r\n        request.replied = true;\r\n\r\n        responseData.headers = responseData.headers ?? {};\r\n\r\n        const cv = request.correlationVector;\r\n        this.logger.info(`Sending response N ${request.id} CV ${cv} with status ${responseData.status}`);\r\n        if (cv) {\r\n            responseData.headers[cvHeader] = cv;\r\n        }\r\n\r\n        // Echo back the incoming \"trouter-request\" header\r\n        if (request.headers?.['trouter-request']) {\r\n            responseData.headers['trouter-request'] = request.headers['trouter-request'];\r\n        }\r\n        // Fill in \"trouter-client\" header\r\n        const latencyMS = Date.now() - request.startTS;\r\n        responseData.headers['trouter-client'] = toJson({\r\n            cd: latencyMS\r\n        });\r\n\r\n        // Echo back \"trouter-is-broadcast\" header\r\n        if (request.headers?.['trouter-is-broadcast']) {\r\n            responseData.headers['trouter-is-broadcast'] = request.headers['trouter-is-broadcast'];\r\n        }\r\n\r\n        this.logger.debug(`response: ${toJson(responseData)}`);\r\n\r\n        if (this.socket) {\r\n            try {\r\n                this.socket.send(toJson(responseData));\r\n                responseData.sentTS = Date.now();\r\n                request.incrementCorrelationVector();\r\n                this.connectionTracker.trackResponse(request, latencyMS, responseData);\r\n                if (this.transportTypeName === 'websocket') {\r\n                    // Send ping request immediately to emulate 'ack' from server, so\r\n                    // client can faster react on network issues\r\n                    this.sendPingRequest();\r\n                }\r\n\r\n                return SendResponseResult.OK;\r\n            } catch (error) {\r\n                const errorMsg = `unable to send data on response.end. Error: ${errorStackToJson(error)}`;\r\n                this.logger.error(errorMsg);\r\n                this.connectionTracker.sendResponseError(errorMsg, request, responseData);\r\n\r\n                return SendResponseResult.Disconnected;\r\n            }\r\n        } else {\r\n            this.connectionTracker.sendResponseError('no socket', request, responseData);\r\n\r\n            return SendResponseResult.Disconnected;\r\n        }\r\n    }\r\n\r\n    /*\r\n        Sends the activity state event to Trouter.\r\n        Has implemented support for sending the current state twice (or multiple times)\r\n        after reconnect, first immediately, and theen the second after configured delay.\r\n\r\n        If after the first sent state event the client app changes the state,\r\n        the new state is sent in the second event after the delay.\r\n        Meanwhile the new state is also sent immediately upon\r\n        the change, but the planned second sending (after delay) is triggered anyway,\r\n        to fulfill it's purpose, which is to prevent server-side race condition.\r\n     */\r\n    private sendUserActivityStateMultiple(remaining: number): void {\r\n        const activityEvent = new DownstreamEvent('user.activity');\r\n        const activityEventObject = this.userActivityState.increaseCvAndGetEventObject();\r\n        activityEvent.args = activityEventObject;\r\n\r\n        this.logger.debug(`Sending user activity '${this.userActivityState.toEventJSON()}', remaining ${remaining - 1}`);\r\n        let timeoutReached = false;\r\n        this.sendDownstreamEvent(activityEvent, () => {\r\n            if (timeoutReached === true) {\r\n                return;\r\n            }\r\n            this.logger.info(`User activity state: ${activityEventObject.state}, cv: ${activityEventObject.cv} accepted`);\r\n            this.manager.onUserActivityStateAccepted(activityEventObject.cv);\r\n            this.clearSentEventTimer(activityEvent.timeoutTimerId);\r\n            if (remaining > 1) {\r\n                const timerId = setTimeout(() => {\r\n                    this.clearSentEventTimer(timerId);\r\n                    this.sendUserActivityStateMultiple(remaining - 1);\r\n                }, this.options.userActivitySecondResendDelayMs);\r\n                this.registerSentEventTimer(timerId, 'user.activity/resend');\r\n            }\r\n        });\r\n\r\n        activityEvent.timeoutTimerId = setTimeout(() => {\r\n            this.logger.error('Activity state response timeout is fired');\r\n            timeoutReached = true;\r\n            this.fsm.onActivityStateResponseTimeout();\r\n            this.clearSentEventTimer(activityEvent.timeoutTimerId);\r\n        }, this.timeoutOptions.userActivityResponseTimeoutMs);\r\n        this.registerSentEventTimer(activityEvent.timeoutTimerId, 'user.activity/response');\r\n    }\r\n\r\n    private sendDownstreamEvent(event: DownstreamEvent, responseCallback: (name: string, args?: unknown) => void) {\r\n        this.logger.debug(`Sending downstream event ${event.name}`);\r\n\r\n        if (this.socket) {\r\n            this.socket.emit(event.name, event.args, responseCallback);\r\n        }\r\n    }\r\n\r\n    private registerSentEventTimer(timerId: Timeout, timerDescription: string): void {\r\n        this.logger.debug(`registering timer ${timerId} -> ${timerDescription}`);\r\n        this.pendingSentEventTimers[<number><unknown>timerId] = timerDescription;\r\n    }\r\n\r\n    private clearSentEventTimer(id: Timeout): void {\r\n        const timerDescription: string = this.pendingSentEventTimers[<number><unknown>id];\r\n        this.logger.debug(`clearing timer ${id} -> ${timerDescription}`);\r\n        delete this.pendingSentEventTimers[<number><unknown>id];\r\n        clearTimeout(id);\r\n    }\r\n\r\n    /**\r\n     * Calculate registration interval. Result is based on configuration parameters\r\n     * and allocation ttl value from trouter server.\r\n     * Returns true only if the registration ttl is present and is smaller than known `allocationTtl`.\r\n     * This means we'll need to re-register to keep the registration alive for the duration of the allocation.\r\n     */\r\n    private getRegistrationTtl(): [number, boolean] {\r\n        const allocationTtl = calculateTtlInSec(this.connectionExpireTimestampInSecs);\r\n        this.logger.debug(`Current connectionID will expire in ${allocationTtl} seconds`);\r\n\r\n        if (this.options.registration?.registrarTtlSec && allocationTtl > 0) {\r\n            const isLower: boolean = this.options.registration.registrarTtlSec < allocationTtl;\r\n\r\n            return [Math.min(this.options.registration.registrarTtlSec, allocationTtl), isLower];\r\n        } else if (this.options.registration?.registrarTtlSec) {\r\n            return [this.options.registration.registrarTtlSec, false];\r\n        } else if (allocationTtl > 0) {\r\n            return [allocationTtl, false];\r\n        }\r\n\r\n        return [DEFAULT_REGISTRATION_TIMEOUT_SEC, false];\r\n    }\r\n\r\n    private clearIncallModeTimerId() {\r\n        if (this.incallModeTimerId !== undefined) {\r\n            this.logger.debug('Clearing in-call mode timer');\r\n            clearTimeout(this.incallModeTimerId);\r\n            this.incallModeTimerId = undefined;\r\n        }\r\n    }\r\n\r\n    private applyConnectionTrackerOptions(options: ITrouterOptions) {\r\n        try {\r\n            const eventLoggerSent = (options.eventLogger && typeof options.eventLogger.logEvent === 'function');\r\n            if (!eventLoggerSent) {\r\n                this.logger.warn('Trouter client event logging disabled due to invalid configuration.');\r\n            } else {\r\n                this.connectionTracker.mergeSettings(options.telemetrySettings);\r\n                this.connectionTracker.enable(options.eventLogger);\r\n            }\r\n        } catch (error) {\r\n            this.logger.warn(`Trouter client event logging disabled. Error: ${errorStackToJson(error)}`);\r\n            this.connectionTracker.disable();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns boolean indicating if we can retry token fetch\r\n     * based on value of optional configuration 'retryLimitOnTokenFetch'\r\n     * @returns boolean\r\n     */\r\n    private canRetryTokenFetchRequest(currentCounter: number) {\r\n        const retryLimit = this.options.retryLimitOnTokenFetch;\r\n\r\n        if (retryLimit === null || retryLimit === undefined) {\r\n\r\n            return true;\r\n        }\r\n\r\n        if (currentCounter < retryLimit) {\r\n\r\n            return true;\r\n        }\r\n\r\n        this.logger.warn(\r\n            `Reached limit on maximum number of token fetch request. Current count: ${currentCounter}, retry limit: ${retryLimit}`\r\n        );\r\n\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction headersFromToken(token: TokenResult, usingLegacyTokenApi: boolean): Record<string, string> {\r\n    const migrationHeader = usingLegacyTokenApi ? undefined : { 'X-MS-Migration': 'True' };\r\n    switch (token.tokenType.toLowerCase()) {\r\n        case 'skype':\r\n            return { 'X-Skypetoken': token.token, ...migrationHeader };\r\n\r\n        case 'aad':\r\n        case 'cae':\r\n            return { Authorization: `Bearer ${token.token}`, ...migrationHeader };\r\n\r\n        default:\r\n            throw new Error(`unsupported token type: ${token.tokenType}`);\r\n    }\r\n}\r\n\r\nfunction safeToStringOrType(value: unknown): string {\r\n    if (value !== undefined && value !== null && typeof value.toString === 'function') {\r\n        return value.toString();\r\n    }\r\n    return `[${typeof value}]`;\r\n}\r\n\r\nfunction errorStackToJson(error: unknown): string {\r\n    if (typeof error === 'object' && error !== null && (<Record<string, unknown>>error).stack !== undefined) {\r\n        // Keeping this as it was for now, but `error.stack` is usually just a string anyway.\r\n        // I guess it also converts newlines to '\\n', which some part may need? Or it's completely unnecessary?\r\n        return toJson((<Record<string, unknown>>error).stack);\r\n    }\r\n    return '\"(no error.stack)\"';\r\n}\r\n\r\nfunction errorMessageToString(error: unknown): string {\r\n    if (typeof error === 'object' && error !== null && typeof (<Record<string, unknown>>error).message === 'string') {\r\n        return (<Record<string, string>>error).message;\r\n    }\r\n    return '(no error.message)';\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/TrouterConnection.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { HANDLED_MESSAGE_ACK, UNHANDLED_MESSAGE_ACK } from './Constants';\r\nimport { HandleMessageResult, LogProvider, MessageHandler, TrouterMessage } from './Interfaces';\r\nimport { Logger } from './Logger';\r\n\r\n/**\r\n * Registry of message handlers.\r\n * Safely executes individual handlers and aggregates results\r\n */\r\nexport class MessageHandlerRegistry {\r\n    private messageHandlers: MessageHandler[] = [];\r\n    private logger: Logger;\r\n\r\n    public constructor(logProvider: LogProvider) {\r\n        this.logger = new Logger(\"MessageHandlers\", logProvider);\r\n    }\r\n\r\n    public register(handler: MessageHandler) {\r\n        if (this.messageHandlers.some(item => item === handler)) {\r\n            throw new Error('Registering the same handler twice is not allowed');\r\n        }\r\n        this.messageHandlers.push(handler);\r\n    }\r\n\r\n    public clear() {\r\n        this.logger.debug('Clearing message handlers');\r\n        this.messageHandlers = [];\r\n    }\r\n\r\n    public active(): boolean {\r\n        return (this.messageHandlers.length > 0);\r\n    }\r\n\r\n    public handleMessage(message: TrouterMessage): HandleMessageResult {\r\n        const unhandledMessageResult = {\r\n            resultCode: UNHANDLED_MESSAGE_ACK,\r\n            isHandled: false\r\n        };\r\n\r\n        for (const messageHandler of this.messageHandlers) {\r\n            const result = this.safeExecuteHandle(messageHandler, message);\r\n            if (result !== undefined && (result.isHandled === undefined || result.isHandled)) {\r\n                if (result.resultCode === undefined) {\r\n                    result.resultCode = HANDLED_MESSAGE_ACK;\r\n                }\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return unhandledMessageResult;\r\n    }\r\n\r\n    private safeExecuteHandle(handler: MessageHandler, message: TrouterMessage): HandleMessageResult | undefined {\r\n        try {\r\n            return handler.handleMessage(message);\r\n        } catch (exception) {\r\n            this.logger.warn(`Trouter message handler threw an exception: ${exception}`);\r\n\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/MessageHandler.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { SkypeTokenProvider } from './Interfaces';\r\n\r\nexport function addCacheAsBackupTo(provider: SkypeTokenProvider): SkypeTokenProvider {\r\n    let cachedToken: string | undefined;\r\n\r\n    return async (forceRefresh: boolean): Promise<string> => {\r\n        if (forceRefresh) {\r\n            cachedToken = undefined;\r\n        }\r\n\r\n        return new Promise<string>((resolve, reject) => {\r\n            provider(forceRefresh).then((token: string) => {\r\n                cachedToken = token;\r\n                resolve(token);\r\n            }).catch((error) => {\r\n                if (cachedToken !== undefined && cachedToken.length > 0) {\r\n                    resolve(cachedToken);\r\n                }\r\n                reject(error);\r\n            });\r\n        });\r\n    };\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/SkypeTokenProviderWithCache.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { CorrelationVector, toJson } from './Common';\r\nimport {\r\n    AuthTokenProvider,\r\n    ConnectionInfo, Listener, LogProvider, Request, Response, SendResponseResult, TokenType, TrouterState,\r\n    UserActivityState,\r\n    IAudienceSubscriptionModel, IAudienceSubscriptionsResponse, IAudienceSubscription\r\n} from './Interfaces';\r\nimport { IMessageLossIndicator, ITrouterOptions, ITrouterRequest, ITrouterResponse, ServerState, TrouterManagerState } from './InternalInterfaces';\r\nimport { Logger } from './Logger';\r\nimport { usedProtocol } from './ProtocolAdapters';\r\nimport { RegistrationEnforcer } from './RegistrationEnforcer';\r\nimport { IManagerConsumer, IReconnectParameters, ReconnectReason, TrouterConnection } from './TrouterConnection';\r\nimport { State } from './TrouterFsm';\r\nimport { IManagerWorker, TrouterManagerFsm } from './TrouterManagerFsm';\r\n\r\n/**\r\n * Type alias for {@link UserActivityObject.toEventObject()}\r\n */\r\nexport type UserActivitySnapshot = { state: string, cv: string };\r\n\r\n/**\r\n * Type alias for {@link AudienceSubscriptionState.increaseCvAndGetEventObject()}\r\n */\r\nexport type AudienceSubscriptionSnapshot = { audiences: IAudienceSubscription[], cv: string }\r\n\r\n/**\r\n * UserActivity object\r\n */\r\nexport class UserActivityObject {\r\n    public readonly correlationVector: CorrelationVector;\r\n\r\n    constructor(readonly state: UserActivityState, correlationVector?: CorrelationVector) {\r\n        this.correlationVector = correlationVector !== undefined ? correlationVector : CorrelationVector.extend();\r\n    }\r\n\r\n    public getStateString() {\r\n        switch (this.state) {\r\n            case UserActivityState.Active:\r\n                return 'active';\r\n            case UserActivityState.Inactive:\r\n                return 'inactive';\r\n            case UserActivityState.Unknown:\r\n                return 'unknown';\r\n            default:\r\n                return 'undefined';\r\n        }\r\n    }\r\n\r\n    public increaseCvAndGetEventObject() {\r\n        this.correlationVector.increase();\r\n\r\n        return this.toEventObject();\r\n    }\r\n\r\n    public toEventObject() {\r\n        return { state: this.getStateString(), cv: this.correlationVector.value() };\r\n    }\r\n\r\n    public toEventJSON() {\r\n        return toJson(this.toEventObject());\r\n    }\r\n}\r\n\r\nexport class AudienceSubscriptionState {\r\n    constructor(\r\n        readonly audienceSubscriptionModel: IAudienceSubscriptionModel,\r\n        readonly correlationVector: CorrelationVector = CorrelationVector.extend()) {\r\n    }\r\n\r\n    public increaseCvAndGetEventObject(): AudienceSubscriptionSnapshot {\r\n        this.correlationVector.increase();\r\n\r\n        return this.toEventObject();\r\n    }\r\n\r\n    public toEventObject(): AudienceSubscriptionSnapshot {\r\n        return { audiences: this.audienceSubscriptionModel.audienceSubscriptions, cv: this.correlationVector.value() };\r\n    }\r\n\r\n    public toEventJSON() {\r\n        return toJson(this.toEventObject());\r\n    }\r\n}\r\n\r\n/**\r\n * Trouter implementation\r\n */\r\nexport class TrouterManager implements IManagerWorker, IManagerConsumer {\r\n    private logger: Logger;\r\n    private fsm: TrouterManagerFsm;\r\n    private firstConnection?: TrouterConnection;\r\n    private secondConnection?: TrouterConnection;\r\n    /** Value of first connection before stop() - to dispatch onDisconnected() of first connection */\r\n    private storedFirstConnection?: TrouterConnection;\r\n    private baseEndpointUrl: string;\r\n    private connectionCache?: Record<string, unknown>;\r\n    private lastExpediteBackoffCallAt?: number;\r\n\r\n    /** Cache for processed message loss to catch duplicates and to not pass them to the listeners */\r\n    private processedMessageLoss: { [flowTag: string]: '' };\r\n    private userActivityObject: UserActivityObject;\r\n    private audienceSubscriptionState: AudienceSubscriptionState | undefined;\r\n\r\n    private readonly protocolSelector: typeof usedProtocol;\r\n\r\n    public constructor(\r\n        private logFunc: LogProvider,\r\n        private options: ITrouterOptions,\r\n        private tokenProvider: AuthTokenProvider,\r\n        private usingLegacyTokenApi: boolean,\r\n        private listener: Listener,\r\n        protocolSelector?: typeof usedProtocol\r\n    ) {\r\n        this.logger = new Logger('Manager', logFunc);\r\n        this.logger.info(`Created TrouterManager with options ${toJson(this.options)}`);\r\n        this.fsm = new TrouterManagerFsm(logFunc, this);\r\n        this.baseEndpointUrl = '';\r\n        this.processedMessageLoss = {};\r\n        this.userActivityObject = new UserActivityObject(UserActivityState.Unknown);\r\n        this.protocolSelector = protocolSelector ?? this.tokenTypeProtocolSelector.bind(this);\r\n    }\r\n\r\n    public start() {\r\n        this.fsm.start();\r\n    }\r\n\r\n    public stop(dontUnregister?: boolean) {\r\n        this.fsm.stop(dontUnregister);\r\n    }\r\n\r\n    public configure(options: ITrouterOptions) {\r\n        this.options = options;\r\n        if (this.firstConnection !== undefined) {\r\n            this.firstConnection.configure(options);\r\n        }\r\n\r\n        if (this.secondConnection !== undefined) {\r\n            this.secondConnection.configure(options);\r\n        }\r\n        this.logger.info(`Reconfigured TrouterManager with options ${toJson(this.options)}`);\r\n    }\r\n\r\n    public checkConnection(disconnectDetected: boolean) {\r\n        if (this.firstConnection !== undefined) {\r\n            this.firstConnection.checkConnection(disconnectDetected);\r\n        }\r\n\r\n        if (this.secondConnection !== undefined) {\r\n            this.secondConnection.checkConnection(disconnectDetected);\r\n        }\r\n    }\r\n\r\n    public async resendRegistration(): Promise<void> {\r\n        if (this.secondConnection !== undefined) {\r\n            this.logger.info('Resending registration on the second/new connection');\r\n\r\n            return this.secondConnection.resendRegistration();\r\n        }\r\n\r\n        if (this.firstConnection !== undefined) {\r\n            this.logger.info('Resending registration on the first/current connection');\r\n\r\n            return this.firstConnection.resendRegistration();\r\n        }\r\n\r\n        this.logger.info('No connection to resend registration on, will be done upon (re)connect');\r\n    }\r\n\r\n    public getServerState(): ServerState | undefined {\r\n        if (this.firstConnection !== undefined) {\r\n            return this.firstConnection.getServerState();\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /** Returns current state */\r\n    public getState(): TrouterState {\r\n        return this.fsm.getState();\r\n    }\r\n\r\n    public isInTerminalState(): boolean {\r\n        return this.fsm.getInternalState() === TrouterManagerState.TerminalError;\r\n    }\r\n\r\n    public reportStateInfo(): string {\r\n        const firstState = this.firstConnection ? State[this.firstConnection.getState()] : \"Unknown\";\r\n        const managerState = TrouterManagerState[this.fsm.getInternalState()];\r\n        if (this.secondConnection) {\r\n            const secondState = State[this.secondConnection.getState()];\r\n            return `Manager ${managerState}; 1st ${firstState}; 2nd ${secondState}`;\r\n        }\r\n        return `Manager ${managerState}; Connection ${firstState}`;\r\n    }\r\n\r\n    //////////// IManagerWorker ////////////\r\n    public startFirstConnection() {\r\n        const connection = new TrouterConnection(\r\n            this.logFunc,\r\n            this.options,\r\n            this.configuredTrouterManager(),\r\n            this.tokenProvider,\r\n            this.usingLegacyTokenApi,\r\n            this.userActivityObject,\r\n            this.protocolSelector,\r\n            this.audienceSubscriptionState);\r\n        this.firstConnection = connection;\r\n\r\n        this.getConnectionCache()\r\n            .then(connectionCache => {\r\n                connection.start(connectionCache);\r\n            })\r\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n            .catch(() => { });\r\n    }\r\n\r\n    public startSecondConnection(useConnectParamsFromCache: boolean) {\r\n        const connection = new TrouterConnection(\r\n            this.logFunc,\r\n            this.options,\r\n            this.configuredTrouterManager(),\r\n            this.tokenProvider,\r\n            this.usingLegacyTokenApi,\r\n            this.userActivityObject,\r\n            this.protocolSelector,\r\n            this.audienceSubscriptionState);\r\n        this.secondConnection = connection;\r\n        if (this.firstConnection !== undefined) {\r\n            this.firstConnection.disableRegistrationsAndAutoReconnect();\r\n        }\r\n\r\n        if (useConnectParamsFromCache) {\r\n            this.getConnectionCache()\r\n                .then(connectionCache => {\r\n                    connection.start(connectionCache);\r\n                })\r\n                // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n                .catch(() => { });\r\n        } else {\r\n            connection.start();\r\n        }\r\n    }\r\n\r\n    public stopFirstConnection(dontUnregister: boolean) {\r\n        if (this.firstConnection !== undefined) {\r\n            // Store first connection to be able to compare in onDisconnected() handler\r\n            this.storedFirstConnection = this.firstConnection;\r\n            this.firstConnection.stop(dontUnregister);\r\n            this.firstConnection = undefined;\r\n        }\r\n    }\r\n\r\n    public stopSecondConnection(dontUnregister: boolean) {\r\n        if (this.secondConnection !== undefined) {\r\n            this.secondConnection.stop(dontUnregister);\r\n            this.secondConnection = undefined;\r\n        }\r\n    }\r\n\r\n    public stopSecondConnectionDelayed() {\r\n        if (this.secondConnection !== undefined) {\r\n            const connection = this.secondConnection;\r\n            this.secondConnection = undefined;\r\n            this.logger.info(`Closing an inactive connection in ${Math.round(this.options.lingeringConnectionDelayMs / 1000)}s`);\r\n            setTimeout(() => {\r\n                connection.stop(true);\r\n            }, this.options.lingeringConnectionDelayMs);\r\n        }\r\n    }\r\n\r\n    public forceStopLingeringConnection() {\r\n        if (this.storedFirstConnection) {\r\n            this.storedFirstConnection.stop(false);\r\n            this.storedFirstConnection = undefined;\r\n        }\r\n    }\r\n\r\n    public switchConnections() {\r\n        const tmp = this.firstConnection;\r\n        this.firstConnection = this.secondConnection;\r\n        this.secondConnection = tmp;\r\n    }\r\n\r\n    public doesSecondConnectionExist(): boolean {\r\n        return this.secondConnection !== undefined;\r\n    }\r\n\r\n    public dispatchConnected() {\r\n        if (this.firstConnection !== undefined) {\r\n            const ss = this.firstConnection.getServerState();\r\n            const baseEndpointUrl = (ss.url.endsWith('/')) ? ss.url.slice(0, -1) : ss.url;\r\n            const connectionInfo: ConnectionInfo = {\r\n                baseEndpointUrl: baseEndpointUrl,\r\n                newEndpointUrl: (baseEndpointUrl !== this.baseEndpointUrl),\r\n                c2cUrlBase: ss.c2cUrlBase,\r\n                clientId: ss.connectedClientId,\r\n                connectionId: ss.connectionId,\r\n                connectionTtlSec: ss.getRemainingTtlInSec()\r\n            };\r\n            this.baseEndpointUrl = baseEndpointUrl;\r\n            this.listener.onTrouterConnected(ss.url, connectionInfo);\r\n        }\r\n    }\r\n\r\n    public dispatchDisconnected() {\r\n        if (this.listener.onTrouterDisconnected) {\r\n            this.listener.onTrouterDisconnected();\r\n        }\r\n    }\r\n\r\n    public dispatchTerminalError() {\r\n        // Emit a disconnected event to listeners too.\r\n        if (this.listener.onTrouterDisconnected) {\r\n            this.listener.onTrouterDisconnected();\r\n        }\r\n    }\r\n\r\n    public dispatchRegistrationState(isRegistered: boolean) {\r\n        if (this.options.registrationStateCallback) {\r\n            this.options.registrationStateCallback(isRegistered);\r\n        }\r\n    }\r\n\r\n    public expediteBackoffOnConnections() {\r\n        if (this.lastExpediteBackoffCallAt !== undefined && Date.now() - this.lastExpediteBackoffCallAt < (this.options.expediteBackoffOnStartMinimumDelayMs ?? 10000)) {\r\n            this.logger.info('Expedite backoff due to start() too frequent, skipping');\r\n            return;\r\n        }\r\n\r\n        this.lastExpediteBackoffCallAt = Date.now();\r\n\r\n        if (this.firstConnection !== undefined) {\r\n            this.firstConnection.expediteBackoff();\r\n        }\r\n\r\n        if (this.secondConnection !== undefined) {\r\n            this.secondConnection.expediteBackoff();\r\n        }\r\n    }\r\n\r\n    //////////// IManagerConsumer ////////////\r\n    public onDownstreamRequest(connection: TrouterConnection, request: ITrouterRequest, response: ITrouterResponse) {\r\n        const req: Request = {\r\n            id: request.id,\r\n            method: request.method,\r\n            path: `/${request.shortUrl}`,\r\n            body: request.body,\r\n            headers: request.headers\r\n        };\r\n        const rsp: Response = {\r\n            id: request.id,\r\n            status: 0,\r\n            headers: {},\r\n            body: '',\r\n            send: () => {\r\n                if (rsp.status <= 100 || rsp.status >= 999) {\r\n\r\n                    return SendResponseResult.Incomplete;\r\n                }\r\n                response.writeHead(rsp.status, rsp.headers);\r\n\r\n                return response.end(rsp.body);\r\n            }\r\n        };\r\n        this.listener.onTrouterRequest(req, rsp);\r\n    }\r\n\r\n    public onConnected(connection: TrouterConnection) {\r\n        this.fsm.onConnected(connection === this.firstConnection);\r\n    }\r\n\r\n    public onRegistered(connection: TrouterConnection) {\r\n        this.fsm.onRegistered(connection === this.firstConnection);\r\n    }\r\n\r\n    public onUnregistered(connection: TrouterConnection) {\r\n        this.fsm.onUnregistered(connection === this.firstConnection || connection === this.storedFirstConnection);\r\n    }\r\n\r\n    public onReconnecting(connection: TrouterConnection) {\r\n        this.fsm.onReconnecting(connection === this.firstConnection);\r\n    }\r\n\r\n    public onReconnectIsRequired(connection: TrouterConnection, useConnectParamsFromCache: boolean, reason: ReconnectReason) {\r\n        this.fsm.onReconnectionRequired(connection === this.firstConnection, useConnectParamsFromCache, reason);\r\n    }\r\n\r\n    public onDisconnected(connection: TrouterConnection) {\r\n        this.fsm.onDisconnected(connection === this.firstConnection || connection == this.storedFirstConnection);\r\n        this.storedFirstConnection = undefined;\r\n    }\r\n\r\n    public onTerminalError() {\r\n        // TODO: the argument passed to onTerminalError is just ignored\r\n        // this.fsm.onTerminalError(connection === this.firstConnection || connection == this.storedFirstConnection);\r\n        this.fsm.onTerminalError();\r\n        this.storedFirstConnection = undefined;\r\n    }\r\n\r\n    public onUserActivityStateAccepted(cv: string) {\r\n        if (this.listener.onTrouterUserActivityStateAccepted) {\r\n            this.listener.onTrouterUserActivityStateAccepted(cv);\r\n        }\r\n    }\r\n\r\n    onAudiencesSetResolved(audienceSubscriptionsResponse: IAudienceSubscriptionsResponse, cv: string): void {\r\n        this.listener.onAudiencesSetResolved?.(audienceSubscriptionsResponse, cv);\r\n    }\r\n\r\n    public onConnectionParametersUpdated(connectionParameters: Record<string, unknown>) {\r\n        this.setConnectionCache(connectionParameters);\r\n    }\r\n\r\n    public setUserActivityState(state: UserActivityState, correlationVector?: string): void {\r\n        this.userActivityObject = new UserActivityObject(state, CorrelationVector.extend(correlationVector));\r\n        if (this.secondConnection !== undefined) {\r\n            this.logger.info(`Setting user activity ${this.userActivityObject.toEventJSON()} on the second/new connection`);\r\n            this.secondConnection.setUserActivityState(this.userActivityObject);\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.firstConnection !== undefined) {\r\n            this.logger.info(`Setting user activity ${this.userActivityObject.toEventJSON()} on the first/current connection`);\r\n            this.firstConnection.setUserActivityState(this.userActivityObject);\r\n\r\n            return;\r\n        }\r\n    }\r\n\r\n    public setAudienceSubscriptionsAsync(audienceSubscriptionModel: IAudienceSubscriptionModel, timeoutInMs: number, correlationVector?: string): Promise<IAudienceSubscriptionsResponse> {\r\n        this.audienceSubscriptionState = new AudienceSubscriptionState(audienceSubscriptionModel, CorrelationVector.extend(correlationVector));\r\n\r\n        if (this.secondConnection) {\r\n            this.logger.info(`Setting audience subscriptions ${this.audienceSubscriptionState.toEventJSON()} on second/new connection`);\r\n\r\n            return this.secondConnection.setAudienceSubscriptionsAsync(this.audienceSubscriptionState, timeoutInMs);\r\n        }\r\n\r\n        if (this.firstConnection) {\r\n            this.logger.info(`Setting audience subscriptions ${this.audienceSubscriptionState.toEventJSON()} on first/current connection`);\r\n\r\n            return this.firstConnection.setAudienceSubscriptionsAsync(this.audienceSubscriptionState, timeoutInMs);\r\n        }\r\n\r\n        throw new Error('No connection found');\r\n    }\r\n\r\n    public onTrouterMessageLost(indicators: IMessageLossIndicator[]) {\r\n        if (this.listener.onTrouterMessageLoss) {\r\n            if (indicators?.length) {\r\n                // Filter out already seen dropped indicators and inform server that they are processed\r\n                const duplicates = indicators.filter(di => this.processedMessageLoss[`${di.tag}-${di.etag}`] !== undefined);\r\n                if (duplicates.length) {\r\n                    this.logger.info(`onTrouterMessageLoss - immediately acknowledging ${duplicates.length} seen dropped indicators`);\r\n                    this.sendProcessedDroppedIndicators(duplicates);\r\n                    indicators = indicators.filter(di => this.processedMessageLoss[`${di.tag}-${di.etag}`] === undefined);\r\n\r\n                    if (!indicators.length) {\r\n                        this.logger.info('onTrouterMessageLoss - all declared dropped indicators have been seen before');\r\n\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                // Send the data to the listeners\r\n                const messageLossProcessed = this.listener.onTrouterMessageLoss(indicators.map(di => di.tag));\r\n                if (!messageLossProcessed) {\r\n                    this.logger.warn('onTrouterMessageLoss - some flow tag(s) have not been processed by listeners');\r\n\r\n                    return;\r\n                }\r\n\r\n                // Update the cache\r\n                indicators.forEach(di => {\r\n                    this.processedMessageLoss[`${di.tag}-${di.etag}`] = '';\r\n                });\r\n                this.sendProcessedDroppedIndicators(indicators);\r\n            } else {\r\n                this.logger.warn('onTrouterMessageLoss - no flow tags have been provided');\r\n            }\r\n        }\r\n    }\r\n\r\n    private getConnectionCache(): Promise<IReconnectParameters | undefined> {\r\n        if (!this.options.connectionCache) {\r\n\r\n            return Promise.resolve(this.connectionCache);\r\n        }\r\n\r\n        this.logger.debug('Querying host\\'s connection cache');\r\n\r\n        return this.options.connectionCache.onGetTrouterConnectionCache()\r\n            .then((serialized) => {\r\n\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n                const parsed = serialized ? JSON.parse(serialized) : undefined;\r\n                return typeof parsed === 'object' ? <Record<string, unknown>>parsed : undefined;\r\n            })\r\n            .catch((e) => {\r\n                this.logger.warn(`Invalid connection cache content provided: ${e}`);\r\n\r\n                return this.connectionCache;\r\n            });\r\n    }\r\n\r\n    private setConnectionCache(content: Record<string, unknown>) {\r\n        this.connectionCache = content;\r\n        if (this.options.connectionCache) {\r\n            try {\r\n                this.options.connectionCache.onSetTrouterConnectionCache(JSON.stringify(content));\r\n            } catch (e) {\r\n                this.logger.warn(`Error setting external connection cache: ${e}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private sendProcessedDroppedIndicators(messageLossIndicators: IMessageLossIndicator[]) {\r\n        if (this.firstConnection !== undefined) {\r\n            this.firstConnection.sendProcessedDroppedIndicators(messageLossIndicators);\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.secondConnection !== undefined) {\r\n            this.secondConnection.sendProcessedDroppedIndicators(messageLossIndicators);\r\n\r\n            return;\r\n        }\r\n    }\r\n\r\n    private configuredTrouterManager(): IManagerConsumer {\r\n        return new RegistrationEnforcer(\r\n            this,\r\n            this.options.connectionDependsOnRegistration,\r\n            this.options.delayEventsUntilRegistered\r\n        );\r\n    }\r\n\r\n    private tokenTypeProtocolSelector = (tokenType: TokenType, reconnectParams: IReconnectParameters | undefined) =>\r\n        this.options.forceV4aProtocol ? 'v4a' : usedProtocol(tokenType, reconnectParams);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/TrouterManager.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { LogProvider } from './Interfaces';\r\nimport { Logger } from './Logger';\r\n\r\n/**\r\n * Util that encapsulates lifecycle of active trouter URL and manages waiter for the URL via promise\r\n */\r\nexport class TrouterUrlPromise {\r\n    private url?: string;\r\n    private pendingPromise?: Promise<string>;\r\n    // eslint-disable-next-line @typescript-eslint/ban-types\r\n    private pendingPromiseResolveRef?: Function;\r\n    // eslint-disable-next-line @typescript-eslint/ban-types\r\n    private pendingPromiseRejectRef?: Function;\r\n    private logger: Logger;\r\n\r\n    public constructor(logProvider: LogProvider) {\r\n        this.logger = new Logger('UrlPromise', logProvider);\r\n    }\r\n\r\n    public getPromise(): Promise<string> {\r\n        if (this.url !== undefined) {\r\n            this.logger.debug(`returning previously resolved url: ${this.url}`);\r\n\r\n            return Promise.resolve(this.url);\r\n        }\r\n\r\n        if (this.pendingPromise === undefined) {\r\n            this.logger.debug('creating and returning promise');\r\n            this.pendingPromise = new Promise<string>((resolve, reject) => {\r\n                this.pendingPromiseResolveRef = resolve;\r\n                this.pendingPromiseRejectRef = reject;\r\n            });\r\n        } else {\r\n            this.logger.debug('returning existing promise');\r\n        }\r\n\r\n        return this.pendingPromise;\r\n    }\r\n\r\n    public resolveUrl(url: string) {\r\n        this.url = url;\r\n        this.logger.debug(`got url: ${this.url}`);\r\n\r\n        const resolveCallback = this.pendingPromiseResolveRef;\r\n        this.pendingPromise = undefined;\r\n        this.pendingPromiseResolveRef = undefined;\r\n        this.pendingPromiseRejectRef = undefined;\r\n\r\n        if (resolveCallback !== undefined) {\r\n            this.logger.debug('resolving promise');\r\n            resolveCallback(url);\r\n        }\r\n    }\r\n\r\n    public rejectUrl(error: Error) {\r\n        this.logger.debug('aborting');\r\n        const rejectCallback = this.pendingPromiseRejectRef;\r\n        this.url = undefined;\r\n        this.pendingPromise = undefined;\r\n        this.pendingPromiseResolveRef = undefined;\r\n        this.pendingPromiseRejectRef = undefined;\r\n\r\n        if (rejectCallback !== undefined) {\r\n            this.logger.debug('rejecting promise');\r\n            rejectCallback(error);\r\n        }\r\n    }\r\n\r\n    public resetUrl() {\r\n        this.logger.debug('resetting url');\r\n        this.url = undefined;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/TrouterUrlPromise.ts","/** Socket.IO.js build:0.9.6, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, global) {\r\n\r\n  /**\r\n   * IO namespace.\r\n   *\r\n   * @namespace\r\n   */\r\n\r\n  var io = exports;\r\n\r\n  /**\r\n   * Socket.IO version\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  io.version = '0.9.6';\r\n\r\n  /**\r\n   * Protocol implemented.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  io.protocol = 1;\r\n\r\n  /**\r\n   * Available transports, these will be populated with the available transports\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  io.transports = [];\r\n\r\n  /**\r\n   * Keep track of jsonp callbacks.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  io.j = [];\r\n\r\n  /**\r\n   * Keep track of our io.Sockets\r\n   *\r\n   * @api private\r\n   */\r\n  io.sockets = {};\r\n\r\n\r\n  /**\r\n   * Manages connections to hosts.\r\n   *\r\n   * @param {String} uri\r\n   * @Param {Boolean} force creation of new socket (defaults to false)\r\n   * @api public\r\n   */\r\n\r\n  io.connect = function (host, details) {\r\n    var uri = io.util.parseUri(host)\r\n      , uuri\r\n      , socket;\r\n\r\n    if (global && global.location) {\r\n      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);\r\n      uri.host = uri.host || (global.document\r\n        ? global.document.domain : global.location.hostname);\r\n      uri.port = uri.port || global.location.port;\r\n    }\r\n\r\n    uuri = io.util.uniqueUri(uri);\r\n\r\n    var options = {\r\n        host: uri.host\r\n      , secure: 'https' == uri.protocol\r\n      , port: uri.port || ('https' == uri.protocol ? 443 : 80)\r\n      , query: uri.query || ''\r\n    };\r\n\r\n    io.util.merge(options, details);\r\n\r\n    if (options['force new connection'] || !io.sockets[uuri]) {\r\n      socket = new io.Socket(options);\r\n    }\r\n\r\n    if (!options['force new connection'] && socket) {\r\n      io.sockets[uuri] = socket;\r\n    }\r\n\r\n    socket = socket || io.sockets[uuri];\r\n\r\n    // Making /v4/c have empty namespace\r\n    if (options['skipped handshake data']) {\r\n      return socket.of('');\r\n    } else {\r\n      // if path is different from '' or /\r\n      return socket.of(uri.path.length > 1 ? uri.path : '');\r\n    }\r\n  };\r\n\r\n})(\r\n    'object' === typeof module ? module.exports : (this.io = {})\r\n  , 'undefined' === typeof global ? window : global);\r\n\r\n// Workaround inside webpack\r\nvar io = module.exports;\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, global) {\r\n\r\n  /**\r\n   * Utilities namespace.\r\n   *\r\n   * @namespace\r\n   */\r\n\r\n  var util = exports.util = {};\r\n\r\n  /**\r\n   * Parses an URI\r\n   *\r\n   * @author Steven Levithan <stevenlevithan.com> (MIT license)\r\n   * @api public\r\n   */\r\n\r\n  var re = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\r\n\r\n  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',\r\n               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',\r\n               'anchor'];\r\n\r\n  util.parseUri = function (str) {\r\n    var m = re.exec(str || '')\r\n      , uri = {}\r\n      , i = 14;\r\n\r\n    while (i--) {\r\n      uri[parts[i]] = m[i] || '';\r\n    }\r\n\r\n    return uri;\r\n  };\r\n\r\n  /**\r\n   * Produces a unique url that identifies a Socket.IO connection.\r\n   *\r\n   * @param {Object} uri\r\n   * @api public\r\n   */\r\n\r\n  util.uniqueUri = function (uri) {\r\n    var protocol = uri.protocol\r\n      , host = uri.host\r\n      , port = uri.port;\r\n\r\n    if ('document' in global) {\r\n      host = host || document.domain;\r\n      port = port || (protocol == 'https'\r\n        && document.location.protocol !== 'https:' ? 443 : document.location.port);\r\n    } else {\r\n      host = host || 'localhost';\r\n\r\n      if (!port && protocol == 'https') {\r\n        port = 443;\r\n      }\r\n    }\r\n\r\n    return (protocol || 'http') + '://' + host + ':' + (port || 80);\r\n  };\r\n\r\n  /**\r\n   * Mergest 2 query strings in to once unique query string\r\n   *\r\n   * @param {String} base\r\n   * @param {String} addition\r\n   * @api public\r\n   */\r\n\r\n  util.query = function (base, addition) {\r\n    var query = util.chunkQuery(base || '')\r\n      , components = [];\r\n\r\n    util.merge(query, util.chunkQuery(addition || ''));\r\n    for (var part in query) {\r\n      if (query.hasOwnProperty(part)) {\r\n        components.push(part + '=' + query[part]);\r\n      }\r\n    }\r\n\r\n    return components.length ? '?' + components.join('&') : '';\r\n  };\r\n\r\n  /**\r\n   * Transforms a querystring in to an object\r\n   *\r\n   * @param {String} qs\r\n   * @api public\r\n   */\r\n\r\n  util.chunkQuery = function (qs) {\r\n    var query = {}\r\n      , params = qs.split('&')\r\n      , i = 0\r\n      , l = params.length\r\n      , kv;\r\n\r\n    for (; i < l; ++i) {\r\n      kv = params[i].split('=');\r\n      if (kv[0]) {\r\n        query[kv[0]] = kv[1];\r\n      }\r\n    }\r\n\r\n    return query;\r\n  };\r\n\r\n  /**\r\n   * Executes the given function when the page is loaded.\r\n   *\r\n   *     io.util.load(function () { console.log('page loaded'); });\r\n   *\r\n   * @param {Function} fn\r\n   * @api public\r\n   */\r\n\r\n  var pageLoaded = false;\r\n\r\n  util.load = function (fn) {\r\n    if ('document' in global && document.readyState === 'complete' || pageLoaded) {\r\n      return fn();\r\n    }\r\n\r\n    util.on(global, 'load', fn, false);\r\n  };\r\n\r\n  /**\r\n   * Adds an event.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  util.on = function (element, event, fn, capture) {\r\n    if (element.attachEvent) {\r\n      element.attachEvent('on' + event, fn);\r\n    } else if (element.addEventListener) {\r\n      element.addEventListener(event, fn, capture);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.\r\n   *\r\n   * @param {Boolean} [xdomain] Create a request that can be used cross domain.\r\n   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.\r\n   * @api private\r\n   */\r\n\r\n  util.request = function (xdomain) {\r\n\r\n    if (xdomain && 'undefined' != typeof XDomainRequest) {\r\n      return new XDomainRequest();\r\n    }\r\n\r\n    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {\r\n      return new XMLHttpRequest();\r\n    }\r\n\r\n    if (!xdomain) {\r\n      try {\r\n        return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');\r\n      } catch(e) { }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * XHR based transport constructor.\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   */\r\n\r\n  /**\r\n   * Change the internal pageLoaded value.\r\n   */\r\n\r\n  if ('undefined' != typeof window) {\r\n    util.load(function () {\r\n      pageLoaded = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Defers a function to ensure a spinner is not displayed by the browser\r\n   *\r\n   * @param {Function} fn\r\n   * @api public\r\n   */\r\n\r\n  util.defer = function (fn) {\r\n    if (!util.ua.webkit || 'undefined' != typeof importScripts) {\r\n      return fn();\r\n    }\r\n\r\n    util.load(function () {\r\n      setTimeout(fn, 100);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Merges two objects.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.merge = function merge (target, additional, deep, lastseen) {\r\n    var seen = lastseen || []\r\n      , depth = typeof deep == 'undefined' ? 2 : deep\r\n      , prop;\r\n\r\n    for (prop in additional) {\r\n      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {\r\n        if (typeof target[prop] !== 'object' || !depth) {\r\n          target[prop] = additional[prop];\r\n          seen.push(additional[prop]);\r\n        } else {\r\n          util.merge(target[prop], additional[prop], depth - 1, seen);\r\n        }\r\n      }\r\n    }\r\n\r\n    return target;\r\n  };\r\n\r\n  /**\r\n   * Merges prototypes from objects\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.mixin = function (ctor, ctor2) {\r\n    util.merge(ctor.prototype, ctor2.prototype);\r\n  };\r\n\r\n  /**\r\n   * Shortcut for prototypical and static inheritance.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  util.inherit = function (ctor, ctor2) {\r\n    function f() {};\r\n    f.prototype = ctor2.prototype;\r\n    ctor.prototype = new f;\r\n  };\r\n\r\n  /**\r\n   * Checks if the given object is an Array.\r\n   *\r\n   *     io.util.isArray([]); // true\r\n   *     io.util.isArray({}); // false\r\n   *\r\n   * @param Object obj\r\n   * @api public\r\n   */\r\n\r\n  util.isArray = Array.isArray || function (obj) {\r\n    return Object.prototype.toString.call(obj) === '[object Array]';\r\n  };\r\n\r\n  /**\r\n   * Intersects values of two arrays into a third\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.intersect = function (arr, arr2) {\r\n    var ret = []\r\n      , longest = arr.length > arr2.length ? arr : arr2\r\n      , shortest = arr.length > arr2.length ? arr2 : arr;\r\n\r\n    for (var i = 0, l = shortest.length; i < l; i++) {\r\n      if (~util.indexOf(longest, shortest[i]))\r\n        ret.push(shortest[i]);\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   * Array indexOf compatibility.\r\n   *\r\n   * @see bit.ly/a5Dxa2\r\n   * @api public\r\n   */\r\n\r\n  util.indexOf = function (arr, o, i) {\r\n\r\n    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0;\r\n         i < j && arr[i] !== o; i++) {}\r\n\r\n    return j <= i ? -1 : i;\r\n  };\r\n\r\n  /**\r\n   * Converts enumerables to array.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.toArray = function (enu) {\r\n    var arr = [];\r\n\r\n    for (var i = 0, l = enu.length; i < l; i++)\r\n      arr.push(enu[i]);\r\n\r\n    return arr;\r\n  };\r\n\r\n  /**\r\n   * UA / engines detection namespace.\r\n   *\r\n   * @namespace\r\n   */\r\n\r\n  util.ua = {};\r\n\r\n  /**\r\n   * Whether the UA supports CORS for XHR.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {\r\n    try {\r\n      var a = new XMLHttpRequest();\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n\r\n    return a.withCredentials != undefined;\r\n  })();\r\n\r\n  /**\r\n   * Detect webkit.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.ua.webkit = 'undefined' != typeof navigator\r\n    && /webkit/i.test(navigator.userAgent);\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' === typeof global ? window : global);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.EventEmitter = EventEmitter;\r\n\r\n  /**\r\n   * Event emitter constructor.\r\n   *\r\n   * @api public.\r\n   */\r\n\r\n  function EventEmitter () {};\r\n\r\n  /**\r\n   * Adds a listener\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.on = function (name, fn) {\r\n    if (!this.$events) {\r\n      this.$events = {};\r\n    }\r\n\r\n    if (!this.$events[name]) {\r\n      this.$events[name] = fn;\r\n    } else if (io.util.isArray(this.$events[name])) {\r\n      this.$events[name].push(fn);\r\n    } else {\r\n      this.$events[name] = [this.$events[name], fn];\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n  /**\r\n   * Adds a volatile listener.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.once = function (name, fn) {\r\n    var self = this;\r\n\r\n    function on () {\r\n      self.removeListener(name, on);\r\n      fn.apply(this, arguments);\r\n    };\r\n\r\n    on.listener = fn;\r\n    this.on(name, on);\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Removes a listener.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.removeListener = function (name, fn) {\r\n    if (this.$events && this.$events[name]) {\r\n      var list = this.$events[name];\r\n\r\n      if (io.util.isArray(list)) {\r\n        var pos = -1;\r\n\r\n        for (var i = 0, l = list.length; i < l; i++) {\r\n          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\r\n            pos = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (pos < 0) {\r\n          return this;\r\n        }\r\n\r\n        list.splice(pos, 1);\r\n\r\n        if (!list.length) {\r\n          delete this.$events[name];\r\n        }\r\n      } else if (list === fn || (list.listener && list.listener === fn)) {\r\n        delete this.$events[name];\r\n      }\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Removes all listeners for an event.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.removeAllListeners = function (name) {\r\n    // TODO: enable this when node 0.5 is stable\r\n    //if (name === undefined) {\r\n      //this.$events = {};\r\n      //return this;\r\n    //}\r\n\r\n    if (this.$events && this.$events[name]) {\r\n      this.$events[name] = null;\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Gets all listeners for a certain event.\r\n   *\r\n   * @api publci\r\n   */\r\n\r\n  EventEmitter.prototype.listeners = function (name) {\r\n    if (!this.$events) {\r\n      this.$events = {};\r\n    }\r\n\r\n    if (!this.$events[name]) {\r\n      this.$events[name] = [];\r\n    }\r\n\r\n    if (!io.util.isArray(this.$events[name])) {\r\n      this.$events[name] = [this.$events[name]];\r\n    }\r\n\r\n    return this.$events[name];\r\n  };\r\n\r\n  /**\r\n   * Emits an event.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.emit = function (name) {\r\n    if (!this.$events) {\r\n      return false;\r\n    }\r\n\r\n    var handler = this.$events[name];\r\n\r\n    if (!handler) {\r\n      return false;\r\n    }\r\n\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n\r\n    if ('function' == typeof handler) {\r\n      handler.apply(this, args);\r\n    } else if (io.util.isArray(handler)) {\r\n      var listeners = handler.slice();\r\n\r\n      for (var i = 0, l = listeners.length; i < l; i++) {\r\n        listeners[i].apply(this, args);\r\n      }\r\n    } else {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * Removed JSON polyfill - obsolete, and we are using native JSON.parse etc. throughout the rest of the codebase anyway\r\n */\r\n\r\n(function (exports, nativeJSON) {\r\n  \"use strict\";\r\n\r\n  // use native JSON if it's available\r\n  if (nativeJSON && nativeJSON.parse){\r\n    return exports.JSON = {\r\n      parse: nativeJSON.parse\r\n    , stringify: nativeJSON.stringify\r\n    }\r\n  }\r\n\r\n  throw new Error(\"JSON not available\");\r\n  \r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , typeof JSON !== 'undefined' ? JSON : undefined\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Parser namespace.\r\n   *\r\n   * @namespace\r\n   */\r\n\r\n  var parser = exports.parser = {};\r\n\r\n  /**\r\n   * Packet types.\r\n   */\r\n\r\n  var packets = parser.packets = [\r\n      'disconnect'\r\n    , 'connect'\r\n    , 'heartbeat'\r\n    , 'message'\r\n    , 'json'\r\n    , 'event'\r\n    , 'ack'\r\n    , 'error'\r\n    , 'noop'\r\n  ];\r\n\r\n  /**\r\n   * Errors reasons.\r\n   */\r\n\r\n  var reasons = parser.reasons = [\r\n      'transport not supported'\r\n    , 'client not handshaken'\r\n    , 'unauthorized'\r\n  ];\r\n\r\n  /**\r\n   * Errors advice.\r\n   */\r\n\r\n  var advice = parser.advice = [\r\n      'reconnect'\r\n  ];\r\n\r\n  /**\r\n   * Shortcuts.\r\n   */\r\n\r\n  var JSON = io.JSON\r\n    , indexOf = io.util.indexOf;\r\n\r\n  /**\r\n   * Encodes a packet.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  parser.encodePacket = function (packet) {\r\n    var type = indexOf(packets, packet.type)\r\n      , id = packet.id || ''\r\n      , endpoint = packet.endpoint || ''\r\n      , ack = packet.ack\r\n      , data = null;\r\n\r\n    switch (packet.type) {\r\n      case 'error':\r\n        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''\r\n          , adv = packet.advice ? indexOf(advice, packet.advice) : '';\r\n\r\n        if (reason !== '' || adv !== '')\r\n          data = reason + (adv !== '' ? ('+' + adv) : '');\r\n\r\n        break;\r\n\r\n      case 'message':\r\n        if (packet.data !== '')\r\n          data = packet.data;\r\n        break;\r\n\r\n      case 'event':\r\n        var ev = { name: packet.name };\r\n\r\n        if (packet.args && packet.args.length) {\r\n          ev.args = packet.args;\r\n        }\r\n\r\n        data = JSON.stringify(ev);\r\n        break;\r\n\r\n      case 'json':\r\n        data = JSON.stringify(packet.data);\r\n        break;\r\n\r\n      case 'connect':\r\n        if (packet.qs)\r\n          data = packet.qs;\r\n        break;\r\n\r\n      case 'ack':\r\n        data = packet.ackId\r\n          + (packet.args && packet.args.length\r\n              ? '+' + JSON.stringify(packet.args) : '');\r\n        break;\r\n    }\r\n\r\n    // construct packet with required fragments\r\n    var encoded = [\r\n        type\r\n      , id + (ack == 'data' ? '+' : '')\r\n      , endpoint\r\n    ];\r\n\r\n    // data fragment is optional\r\n    if (data !== null && data !== undefined)\r\n      encoded.push(data);\r\n\r\n    return encoded.join(':');\r\n  };\r\n\r\n  /**\r\n   * Encodes multiple messages (payload).\r\n   *\r\n   * @param {Array} messages\r\n   * @api private\r\n   */\r\n\r\n  parser.encodePayload = function (packets) {\r\n    var decoded = '';\r\n\r\n    if (packets.length == 1)\r\n      return packets[0];\r\n\r\n    for (var i = 0, l = packets.length; i < l; i++) {\r\n      var packet = packets[i];\r\n      decoded += '\\ufffd' + packet.length + '\\ufffd' + packets[i];\r\n    }\r\n\r\n    return decoded;\r\n  };\r\n\r\n  /**\r\n   * Decodes a packet\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  var regexp = /([^:]+):([0-9]+)?(\\+)?:([^:]+)?:?([\\s\\S]*)?/;\r\n\r\n  parser.decodePacket = function (data) {\r\n    var pieces = data.match(regexp);\r\n\r\n    if (!pieces) return {};\r\n\r\n    var id = pieces[2] || ''\r\n      , data = pieces[5] || ''\r\n      , packet = {\r\n            type: packets[pieces[1]]\r\n          , endpoint: pieces[4] || ''\r\n        };\r\n\r\n    // whether we need to acknowledge the packet\r\n    if (id) {\r\n      packet.id = id;\r\n      if (pieces[3])\r\n        packet.ack = 'data';\r\n      else\r\n        packet.ack = true;\r\n    }\r\n\r\n    // handle different packet types\r\n    switch (packet.type) {\r\n      case 'error':\r\n        var pieces = data.split('+');\r\n        packet.reason = reasons[pieces[0]] || '';\r\n        packet.advice = advice[pieces[1]] || '';\r\n        break;\r\n\r\n      case 'message':\r\n        packet.data = data || '';\r\n        break;\r\n\r\n      case 'event':\r\n        try {\r\n          var opts = JSON.parse(data);\r\n          packet.name = opts.name;\r\n          packet.args = opts.args;\r\n        } catch (e) { }\r\n\r\n        packet.args = packet.args || [];\r\n        break;\r\n\r\n      case 'json':\r\n        try {\r\n          packet.data = JSON.parse(data);\r\n        } catch (e) { }\r\n        break;\r\n\r\n      case 'connect':\r\n        packet.qs = data || '';\r\n        break;\r\n\r\n      case 'ack':\r\n        var pieces = data.match(/^([0-9]+)(\\+)?(.*)/);\r\n        if (pieces) {\r\n          packet.ackId = pieces[1];\r\n          packet.args = [];\r\n\r\n          if (pieces[3]) {\r\n            try {\r\n              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];\r\n            } catch (e) { }\r\n          }\r\n        }\r\n        break;\r\n\r\n      case 'disconnect':\r\n        packet.reason = data;\r\n        break;\r\n\r\n      case 'heartbeat':\r\n        break;\r\n    };\r\n\r\n    return packet;\r\n  };\r\n\r\n  /**\r\n   * Decodes data payload. Detects multiple messages\r\n   *\r\n   * @return {Array} messages\r\n   * @api public\r\n   */\r\n\r\n  parser.decodePayload = function (data) {\r\n    // IE doesn't like data[i] for unicode chars, charAt works fine\r\n    if (data.charAt(0) == '\\ufffd') {\r\n      var ret = [];\r\n\r\n      for (var i = 1, length = ''; i < data.length; i++) {\r\n        if (data.charAt(i) == '\\ufffd') {\r\n          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));\r\n          i += Number(length) + 1;\r\n          length = '';\r\n        } else {\r\n          length += data.charAt(i);\r\n        }\r\n      }\r\n\r\n      return ret;\r\n    } else {\r\n      return [parser.decodePacket(data)];\r\n    }\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.Transport = Transport;\r\n\r\n  /**\r\n   * This is the transport template for all supported transport methods.\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   * @param {exports.Socket} socket\r\n   */\r\n\r\n  function Transport (socket, sessid) {\r\n    this.socket = socket;\r\n    this.sessid = sessid;\r\n    this.connectErrorCallback = undefined;\r\n    this.isOpened = false;\r\n  };\r\n\r\n  /**\r\n   * Apply EventEmitter mixin.\r\n   */\r\n\r\n  io.util.mixin(Transport, io.EventEmitter);\r\n\r\n  /**\r\n   * Handles the response from the server. When a new response is received\r\n   * it will automatically update the timeout, decode the message and\r\n   * forwards the response to the onMessage function for further processing.\r\n   *\r\n   * @param {String} data Response from the server.\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onData = function (data) {\r\n    this.clearCloseTimeout();\r\n\r\n    // If the connection in currently open (or in a reopening state) reset the close\r\n    // timeout since we have just received data. This check is necessary so\r\n    // that we don't reset the timeout on an explicitly disconnected connection.\r\n    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {\r\n      this.setCloseTimeout();\r\n    }\r\n\r\n    if (data !== '') {\r\n      // todo: we should only do decodePayload for xhr transports\r\n      var msgs = io.parser.decodePayload(data);\r\n\r\n      if (msgs && msgs.length) {\r\n        for (var i = 0, l = msgs.length; i < l; i++) {\r\n          this.onPacket(msgs[i]);\r\n        }\r\n      }\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Handles packets.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onPacket = function (packet) {\r\n    this.socket.setHeartbeatTimeout();\r\n\r\n    if (packet.type == 'heartbeat') {\r\n      return this.onHeartbeat();\r\n    }\r\n\r\n    if (packet.type == 'connect' && packet.endpoint == '') {\r\n      this.onConnect();\r\n    }\r\n\r\n    if (packet.type == 'error' && packet.advice == 'reconnect') {\r\n      this.isOpened = false;\r\n    }\r\n\r\n    this.socket.onPacket(packet);\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Sets close timeout\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.setCloseTimeout = function () {\r\n    if (!this.closeTimeout) {\r\n      var self = this;\r\n\r\n      this.closeTimeout = setTimeout(function () {\r\n        self.onDisconnect();\r\n      }, this.socket.closeTimeout);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called when transport disconnects.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onDisconnect = function () {\r\n    if (this.close && this.isOpened) this.close();\r\n    this.clearTimeouts();\r\n    this.socket.onDisconnect();\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Called when transport connects\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onConnect = function () {\r\n    this.socket.onConnect();\r\n    this.connectErrorCallback = undefined;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clears close timeout\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.clearCloseTimeout = function () {\r\n    if (this.closeTimeout) {\r\n      clearTimeout(this.closeTimeout);\r\n      this.closeTimeout = null;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear timeouts\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.clearTimeouts = function () {\r\n    this.clearCloseTimeout();\r\n\r\n    if (this.reopenTimeout) {\r\n      clearTimeout(this.reopenTimeout);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Sends a packet\r\n   *\r\n   * @param {Object} packet object.\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.packet = function (packet) {\r\n    this.send(io.parser.encodePacket(packet));\r\n  };\r\n\r\n  /**\r\n   * Send the received heartbeat message back to server. So the server\r\n   * knows we are still connected.\r\n   *\r\n   * @param {String} heartbeat Heartbeat response from the server.\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onHeartbeat = function (heartbeat) {\r\n    this.packet({ type: 'heartbeat' });\r\n  };\r\n\r\n  /**\r\n   * Called when the transport opens.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onOpen = function () {\r\n    this.isOpened = true;\r\n    this.clearCloseTimeout();\r\n    this.socket.onOpen();\r\n  };\r\n\r\n  /**\r\n   * Notifies the base when the connection with the Socket.IO server\r\n   * has been disconnected.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onClose = function () {\r\n    var self = this;\r\n\r\n    /* FIXME: reopen delay causing a infinit loop\r\n    this.reopenTimeout = setTimeout(function () {\r\n      self.open();\r\n    }, this.socket.options['reopen delay']);*/\r\n\r\n    this.isOpened = false;\r\n    this.socket.onClose();\r\n    this.onDisconnect();\r\n  };\r\n\r\n  /**\r\n   * Generates a connection url based on the Socket.IO URL Protocol.\r\n   * See <https://github.com/learnboost/socket.io-node/> for more details.\r\n   *\r\n   * @returns {String} Connection url\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.prepareUrl = function (query) {\r\n    /** @var {ISocketIoOptions} options */\r\n    var options = this.socket.options;\r\n\r\n    if (options['skipped handshake data']) {\r\n      // /v4/c protocol\r\n      return options.rewriteUrlForProxy(options['skipped handshake data'].websocketUrl + (query ? query : ''))\r\n    }\r\n\r\n    var url = this.scheme() + '://'\r\n      + options.host + ':' + options.port + '/'\r\n      + options.resource + '/' + io.protocol\r\n      + '/' + this.name + '/' + this.sessid + (query ? query : '');\r\n\r\n    return options.rewriteUrlForProxy(url);\r\n  };\r\n\r\n  /**\r\n   * Checks if the transport is ready to start a connection.\r\n   *\r\n   * @param {Socket} socket The socket instance that needs a transport\r\n   * @param {Function} fn The callback\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.ready = function (socket, fn) {\r\n    fn.call(this);\r\n  };\r\n\r\n  /**\r\n   * Clears the event handlers attached on to by specific transport implementations.\r\n   *\r\n   * @api private\r\n   */\r\n  Transport.prototype.clearEventHandlers = function () {\r\n      return this;\r\n  };\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.Socket = Socket;\r\n\r\n  /**\r\n   * Create a new `Socket.IO client` which can establish a persistent\r\n   * connection with a Socket.IO enabled server.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  function Socket (options) {\r\n    this.options = {\r\n        port: 80\r\n      , secure: false\r\n      , document: 'document' in global ? document : false\r\n      , resource: 'socket.io'\r\n      , transports: io.transports.slice()\r\n      , 'connect timeout': 10000\r\n      , 'try multiple transports': true\r\n      , 'reconnect': true\r\n      , 'reconnection delay': 500\r\n      , 'reconnection limit': Infinity\r\n      , 'reopen delay': 3000\r\n      , 'max reconnection attempts': 10\r\n      , 'sync disconnect on unload': true\r\n      , 'auto connect': true\r\n      , 'flash policy port': 10843\r\n    };\r\n\r\n    io.util.merge(this.options, options);\r\n\r\n    this.connected = false;\r\n    this.open = false;\r\n    this.connecting = false;\r\n    this.reconnecting = false;\r\n    this.namespaces = {};\r\n    this.buffer = [];\r\n    this.doBuffer = false;\r\n    this.disconnected = false;\r\n\r\n    if (this.options['sync disconnect on unload'] &&\r\n        (!this.isXDomain() || io.util.ua.hasCORS)) {\r\n      var self = this;\r\n\r\n      io.util.on(global, 'unload', function () {\r\n        self.disconnectSync();\r\n      }, false);\r\n    }\r\n\r\n    if (this.options['auto connect']) {\r\n      this.connect();\r\n    }\r\n};\r\n\r\n  /**\r\n   * Apply EventEmitter mixin.\r\n   */\r\n\r\n  io.util.mixin(Socket, io.EventEmitter);\r\n\r\n  /**\r\n   * Returns a namespace listener/emitter for this socket\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.of = function (name) {\r\n    if (!this.namespaces[name]) {\r\n      this.namespaces[name] = new io.SocketNamespace(this, name);\r\n\r\n      if (name !== '') {\r\n        this.namespaces[name].packet({ type: 'connect' });\r\n      }\r\n    }\r\n\r\n    return this.namespaces[name];\r\n  };\r\n\r\n  /**\r\n   * Emits the given event to the Socket and all namespaces\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.publish = function () {\r\n    this.emit.apply(this, arguments);\r\n\r\n    var nsp;\r\n\r\n    for (var i in this.namespaces) {\r\n      if (this.namespaces.hasOwnProperty(i)) {\r\n        nsp = this.of(i);\r\n        nsp.$emit.apply(nsp, arguments);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Performs the handshake\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  function empty () { };\r\n\r\n  Socket.prototype.handshake = function (fn) {\r\n    var self = this\r\n      , options = this.options;\r\n      \r\n    if (self.disconnected) {\r\n      return;\r\n    }\r\n\r\n    function complete (data) {\r\n      if (data instanceof Error) {\r\n        self.onError(data.message);\r\n      } else {\r\n        fn.apply(null, data.split(':'));\r\n      }\r\n    };\r\n\r\n    var url = options.rewriteUrlForProxy([\r\n          'http' + (options.secure ? 's' : '') + ':/'\r\n        , options.host + ':' + options.port\r\n        , options.resource\r\n        , io.protocol\r\n        , io.util.query(this.options.query, 't=' + +new Date)\r\n      ].join('/'));\r\n\r\n    if (this.isXDomain() && !io.util.ua.hasCORS) {\r\n      var insertAt = document.getElementsByTagName('script')[0]\r\n        , script = document.createElement('script');\r\n\r\n      script.src = url + '&jsonp=' + io.j.length;\r\n      insertAt.parentNode.insertBefore(script, insertAt);\r\n\r\n      io.j.push(function (data) {\r\n        complete(data);\r\n        script.parentNode.removeChild(script);\r\n      });\r\n    } else {\r\n      var xhr = io.util.request();\r\n      \r\n      xhr.open('GET', url, true);\r\n\r\n      var headers = this.options.requestHeaders;\r\n      if (headers !== undefined) {\r\n        Object.keys(headers).forEach(function(name) {\r\n          xhr.setRequestHeader(name, headers[name]);\r\n        });\r\n      }\r\n      xhr.onreadystatechange = function () {\r\n        if (xhr.readyState == 4) {\r\n          xhr.onreadystatechange = empty;\r\n\r\n          if (xhr.status == 200) {\r\n            complete(xhr.responseText);\r\n          } else {\r\n            !self.reconnecting && self.onError(xhr.responseText);\r\n          }\r\n        }\r\n      };\r\n      xhr.send(null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Find an available transport based on the options supplied in the constructor.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.getTransport = function (override) {\r\n    var transports = override || this.transports, match;\r\n\r\n    for (var i = 0, transport; transport = transports[i]; i++) {\r\n      if (io.Transport[transport]\r\n        && io.Transport[transport].check(this)\r\n        && (!this.isXDomain() || io.Transport[transport].xdomainCheck())) {\r\n        return new io.Transport[transport](this, this.sessionid);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Connects to the server.\r\n   *\r\n   * @param {Function} [fn] Callback.\r\n   * @returns {io.Socket}\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.connect = function (fn) {\r\n    if (this.connecting || this.disconnected) {\r\n      return this;\r\n    }\r\n\r\n    var self = this;\r\n\r\n    var onHandshakeComplete = (function (sid, heartbeat, close, transports) {\r\n      // Params come from response's body - it's splitted by ':'\r\n      // example: 1178beba4026e2c7-48e62d038b18f416:85:85:websocket,xhr-polling,jsonp-polling\r\n      self.sessionid = sid;\r\n      // Add two seconds, so connection is closed by server, not client - otherwise\r\n      // there will be a onSocketDisconnect event which will start health check, etc\r\n      // This can happen if server returns close/heartbeat timeout equal to 40 which is server's timeout to\r\n      // close long poll connection, in such case client can close connection before server response with empty\r\n      // response and client goes to health check. Server can return such timeout if client send too small ping timeout\r\n      // during handshake\r\n      self.closeTimeout = close * 1000 + 2000;\r\n      self.heartbeatTimeout = heartbeat * 1000 + 2000;\r\n      self.transports = transports ? io.util.intersect(\r\n          transports.split(',')\r\n        , self.options.transports\r\n      ) : self.options.transports;\r\n\r\n      self.setHeartbeatTimeout();\r\n      self.remainingTransports = self.transports.slice(0);\r\n\r\n      function tryNextTransport() {\r\n        if (!self.connected && !self.disconnected) {\r\n          self.connecting = false;\r\n          clearTimeout(self.connectTimeoutTimer);\r\n\r\n          if (self.options['try multiple transports']) {\r\n            while (self.remainingTransports.length > 0\r\n                   && self.remainingTransports.splice(0,1)[0] != self.transport.name) {}\r\n\r\n            if (self.remainingTransports.length){\r\n              connect(self.remainingTransports);\r\n            } else {\r\n              self.publish('connect_failed');\r\n            }\r\n          } else {\r\n            self.publish('connect_failed');\r\n          }\r\n        }\r\n      }\r\n\r\n\r\n      function connect (transports){\r\n        if (self.transport) {\r\n            self.transport.clearTimeouts();\r\n            self.transport.clearEventHandlers();\r\n        }\r\n\r\n        self.transport = self.getTransport(transports);\r\n        if (!self.transport || self.disconnected) return self.publish('connect_failed');\r\n\r\n        // once the transport is ready (i.e. page is fully loaded)\r\n        self.transport.ready(self, function () {\r\n          self.connecting = true;\r\n          self.publish('connecting', self.transport.name);\r\n          self.transport.open(tryNextTransport);\r\n\r\n          if (self.options['connect timeout']) {\r\n            self.connectTimeoutTimer = setTimeout(function () {\r\n              tryNextTransport();\r\n            }, self.options['connect timeout']);\r\n          }\r\n        });\r\n      }\r\n\r\n      connect(self.transports);\r\n\r\n      self.once('connect', function (){\r\n        clearTimeout(self.connectTimeoutTimer);\r\n\r\n        fn && typeof fn == 'function' && fn();\r\n      });\r\n    });\r\n\r\n    if (this.options['skipped handshake data']) {\r\n      // /v4/c protocol\r\n      var data = this.options['skipped handshake data'];\r\n      // There is no need for the client to know a Socket ID with this protocol\r\n      // Can probably just use some dummy/random/timestamp thing as session id, it is completely opaque, on server too\r\n      // It can also be filled retroactively after being sent from the server inside a WS message (trouter.connected),\r\n      // but I don't think we need to bother.\r\n      onHandshakeComplete('v4c-' + new Date().getTime(), data.timeout, data.timeout, 'websocket');\r\n    } else {\r\n      this.handshake(onHandshakeComplete);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Clears and sets a new heartbeat timeout using the value given by the\r\n   * server during the handshake.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.setHeartbeatTimeout = function () {\r\n    clearTimeout(this.heartbeatTimeoutTimer);\r\n\r\n    var self = this;\r\n    this.heartbeatTimeoutTimer = setTimeout(function () {\r\n      self.transport.onClose();\r\n    }, this.heartbeatTimeout);\r\n  };\r\n\r\n  /**\r\n   * Sends a message.\r\n   *\r\n   * @param {Object} data packet.\r\n   * @returns {io.Socket}\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.packet = function (data) {\r\n    if (this.connected && !this.doBuffer) {\r\n      this.transport.packet(data);\r\n    } else {\r\n      this.buffer.push(data);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Sets buffer state\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.setBuffer = function (v) {\r\n    this.doBuffer = v;\r\n\r\n    if (!v && this.connected && this.buffer.length) {\r\n      this.transport.payload(this.buffer);\r\n      this.buffer = [];\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Disconnect the established connect.\r\n   *\r\n   * @returns {io.Socket}\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.disconnect = function () {\r\n    if (this.connected || this.connecting) {\r\n      if (this.open) {\r\n        this.of('').packet({ type: 'disconnect' });\r\n      }\r\n\r\n      // handle disconnection immediately\r\n      this.onDisconnect('booted');\r\n    }\r\n    this.disconnected = true;\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Disconnects the socket with a sync XHR.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.disconnectSync = function () {\r\n    // ensure disconnection\r\n    var xhr = io.util.request()\r\n      , uri = this.resource + '/' + io.protocol + '/' + this.sessionid;\r\n\r\n    xhr.open('GET', uri, true);\r\n\r\n    // handle disconnection immediately\r\n    this.onDisconnect('booted');\r\n  };\r\n\r\n  /**\r\n   * Check if we need to use cross domain enabled transports. Cross domain would\r\n   * be a different port or different domain name.\r\n   *\r\n   * @returns {Boolean}\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.isXDomain = function () {\r\n\r\n    var port = global.location.port ||\r\n      ('https:' == global.location.protocol ? 443 : 80);\r\n\r\n    return this.options.host !== global.location.hostname\r\n      || this.options.port != port;\r\n  };\r\n\r\n  /**\r\n   * Called upon handshake.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onConnect = function () {\r\n    if (!this.connected) {\r\n      this.connected = true;\r\n      this.connecting = false;\r\n      if (!this.doBuffer) {\r\n        // make sure to flush the buffer\r\n        this.setBuffer(false);\r\n      }\r\n      this.emit('connect');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called when the transport opens\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onOpen = function () {\r\n    this.open = true;\r\n  };\r\n\r\n  /**\r\n   * Called when the transport closes.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onClose = function () {\r\n    this.open = false;\r\n    clearTimeout(this.heartbeatTimeoutTimer);\r\n  };\r\n\r\n  /**\r\n   * Called when the transport first opens a connection\r\n   *\r\n   * @param text\r\n   */\r\n\r\n  Socket.prototype.onPacket = function (packet) {\r\n    this.of(packet.endpoint).onPacket(packet);\r\n  };\r\n\r\n  /**\r\n   * Handles an error.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onError = function (err) {\r\n    if (err && err.advice) {\r\n      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {\r\n        this.disconnect();\r\n        if (this.options.reconnect) {\r\n          this.reconnect();\r\n        }\r\n      }\r\n    }\r\n\r\n    this.publish('error', err && err.reason ? err.reason : err);\r\n  };\r\n\r\n  /**\r\n   * Called when the transport disconnects.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onDisconnect = function (reason) {\r\n    var wasConnected = this.connected\r\n      , wasConnecting = this.connecting;\r\n\r\n    this.connected = false;\r\n    this.connecting = false;\r\n    this.open = false;\r\n\r\n    if (wasConnected || wasConnecting) {\r\n      this.transport.close();\r\n      this.transport.clearTimeouts();\r\n      if (wasConnected) {\r\n        this.publish('disconnect', reason);\r\n\r\n        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {\r\n          this.reconnect();\r\n        }\r\n      } else {\r\n        this.publish('close_during_connecting', reason);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called upon reconnection.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.reconnect = function () {\r\n    this.reconnecting = true;\r\n    this.reconnectionAttempts = 0;\r\n    this.reconnectionDelay = this.options['reconnection delay'];\r\n\r\n    var self = this\r\n      , maxAttempts = this.options['max reconnection attempts']\r\n      , tryMultiple = this.options['try multiple transports']\r\n      , limit = this.options['reconnection limit'];\r\n\r\n    function reset () {\r\n      if (self.connected) {\r\n        for (var i in self.namespaces) {\r\n          if (self.namespaces.hasOwnProperty(i) && '' !== i) {\r\n              self.namespaces[i].packet({ type: 'connect' });\r\n          }\r\n        }\r\n        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);\r\n      }\r\n\r\n      clearTimeout(self.reconnectionTimer);\r\n\r\n      self.removeListener('connect_failed', maybeReconnect);\r\n      self.removeListener('connect', maybeReconnect);\r\n\r\n      self.reconnecting = false;\r\n\r\n      delete self.reconnectionAttempts;\r\n      delete self.reconnectionDelay;\r\n      delete self.reconnectionTimer;\r\n      delete self.redoTransports;\r\n\r\n      self.options['try multiple transports'] = tryMultiple;\r\n    };\r\n\r\n    function maybeReconnect () {\r\n      if (!self.reconnecting) {\r\n        return;\r\n      }\r\n\r\n      if (self.connected) {\r\n        return reset();\r\n      };\r\n\r\n      if (self.connecting && self.reconnecting) {\r\n        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);\r\n      }\r\n\r\n      if (self.reconnectionAttempts++ >= maxAttempts) {\r\n        if (!self.redoTransports) {\r\n          self.on('connect_failed', maybeReconnect);\r\n          self.options['try multiple transports'] = true;\r\n          self.transport = self.getTransport();\r\n          self.redoTransports = true;\r\n          self.connect();\r\n        } else {\r\n          self.publish('reconnect_failed');\r\n          reset();\r\n        }\r\n      } else {\r\n        if (self.reconnectionDelay < limit) {\r\n          self.reconnectionDelay *= 2; // exponential back off\r\n        }\r\n\r\n        self.connect();\r\n        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);\r\n        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);\r\n      }\r\n    };\r\n\r\n    this.options['try multiple transports'] = false;\r\n    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);\r\n\r\n    this.on('connect', maybeReconnect);\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , 'undefined' === typeof global ? window : global\r\n);\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.SocketNamespace = SocketNamespace;\r\n\r\n  /**\r\n   * Socket namespace constructor.\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   */\r\n\r\n  function SocketNamespace (socket, name) {\r\n    this.socket = socket;\r\n    this.name = name || '';\r\n    this.flags = {};\r\n    this.json = new Flag(this, 'json');\r\n    this.ackPackets = 0;\r\n    this.acks = {};\r\n  };\r\n\r\n  /**\r\n   * Apply EventEmitter mixin.\r\n   */\r\n\r\n  io.util.mixin(SocketNamespace, io.EventEmitter);\r\n\r\n  /**\r\n   * Copies emit since we override it\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;\r\n\r\n  /**\r\n   * Creates a new namespace, by proxying the request to the socket. This\r\n   * allows us to use the synax as we do on the server.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  SocketNamespace.prototype.of = function () {\r\n    return this.socket.of.apply(this.socket, arguments);\r\n  };\r\n\r\n  /**\r\n   * Sends a packet.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  SocketNamespace.prototype.packet = function (packet) {\r\n    packet.endpoint = this.name;\r\n    this.socket.packet(packet);\r\n    this.flags = {};\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Sends a message\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  SocketNamespace.prototype.send = function (data, fn) {\r\n    var packet = {\r\n        type: this.flags.json ? 'json' : 'message'\r\n      , data: data\r\n    };\r\n\r\n    if ('function' == typeof fn) {\r\n      packet.id = ++this.ackPackets;\r\n      packet.ack = true;\r\n      this.acks[packet.id] = fn;\r\n    }\r\n\r\n    return this.packet(packet);\r\n  };\r\n\r\n  /**\r\n   * Emits an event\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  SocketNamespace.prototype.emit = function (name) {\r\n    var args = Array.prototype.slice.call(arguments, 1)\r\n      , lastArg = args[args.length - 1]\r\n      , packet = {\r\n            type: 'event'\r\n          , name: name\r\n        };\r\n\r\n    if ('function' == typeof lastArg) {\r\n      packet.id = ++this.ackPackets;\r\n      packet.ack = 'data';\r\n      this.acks[packet.id] = lastArg;\r\n      args = args.slice(0, args.length - 1);\r\n    }\r\n\r\n    packet.args = args;\r\n\r\n    return this.packet(packet);\r\n  };\r\n\r\n  /**\r\n   * Disconnects the namespace\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  SocketNamespace.prototype.disconnect = function () {\r\n    if (this.name === '') {\r\n      this.socket.disconnect();\r\n    } else {\r\n      this.packet({ type: 'disconnect' });\r\n      this.$emit('disconnect');\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Handles a packet\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  SocketNamespace.prototype.onPacket = function (packet) {\r\n    var self = this;\r\n\r\n    function ack () {\r\n      self.packet({\r\n          type: 'ack'\r\n        , args: io.util.toArray(arguments)\r\n        , ackId: packet.id\r\n      });\r\n    };\r\n\r\n    switch (packet.type) {\r\n      case 'connect':\r\n        this.$emit('connect');\r\n        break;\r\n\r\n      case 'disconnect':\r\n        if (this.name === '') {\r\n          this.socket.onDisconnect(packet.reason || 'booted');\r\n        } else {\r\n          this.$emit('disconnect', packet.reason || '');\r\n        }\r\n        break;\r\n\r\n      case 'message':\r\n      case 'json':\r\n        var params = ['message', packet.data];\r\n\r\n        if (packet.ack == 'data') {\r\n          params.push(ack);\r\n        } else if (packet.ack) {\r\n          this.packet({ type: 'ack', ackId: packet.id });\r\n        }\r\n\r\n        this.$emit.apply(this, params);\r\n        break;\r\n\r\n      case 'event':\r\n        var params = [packet.name].concat(packet.args);\r\n\r\n        if (packet.ack == 'data')\r\n          params.push(ack);\r\n\r\n        this.$emit.apply(this, params);\r\n        break;\r\n\r\n      case 'ack':\r\n        if (this.acks[packet.ackId]) {\r\n          this.acks[packet.ackId].apply(this, packet.args);\r\n          delete this.acks[packet.ackId];\r\n        }\r\n        break;\r\n\r\n      case 'error':\r\n        if (packet.advice){\r\n          this.socket.onError(packet);\r\n        } else {\r\n          if (packet.reason == 'unauthorized') {\r\n            this.$emit('connect_failed', packet.reason);\r\n          } else {\r\n            this.$emit('error', packet.reason);\r\n          }\r\n        }\r\n        break;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Flag interface.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  function Flag (nsp, name) {\r\n    this.namespace = nsp;\r\n    this.name = name;\r\n  };\r\n\r\n  /**\r\n   * Send a message\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  Flag.prototype.send = function () {\r\n    this.namespace.flags[this.name] = true;\r\n    this.namespace.send.apply(this.namespace, arguments);\r\n  };\r\n\r\n  /**\r\n   * Emit an event\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  Flag.prototype.emit = function () {\r\n    this.namespace.flags[this.name] = true;\r\n    this.namespace.emit.apply(this.namespace, arguments);\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.websocket = WS;\r\n\r\n  /**\r\n   * The WebSocket transport uses the HTML5 WebSocket API to establish an\r\n   * persistent connection with the Socket.IO server. This transport will also\r\n   * be inherited by the FlashSocket fallback as it provides a API compatible\r\n   * polyfill for the WebSockets.\r\n   *\r\n   * @constructor\r\n   * @extends {io.Transport}\r\n   * @api public\r\n   */\r\n\r\n  function WS (socket) {\r\n    io.Transport.apply(this, arguments);\r\n  };\r\n\r\n  /**\r\n   * Inherits from Transport.\r\n   */\r\n\r\n  io.util.inherit(WS, io.Transport);\r\n\r\n  /**\r\n   * Transport name\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  WS.prototype.name = 'websocket';\r\n\r\n  function empty() { };\r\n\r\n  /**\r\n   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach\r\n   * all the appropriate listeners to handle the responses from the server.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  WS.prototype.open = function (connectErrorCallback) {\r\n    var query = io.util.query(this.socket.options.query)\r\n      , self = this\r\n      , Socket\r\n\r\n    this.connectErrorCallback = connectErrorCallback;\r\n\r\n    if (!Socket) {\r\n      Socket = global.MozWebSocket || global.WebSocket;\r\n    }\r\n\r\n    this.websocket = new Socket(this.prepareUrl(query));\r\n\r\n    this.websocket.onopen = function () {\r\n      self.onOpen();\r\n      self.socket.setBuffer(false);\r\n    };\r\n    this.websocket.onmessage = function (ev) {\r\n      self.onData(ev.data);\r\n    };\r\n    this.websocket.onclose = function () {\r\n      self.onClose();\r\n      self.socket.setBuffer(true);\r\n    };\r\n    this.websocket.onerror = function (e) {\r\n      self.onError(e);\r\n    };\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Send a message to the Socket.IO server. The message will automatically be\r\n   * encoded in the correct message format.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  WS.prototype.send = function (data) {\r\n    this.websocket.send(data);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Payload\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  WS.prototype.payload = function (arr) {\r\n    for (var i = 0, l = arr.length; i < l; i++) {\r\n      this.packet(arr[i]);\r\n    }\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Disconnect the established `WebSocket` connection.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  WS.prototype.close = function () {\r\n    this.websocket.close();\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Handle the errors that `WebSocket` might be giving when we\r\n   * are attempting to connect or send messages.\r\n   *\r\n   * @param {Error} e The error.\r\n   * @api private\r\n   */\r\n\r\n  WS.prototype.onError = function (e) {\r\n      if (this.connectErrorCallback !== undefined) {\r\n        this.connectErrorCallback();\r\n        this.connectErrorCallback = undefined;\r\n      }\r\n      this.socket.onError(e);\r\n  };\r\n\r\n  /**\r\n   * Returns the appropriate scheme for the URI generation.\r\n   *\r\n   * @api private\r\n   */\r\n  WS.prototype.scheme = function () {\r\n    return this.socket.options.secure ? 'wss' : 'ws';\r\n  };\r\n\r\n  /**\r\n   * Checks if the browser has support for native `WebSockets` and that\r\n   * it's not the polyfill created for the FlashSocket transport.\r\n   *\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  WS.check = function () {\r\n    return ('WebSocket' in global && !('__addTask' in WebSocket))\r\n          || 'MozWebSocket' in global;\r\n  };\r\n\r\n  /**\r\n   * Check if the `WebSocket` transport support cross domain communications.\r\n   *\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  WS.xdomainCheck = function () {\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Clears the event listeners attached to the `WebSocket` transport object.\r\n   *\r\n   * @api private\r\n   */\r\n  WS.prototype.clearEventHandlers = function() {\r\n      if (this.websocket) {\r\n          this.websocket.onopen = this.websocket.onmessage = this.websocket.onclose = this.websocket.onerror = empty;\r\n      }\r\n      return this;\r\n  };\r\n\r\n  /**\r\n   * Add the transport to your public io.transports array.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  io.transports.push('websocket');\r\n\r\n})(\r\n    'undefined' != typeof io ? io.Transport : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , 'undefined' === typeof global ? window : global\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  exports.XHR = XHR;\r\n\r\n  /**\r\n   * XHR constructor\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   */\r\n\r\n  function XHR (socket) {\r\n    if (!socket) return;\r\n\r\n    io.Transport.apply(this, arguments);\r\n  };\r\n\r\n  /**\r\n   * Inherits from Transport.\r\n   */\r\n\r\n  io.util.inherit(XHR, io.Transport);\r\n\r\n  /**\r\n   * Establish a connection\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  XHR.prototype.open = function () {\r\n    this.socket.setBuffer(false);\r\n    this.onOpen();\r\n    this.get();\r\n\r\n    // we need to make sure the request succeeds since we have no indication\r\n    // whether the request opened or not until it succeeded.\r\n    this.setCloseTimeout();\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Check if we need to send data to the Socket.IO server, if we have data in our\r\n   * buffer we encode it and forward it to the `post` method.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  XHR.prototype.payload = function (payload) {\r\n    var msgs = [];\r\n\r\n    for (var i = 0, l = payload.length; i < l; i++) {\r\n      msgs.push(io.parser.encodePacket(payload[i]));\r\n    }\r\n\r\n    this.send(io.parser.encodePayload(msgs));\r\n  };\r\n\r\n  /**\r\n   * Send data to the Socket.IO server.\r\n   *\r\n   * @param data The message\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  XHR.prototype.send = function (data) {\r\n    this.post(data);\r\n    return this;\r\n  };\r\n\r\n  function empty () { };\r\n\r\n  /**\r\n   * Posts a encoded message to the Socket.IO server.\r\n   *\r\n   * IMPORTANT: Note that only one of these requests should be in flight at any time,\r\n   * see the mutation of `doBuffer` via `setBuffer`, and where `post` is called from.\r\n   * Subsequent messages will be queued, and sent out on the next call\r\n   * to `setBuffer(false)` (e.g. from the success callback).\r\n   *\r\n   * @param {String} data A encoded message.\r\n   * @api private\r\n   */\r\n  XHR.prototype.post = function (data) {\r\n    var self = this;\r\n    this.socket.setBuffer(true);\r\n\r\n    this.sendXHR = this.request('POST');\r\n\r\n    function stateChange () {\r\n      if (this.readyState == 4) {\r\n        this.onreadystatechange = empty;\r\n\r\n        if (this.status == 200) {\r\n          clearTimeout(this.ackTimeoutTimer);\r\n\r\n          // this flushes the buffer, which can trigger another call to `post`,\r\n          // that will overwrite `self.sendXHR`\r\n          self.socket.setBuffer(false);\r\n\r\n          // at this point, self.sendXHR may already be the subsequent request\r\n        } else {\r\n          self.onClose();\r\n        }\r\n      }\r\n    }\r\n\r\n    function onload () {\r\n      this.onload = empty;\r\n      self.socket.setBuffer(false);\r\n    };\r\n\r\n    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {\r\n      this.sendXHR.onload = this.sendXHR.onerror = onload;\r\n    } else {\r\n      this.sendXHR.onreadystatechange = stateChange;\r\n    }\r\n\r\n    this.sendXHR.send(data);\r\n    self.sendXHR.ackTimeoutTimer = setTimeout(function () {\r\n      self.onClose();\r\n    }, self.socket.options.ackTimeoutMs);\r\n  };\r\n\r\n  /**\r\n   * Disconnects the established `XHR` connection.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  XHR.prototype.close = function () {\r\n    this.onClose();\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Generates a configured XHR request\r\n   *\r\n   * @param {String} url The url that needs to be requested.\r\n   * @param {String} method The method the request should use.\r\n   * @returns {XMLHttpRequest}\r\n   * @api private\r\n   */\r\n\r\n  XHR.prototype.request = function (method) {\r\n    var req = io.util.request(this.socket.isXDomain())\r\n      , query = io.util.query(this.socket.options.query, 't=' + +new Date);\r\n\r\n    req.open(method || 'GET', this.prepareUrl(query), true);\r\n\r\n    var headers = this.socket.options.requestHeaders;\r\n    if (headers !== undefined) {\r\n      Object.keys(headers).forEach(function(name) {\r\n        req.setRequestHeader(name, headers[name]);\r\n      });\r\n    }\r\n\r\n    if (method == 'POST') {\r\n      try {\r\n        if (req.setRequestHeader) {\r\n          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\r\n        } else {\r\n          // XDomainRequest\r\n          req.contentType = 'text/plain';\r\n        }\r\n      } catch (e) {}\r\n    }\r\n\r\n    return req;\r\n  };\r\n\r\n  /**\r\n   * Returns the scheme to use for the transport URLs.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  XHR.prototype.scheme = function () {\r\n    return this.socket.options.secure ? 'https' : 'http';\r\n  };\r\n\r\n  /**\r\n   * Check if the XHR transports are supported\r\n   *\r\n   * @param {Boolean} xdomain Check if we support cross domain requests.\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  XHR.check = function (socket, xdomain) {\r\n\r\n    try {\r\n      var request = io.util.request(xdomain),\r\n          usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),\r\n          socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),\r\n          isXProtocol = (socketProtocol != global.location.protocol);\r\n      if (request && !(usesXDomReq && isXProtocol)) {\r\n        return true;\r\n      }\r\n    } catch(e) {}\r\n\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Check if the XHR transport supports cross domain requests.\r\n   *\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  XHR.xdomainCheck = function () {\r\n    return XHR.check(null, true);\r\n  };\r\n\r\n  /**\r\n   * Clears the event listeners attached to the XHR transport object.\r\n   *\r\n   * @api private\r\n   */\r\n  XHR.prototype.clearEventHandlers = function () {\r\n      if (this.sendXHR) {\r\n          this.sendXHR.onreadystatechange = this.sendXHR.onload = empty;\r\n      }\r\n      return this;\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io.Transport : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , 'undefined' === typeof global ? window : global\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports['xhr-polling'] = XHRPolling;\r\n\r\n  /**\r\n   * The XHR-polling transport uses long polling XHR requests to create a\r\n   * \"persistent\" connection with the server.\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   */\r\n\r\n  function XHRPolling () {\r\n    io.Transport.XHR.apply(this, arguments);\r\n  };\r\n\r\n  /**\r\n   * Inherits from XHR transport.\r\n   */\r\n\r\n  io.util.inherit(XHRPolling, io.Transport.XHR);\r\n\r\n  /**\r\n   * Merge the properties from XHR transport\r\n   */\r\n\r\n  io.util.merge(XHRPolling, io.Transport.XHR);\r\n\r\n  /**\r\n   * Transport name\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  XHRPolling.prototype.name = 'xhr-polling';\r\n\r\n  /**\r\n   * Establish a connection, for iPhone and Android this will be done once the page\r\n   * is loaded.\r\n   *\r\n   * @returns {Transport} Chaining.\r\n   * @api public\r\n   */\r\n\r\n  XHRPolling.prototype.open = function (connectErrorCallback) {\r\n    var self = this;\r\n\r\n    self.connectErrorCallback = connectErrorCallback;\r\n\r\n    io.Transport.XHR.prototype.open.call(self);\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Starts a XHR request to wait for incoming messages.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  function empty () {};\r\n\r\n  XHRPolling.prototype.get = function () {\r\n    if (!this.isOpened) return;\r\n\r\n    var self = this;\r\n\r\n    function stateChange () {\r\n      if (this.readyState == 4) {\r\n        this.onreadystatechange = empty;\r\n\r\n        if (this.status == 200) {\r\n          self.connectErrorCallback = undefined;\r\n          self.onData(this.responseText);\r\n          self.get();\r\n        } else {\r\n          self.onClose();\r\n\r\n          if (self.connectErrorCallback !== undefined) {\r\n            self.connectErrorCallback();\r\n            self.connectErrorCallback = undefined;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    function onload () {\r\n      self.connectErrorCallback = undefined;\r\n      this.onload = empty;\r\n      this.onerror = empty;\r\n      self.onData(this.responseText);\r\n      self.get();\r\n    };\r\n\r\n    function onerror () {\r\n      self.onClose();\r\n\r\n      if (self.connectErrorCallback !== undefined) {\r\n        self.connectErrorCallback();\r\n        self.connectErrorCallback = undefined;\r\n      }\r\n    };\r\n\r\n    this.xhr = this.request();\r\n\r\n    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {\r\n      this.xhr.onload = onload;\r\n      this.xhr.onerror = onerror;\r\n    } else {\r\n      this.xhr.onreadystatechange = stateChange;\r\n    }\r\n\r\n    this.xhr.send(null);\r\n  };\r\n\r\n  /**\r\n   * Handle the unclean close behavior.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  XHRPolling.prototype.onClose = function () {\r\n    io.Transport.XHR.prototype.onClose.call(this);\r\n\r\n    if (this.xhr) {\r\n      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;\r\n      try {\r\n        this.xhr.abort();\r\n      } catch(e){}\r\n      this.xhr = null;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Webkit based browsers show a infinit spinner when you start a XHR request\r\n   * before the browsers onload event is called so we need to defer opening of\r\n   * the transport until the onload event is called. Wrapping the cb in our\r\n   * defer method solve this.\r\n   *\r\n   * @param {Socket} socket The socket instance that needs a transport\r\n   * @param {Function} fn The callback\r\n   * @api private\r\n   */\r\n\r\n  XHRPolling.prototype.ready = function (socket, fn) {\r\n    var self = this;\r\n\r\n    io.util.defer(function () {\r\n      fn.call(self);\r\n    });\r\n  };\r\n\r\n   /**\r\n   * Clears the event listeners attached to the XHR transport object.\r\n   *\r\n   * @api private\r\n   */\r\n  XHRPolling.prototype.clearEventHandlers = function () {\r\n      io.Transport.XHR.prototype.clearEventHandlers.call(this);\r\n\r\n      if (this.xhr) {\r\n          this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;\r\n      }\r\n      return this;\r\n  }\r\n\r\n  /**\r\n   * Add the transport to your public io.transports array.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  io.transports.push('xhr-polling');\r\n\r\n})(\r\n    'undefined' != typeof io ? io.Transport : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , 'undefined' === typeof global ? window : global\r\n);\r\n\r\nexports.io = io;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib_temp/socket.io.js\n// module id = 12\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 13\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 14\n// module chunks = 0","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { Timeout, Timespan, toJson } from './Common';\r\nimport { CLIENT_VERSION } from './Constants';\r\nimport { HttpHeaders, ITelemetrySender, LogProvider, TrouterTelemetrySettings } from './Interfaces';\r\nimport { IClientInfo, ITrouterRequest, ServerState } from './InternalInterfaces';\r\nimport { Logger } from './Logger';\r\n\r\n/**\r\n * Data for trouter response\r\n */\r\nexport class ResponseData {\r\n    public status: number = 200;\r\n    public headers?: HttpHeaders = {};\r\n    public body: string = '';\r\n    public sentTS: number | undefined;\r\n\r\n    public constructor(public id: number) { }\r\n}\r\n\r\n// Possible telemetry events\r\nexport enum ClientEventName {\r\n    Connected = 'trouter_js_client_connected',\r\n    Disconnected = 'trouter_js_client_disconnected',\r\n    Error = 'trouter_js_client_error',\r\n    Progress = 'trouter_js_client_progress',\r\n    Response = 'trouter_js_client_response',\r\n    Request = 'trouter_js_client_request',\r\n    CheckConnection = 'trouter_js_client_check_connection',\r\n    Registration = 'trouter_js_client_registration',\r\n    Unregistration = 'trouter_js_client_unregistration'\r\n}\r\nexport type EnabledEvents = { [key in ClientEventName]: boolean };\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\r\nexport interface IAllTelemetryEventsSettings extends EnabledEvents {\r\n}\r\n\r\n/**\r\n * Stores one step of connection process\r\n */\r\nexport class TrackerStep {\r\n    public constructor(\r\n        public stepName: string,\r\n        public operation: string,\r\n        public delta: number,\r\n        public ts: number,\r\n        public error?: string\r\n    ) { }\r\n}\r\n\r\ntype PropertyBagValue = number | string | boolean | { [key: number]: boolean } | undefined;\r\n\r\n/**\r\n * Base class for something that can be used as a property bag\r\n */\r\nexport class Properties {\r\n    hasError?: boolean;\r\n    error?: string;\r\n    [index: string]: PropertyBagValue;\r\n}\r\n\r\n/**\r\n * Information about connection\r\n */\r\nclass ConnectedInfo {\r\n    public numberOfPingReplies: number = 0;\r\n    public connectedTimestamp: number = 0;\r\n    public isNewUrl: boolean = false;\r\n    public transportType: string = '';\r\n    public connectionNumber: number = 0;\r\n}\r\n\r\n/**\r\n * Default values for IEventLogSettings\r\n */\r\nclass EventLogSettings implements TrouterTelemetrySettings, IAllTelemetryEventsSettings {\r\n    public enabled = false;\r\n    public numberOfStepsToMaintain = 40;\r\n    public logHealthCheckError = false;\r\n    public sendProgressTimeoutSecs = 55;\r\n    public logSendPingError = false;\r\n    public maxBackoffInMs = 120000;\r\n\r\n    public trouter_js_client_connected = false;\r\n    public trouter_js_client_disconnected = false;\r\n    public trouter_js_client_error = false;\r\n    public trouter_js_client_progress = false;\r\n    public trouter_js_client_response = false;\r\n    public trouter_js_client_request = false;\r\n    public trouter_js_client_registration = false;\r\n    public trouter_js_client_unregistration = false;\r\n\r\n    /** This event is ENABLED by default */\r\n    public trouter_js_client_check_connection = true;\r\n}\r\n\r\n/**\r\n * Telemetry sender\r\n */\r\nexport class ConnectionTracker {\r\n    private logger: Logger;\r\n    private steps: TrackerStep[];\r\n    private connectionAttempt: number;\r\n    private totalStepCount: number;\r\n    private beginTimestamp: Timespan;\r\n    private eventLogSettings: TrouterTelemetrySettings;\r\n    private connectedInfo: ConnectedInfo;\r\n    private progressTimeout?: Timeout;\r\n    private eventLogger?: ITelemetrySender;\r\n\r\n    public constructor(\r\n        logfunc: LogProvider,\r\n        private clientId: number,\r\n        private clientInfo: Readonly<IClientInfo>,\r\n        private getServerState: () => ServerState,\r\n        private endpointId?: string,\r\n        public clientCorrelationID?: string,\r\n        private environment?: string\r\n    ) {\r\n        this.logger = new Logger('ConnectionTracker', logfunc);\r\n        this.clientCorrelationID = clientCorrelationID !== undefined ? clientCorrelationID : '';\r\n        this.steps = [];\r\n        this.connectionAttempt = 0;\r\n        this.totalStepCount = 0;\r\n        this.beginTimestamp = new Timespan();\r\n        this.eventLogSettings = new EventLogSettings();\r\n        this.connectedInfo = new ConnectedInfo();\r\n    }\r\n\r\n    public enable(telemetrySender: ITelemetrySender) {\r\n        this.eventLogSettings.enabled = true;\r\n        this.eventLogger = telemetrySender;\r\n    }\r\n\r\n    public disable() {\r\n        this.eventLogSettings.enabled = false;\r\n    }\r\n\r\n    public sendProgress(context: Properties): void {\r\n        // connect truncates steps array. this check ensures that a progress event is only sent out if the client is not connected\r\n        if (this.steps.length > 0) {\r\n            this.sendTelemetry(ClientEventName.Progress, context, this.steps);\r\n        }\r\n    }\r\n\r\n    public cancelProgressTimer(): void {\r\n        if (this.progressTimeout !== undefined) {\r\n            clearTimeout(this.progressTimeout);\r\n            this.progressTimeout = undefined;\r\n        }\r\n    }\r\n\r\n    public resetProgressSendTimer() {\r\n        this.cancelProgressTimer();\r\n\r\n        // send connection steps after a timeout\r\n        // this timeout may fire if auth callback never comes or the client is stuck in a loop to get connected\r\n        if (this.eventLogSettings.sendProgressTimeoutSecs !== undefined && this.eventLogSettings.sendProgressTimeoutSecs > 0) {\r\n            this.progressTimeout = setTimeout(() => {\r\n                this.sendProgress({\r\n                    reason: 'timeout',\r\n                    timeoutSecs: this.eventLogSettings.sendProgressTimeoutSecs\r\n                });\r\n            }, 1000 * this.eventLogSettings.sendProgressTimeoutSecs);\r\n        }\r\n    }\r\n\r\n    public setConnectedInfo(isNewUrl: boolean, transportType: string): void {\r\n        this.connectedInfo.numberOfPingReplies = 0;\r\n        this.connectedInfo.connectedTimestamp = Date.now();\r\n        this.connectedInfo.isNewUrl = isNewUrl;\r\n        this.connectedInfo.transportType = transportType;\r\n        ++this.connectedInfo.connectionNumber;\r\n    }\r\n\r\n    public clearConnectedInfo(): void {\r\n        this.connectedInfo.numberOfPingReplies = 0;\r\n        this.connectedInfo.connectedTimestamp = 0;\r\n        this.connectedInfo.isNewUrl = true;\r\n        this.connectedInfo.transportType = '';\r\n    }\r\n\r\n    // Copies from\r\n    // source {\r\n    //    propName: value\r\n    // }\r\n    // to\r\n    // dest {\r\n    //    propName: { value: actualValue }\r\n    // }\r\n    public copyProperties(dest: Record<string, { value: PropertyBagValue }>, source: Properties): void {\r\n        // copy properties from source and add in a format expected by logger\r\n        for (const prop of Object.keys(source)) {\r\n            if (source[prop] !== undefined) {\r\n                // replace hyphen by _\r\n                dest[prop.replace(/-/g, '_')] = { value: source[prop] };\r\n            }\r\n        }\r\n    }\r\n\r\n    public increasePingResponseCount() {\r\n        ++this.connectedInfo.numberOfPingReplies;\r\n    }\r\n\r\n    /**\r\n     * @param eventName Telemetry event name\r\n     * @param eventProperties Event property bag\r\n     * @param progress\r\n     */\r\n    public sendTelemetry(\r\n        eventName: ClientEventName,\r\n        eventProperties: Properties,\r\n        progress: unknown[]\r\n    ) {\r\n        try {\r\n            if (this.eventLogSettings.enabled === true\r\n                && this.eventLogSettings[eventName] === true\r\n                && this.eventLogger !== undefined\r\n            ) {\r\n                const serverState = this.getServerState();\r\n                const clientEvent = {\r\n                    name: eventName,\r\n                    properties: {\r\n                        connectionAttempt: { value: this.connectionAttempt },\r\n                        epid: { value: this.endpointId },\r\n                        clientCorrelationID: { value: this.clientCorrelationID },\r\n                        steps: { value: toJson(progress) },\r\n                        clientID: { value: this.clientId },\r\n                        eventVersion: { value: 3 }, // version of telemetry events,\r\n                        environment: { value: this.environment },\r\n                        cv: { value: CLIENT_VERSION },\r\n                        ua: { value: this.clientInfo.ua },\r\n\r\n                        // Copy ServerState\r\n                        connectionId: { value: serverState.connectionId },\r\n                        connectedClientId: { value: serverState.connectedClientId },\r\n                        domId: { value: serverState.domId },\r\n                        url: { value: serverState.unsecureUrl },\r\n                        surl: { value: serverState.url },\r\n                        ttlInSecs: { value: serverState.getRemainingTtlInSec() },\r\n\r\n                        // Copy this.connectedInfo\r\n                        numberOfPingReplies: { value: this.connectedInfo.numberOfPingReplies },\r\n                        connectedTimestamp: { value: this.connectedInfo.connectedTimestamp },\r\n                        isNewUrl: { value: this.connectedInfo.isNewUrl },\r\n                        transportType: { value: this.connectedInfo.transportType },\r\n                        connectionNumber: { value: this.connectedInfo.connectionNumber }\r\n                    }\r\n                };\r\n\r\n                this.copyProperties(clientEvent.properties, eventProperties);\r\n\r\n                this.eventLogger.logEvent(clientEvent);\r\n            }\r\n        } catch (exc) {\r\n            this.logger.warn(`error in sending event ${eventName}: ${toJson(exc)}`);\r\n        }\r\n    }\r\n\r\n    public createStep(stepName: string, operation: string, error?: string): TrackerStep {\r\n        return new TrackerStep(\r\n            stepName,\r\n            operation,\r\n            this.beginTimestamp.duration,\r\n            Date.now(),\r\n            error);\r\n    }\r\n\r\n    public addStep(tag: string, progressHint: string, error?: string): void {\r\n        if (this.eventLogSettings.enabled === false) {\r\n            return;\r\n        }\r\n\r\n        if (this.steps.length === 0) {\r\n            this.beginTimestamp.reset();\r\n        }\r\n        this.steps.push(this.createStep(tag, progressHint, error));\r\n        ++this.totalStepCount;\r\n        // do not maintain an ever growing list of steps. send a progress event with what is collected so far and clear steps\r\n        // there should be enough context in any event for the server to group events created for the sameonnection\r\n        if (this.eventLogSettings.numberOfStepsToMaintain !== undefined\r\n            && this.steps.length > this.eventLogSettings.numberOfStepsToMaintain\r\n        ) {\r\n            const progress = this.steps.slice(0);\r\n            this.steps.length = 0;\r\n            this.sendTelemetry(ClientEventName.Progress, { reason: 'flush' }, progress);\r\n        }\r\n    }\r\n\r\n    public trackStart(tag: string): void {\r\n        this.addStep(tag, 'start');\r\n    }\r\n\r\n    public trackEnd(tag: string): void {\r\n        this.addStep(tag, 'end');\r\n    }\r\n\r\n    public trackError(tag: string, error: string, addStep: boolean = true, subOperation?: string) {\r\n        if (tag === 'health' && this.eventLogSettings.logHealthCheckError !== true) {\r\n            return;\r\n        }\r\n        if (tag === 'ping' && this.eventLogSettings.logSendPingError === false) {\r\n            return;\r\n        }\r\n\r\n        if (subOperation === undefined) {\r\n            subOperation = 'error';\r\n        }\r\n\r\n        if (addStep === true) {\r\n            this.addStep(tag, subOperation, error);\r\n        }\r\n        this.sendTelemetry(ClientEventName.Error, {}, [this.createStep(tag, subOperation, error)]);\r\n    }\r\n\r\n    public trackProgress(tag: string, subOperation: string): void {\r\n        this.addStep(tag, subOperation);\r\n    }\r\n\r\n    public trackConnected(isNewUrl: boolean, transportType: string): void {\r\n        this.setConnectedInfo(isNewUrl, transportType);\r\n        const progress = this.steps.slice(0);\r\n        const totalSteps = this.totalStepCount;\r\n        const connectionDuration = this.beginTimestamp.duration;\r\n\r\n        // clear steps collected\r\n        this.steps.length = 0;\r\n        this.totalStepCount = 0;\r\n\r\n        this.sendTelemetry(ClientEventName.Connected, {\r\n            stepCount: progress.length,\r\n            totalStepCount: totalSteps,\r\n            connectionEstablishmentMs_Total: connectionDuration\r\n        }, progress);\r\n\r\n        this.cancelProgressTimer();\r\n    }\r\n\r\n    public getSessionLength(): number {\r\n        return Date.now() - this.connectedInfo.connectedTimestamp;\r\n    }\r\n\r\n    public trackDisconnected(context: Properties): void {\r\n        context.sessionLengthMS = this.getSessionLength();\r\n        this.sendTelemetry(ClientEventName.Disconnected, context, []);\r\n        this.resetProgressSendTimer();\r\n    }\r\n\r\n    public trackNewConnection(): void {\r\n        ++this.connectionAttempt;\r\n    }\r\n\r\n    public trackRequest(request?: ITrouterRequest, errorMsg?: string): void {\r\n        const context: Properties = {};\r\n        if (errorMsg !== undefined) {\r\n            context.hasError = true;\r\n            context.error = errorMsg;\r\n        }\r\n        try {\r\n            if (request) {\r\n                context.requestID = request.id;\r\n                context.httpMethod = request.method;\r\n                context.url = request.url;\r\n                context.bodyLength = request.body.length;\r\n                context.shortUrl = request.shortUrl;\r\n                context.requestTimeStamp = request.startTS;\r\n                context.correlationVector = request.correlationVector;\r\n                const headers = request.headers;\r\n                for (const header of Object.keys(headers)) {\r\n                    context[header] = headers[header];\r\n                }\r\n            }\r\n        } catch (exc) {\r\n            context.hasError = true;\r\n            context.error = `${context.error} error creating request context ${toJson(exc)}`;\r\n        }\r\n\r\n        this.sendTelemetry(ClientEventName.Request, context, []);\r\n    }\r\n\r\n    public trackResponse(request?: ITrouterRequest, latencyMS?: number, responseData?: ResponseData, errorMsg?: string): void {\r\n        const context: Properties = {};\r\n        if (errorMsg !== undefined) {\r\n            context.hasError = true;\r\n            context.error = errorMsg;\r\n        }\r\n\r\n        try {\r\n            context.responseTimestamp = responseData !== undefined ? responseData.sentTS : Date.now();\r\n            if (request) {\r\n                context.requestID = request.id;\r\n                context.httpMethod = request.method;\r\n                context.shortUrl = request.shortUrl;\r\n                context.correlationVector = request.correlationVector;\r\n                const headers = request.headers;\r\n                for (const header of Object.keys(headers)) {\r\n                    context[header] = headers[header];\r\n                }\r\n            }\r\n\r\n            if (responseData) {\r\n                context.latencyMS = latencyMS;\r\n                context.responseCode = responseData.status;\r\n                context.responseLength = responseData.body.length;\r\n            }\r\n        } catch (exc) {\r\n            context.hasError = true;\r\n            context.error = `${context.error} error creating response context ${toJson(exc)}`;\r\n        }\r\n\r\n        this.sendTelemetry(ClientEventName.Response, context, []);\r\n    }\r\n\r\n    public sendResponseError(errorMsg: string, request?: ITrouterRequest, responseData?: ResponseData): void {\r\n        this.trackResponse(request, undefined, responseData, errorMsg);\r\n    }\r\n\r\n    public close(): void {\r\n        this.sendProgress({\r\n            reason: 'closed'\r\n        });\r\n        this.steps.length = 0;\r\n        this.cancelProgressTimer();\r\n    }\r\n\r\n    public mergeSettings(settings?: TrouterTelemetrySettings) {\r\n        if (!settings) {\r\n            return;\r\n        }\r\n\r\n        this.eventLogSettings.numberOfStepsToMaintain = Math.min(40,\r\n            Math.max(10, (settings.numberOfStepsToMaintain !== undefined ? settings.numberOfStepsToMaintain : 0)));\r\n\r\n        // min of 55 secs and max allowed is 1 hr\r\n        const newProgressTimeout = Math.min(3600,\r\n            Math.max(55, settings.sendProgressTimeoutSecs !== undefined ? settings.sendProgressTimeoutSecs : 0));\r\n\r\n        this.eventLogSettings.logHealthCheckError = settings.logHealthCheckError;\r\n        this.eventLogSettings.logSendPingError = settings.logSendPingError;\r\n\r\n        // Copy enable/disable flags for all telemetry events\r\n        for (const iterator of Object.keys(ClientEventName).map(k => ClientEventName[<keyof typeof ClientEventName>k])) {\r\n            if (settings[iterator] !== undefined) {\r\n                this.eventLogSettings[iterator] = settings[iterator];\r\n            }\r\n        }\r\n\r\n        if (this.eventLogSettings.sendProgressTimeoutSecs !== newProgressTimeout) {\r\n            this.eventLogSettings.sendProgressTimeoutSecs = newProgressTimeout;\r\n            this.resetProgressSendTimer();\r\n        }\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/ConnectionTracker.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { Logger } from './Logger';\r\nexport type SocketIoEventKind = 'socketerror' | 'reconnecterror' | 'disconnect';\r\n// Empty string means normal disconnect\r\nexport type DisconnectReasonKind = '' | 'dup' | 'unauthorized' | 'badrequest' | 'serviceunavailable' | SocketIoEventKind | 'unknown' | 'skypetoken-deprecated';\r\n\r\n/**\r\n * Disconnect reason format sent when using the /v4/c protocol as part of the socket.io disconnect (`0::`),\r\n * e.g.\r\n * - `0::`\r\n * - `0:::dup`\r\n * - `0:::{\"reason\":\"unauthorized\",\"claims\":\"Bearer token_types=\\\"skype,aad,cae\\\"\"}`\r\n *\r\n * Additionally, it is also used internally for other socket.io events calling `TrouterFsm.onSocketDisconnect` (see usages).\r\n */\r\nexport class DisconnectReason {\r\n    constructor(\r\n        public readonly reason: DisconnectReasonKind,\r\n        public readonly claims?: string,\r\n        public readonly details?: string\r\n    ) { }\r\n\r\n    public static fromRawReason(rawReason: string, logger?: Logger): DisconnectReason {\r\n        if (rawReason === '' || rawReason === 'dup') {\r\n            return new DisconnectReason(rawReason);\r\n        }\r\n\r\n        try {\r\n            const parsedReason = <Partial<DisconnectReason>>JSON.parse(rawReason);\r\n            if (typeof parsedReason !== 'object' || parsedReason.reason === undefined) {\r\n                logger?.error('invalid disconnect reason format');\r\n\r\n                return new DisconnectReason('unknown', undefined, rawReason);\r\n            }\r\n\r\n            return new DisconnectReason(parsedReason.reason, parsedReason.claims, parsedReason.details);\r\n        } catch (e) {\r\n            // Non-JSON string from the `0::` socket.io message is just set \"as is\" as details\r\n            return new DisconnectReason('disconnect', undefined, rawReason);\r\n        }\r\n    }\r\n\r\n    public static fromSocketIoEventData(event: SocketIoEventKind, arg: unknown): DisconnectReason | undefined {\r\n        return typeof arg === 'string' ? new DisconnectReason(event, undefined, arg) : undefined;\r\n    }\r\n\r\n    public toTelemetryString(): string | undefined {\r\n        if (this.reason === 'socketerror' || this.reason === 'reconnecterror' || this.reason === 'disconnect') {\r\n            return this.details;\r\n        }\r\n\r\n        return this.reason;\r\n    }\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/DisconnectReason.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { Timeout } from './Common';\r\nimport { Logger } from './Logger';\r\n\r\n/**\r\n * Settings for detecting times when the timeouts were not called - such as computer sleeping,\r\n * where we want to reset the backoff afterwards\r\n */\r\nexport type GapDetectionSettings = {\r\n    /** backoff will be reset if the detected wait was this times the expected wait */\r\n    tolerance: number,\r\n\r\n    /** minimum wait after which backoff will be reset, to avoid spurious resets due to lack of timer precision */\r\n    minimumWaitMs: number\r\n}\r\n\r\n/**\r\n * Executes callbacks with exponential backoff\r\n */\r\nexport class ExponentialBackoff {\r\n    private backoffId = 0;\r\n    private backoffCount = 0;\r\n    private timerHandle?: Timeout;\r\n    private callback?: (waitStart?: number, expectedWait?: number) => void;\r\n    private previousCompleteTime?: number;\r\n\r\n    public constructor(\r\n        private logger: Logger,\r\n        private maxBackoffInMs: number,\r\n        private gapDetectionSettings: GapDetectionSettings = { tolerance: 2, minimumWaitMs: 10_000 }\r\n    ) { }\r\n\r\n    private static calculateNextBackoffMs(backoffCount: number, maxBackoffInMs: number): number {\r\n        const fudge = 1 + (Math.random() - 0.5) * 0.4; // +/- 20%\r\n        let backoff = 1000 * Math.pow(2, backoffCount) * fudge; // 1s initial\r\n        backoff = Math.round(backoff);\r\n\r\n        return Math.min(maxBackoffInMs, backoff);\r\n    }\r\n\r\n    public setMaxBackoffMs(ms: number) {\r\n        this.maxBackoffInMs = ms;\r\n    }\r\n\r\n    public backoff(taskName: string, handler: () => void): void {\r\n        if (this.timerHandle !== undefined) {\r\n            this.logger.debug('Clearing current back off');\r\n            clearTimeout(this.timerHandle);\r\n            this.timerHandle = undefined;\r\n        }\r\n\r\n        // This detects a situation where the computer/tab likely went to sleep while NOT waiting on backoff,\r\n        // but doing other things (e.g. waiting on fetch, waiting on token provider, etc.),\r\n        // and woke up much later, the operation having failed, triggering a retry after backoff.\r\n        // If a lot of time has passed in sleep, we want to reset that backoff.\r\n        //\r\n        // We are counting on the fact that the operation (fetch, token wait, etc.) should never take significantly longer\r\n        // than the maximum allowed backoff time, to avoid unwanted resets.\r\n        //\r\n        // (If computer woke up while it WAS waiting on backoff, after a long time, it would likely complete that wait\r\n        // immediately, so previousCompleteTime would be very close to the next attempt, thus not triggering this.)\r\n        if (this.previousCompleteTime !== undefined) {\r\n            const elapsed = Date.now() - this.previousCompleteTime;\r\n            // The time to reset this needs to be much longer here, as the operation itself can take quite a long time even under normal circumstances.\r\n            // In practice, based on settings as of February 2024, this can be triggered after a sleep that in some cases needs to be over 10 minutes.\r\n            if (elapsed > this.maxBackoffInMs * this.gapDetectionSettings.tolerance && elapsed > this.gapDetectionSettings.minimumWaitMs) {\r\n                this.logger.info(`Back off for ${taskName} with ID ${this.backoffId} will be reset due to a lot of time having passed since the previous backoff (${elapsed} ms)`);\r\n                this.backoffCount = 0;\r\n                this.previousCompleteTime = undefined;\r\n            }\r\n        }\r\n\r\n        const backoffMs = ExponentialBackoff.calculateNextBackoffMs(this.backoffCount, this.maxBackoffInMs);\r\n        this.backoffId++;\r\n        this.backoffCount++;\r\n        this.logger.info(`Backing off ${taskName} for ${backoffMs} milliseconds with ID ${this.backoffId}`);\r\n        this.callback = (waitStart?: number, expectedWait?: number) => {\r\n            if (shouldReset(waitStart, expectedWait, this.gapDetectionSettings)) {\r\n                // Most likely computer/tab went to sleep while waiting on backoff and woke up much later\r\n                this.logger.info(`Back off for ${taskName} with ID ${this.backoffId} will be reset due to the wait (${Date.now() - (waitStart ?? 0)} ms) being longer than expected (${expectedWait} ms)`);\r\n                this.backoffCount = 0;\r\n            }\r\n            this.logger.info(`Back off for ${taskName} with ID ${this.backoffId} complete, invoking handler`);\r\n            this.timerHandle = undefined;\r\n            this.callback = undefined;\r\n            this.previousCompleteTime = Date.now();\r\n            handler();\r\n        };\r\n        const backoffWaitStart = Date.now();\r\n        this.timerHandle = setTimeout(\r\n            () => this.callback?.(backoffWaitStart, backoffMs),\r\n            backoffMs\r\n        );\r\n    }\r\n\r\n    /// Stop the backoff if active, do not call the handler and reset to the initial/shortest period again\r\n    public reset(): void {\r\n        if (this.timerHandle !== undefined) {\r\n            this.logger.debug(`Resetting back off with ID ${this.backoffId}`);\r\n            clearTimeout(this.timerHandle);\r\n            this.timerHandle = undefined;\r\n            this.callback = undefined;\r\n        }\r\n        this.backoffCount = 0;\r\n    }\r\n\r\n    /// Call the handler right now if active and reset to the initial/shortest period again\r\n    public expediteIfPending(): void {\r\n        this.backoffCount = 0;\r\n        if (this.timerHandle !== undefined) {\r\n            this.logger.debug(`Expediting back off with ID ${this.backoffId}`);\r\n            clearTimeout(this.timerHandle);\r\n            this.timerHandle = undefined;\r\n            const callback = this.callback;\r\n            this.callback = undefined;\r\n            if (callback) {\r\n                callback();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction shouldReset(waitStart: number|undefined, expectedWait: number|undefined, settings: GapDetectionSettings): boolean {\r\n    if (waitStart === undefined || expectedWait === undefined) {\r\n        return false;\r\n    }\r\n    const actualWait = Date.now() - waitStart;\r\n    return actualWait > expectedWait * settings.tolerance && actualWait > settings.minimumWaitMs;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/ExponentialBackoff.ts","import { IAudienceSubscriptionsResponse, LogProvider, TrouterState } from \"./Interfaces\";\r\nimport { ITrouterRequest, ITrouterResponse, IMessageLossIndicator } from \"./InternalInterfaces\";\r\nimport { IManagerConsumer, ReconnectReason, TrouterConnection } from \"./TrouterConnection\";\r\nimport { State } from \"./TrouterFsm\";\r\n\r\n/**\r\n * Intercepts calls from TrouterConnection to TrouterManager, to only allow\r\n * switching to the \"connected\" state after the connection\r\n * has been successfully registered, and disconnects Trouter if an existing\r\n * registration expires or gets revoked.\r\n * \r\n * One instance of this wrappere exists per each TrouterConnection (though wrapping the same TrouterManger instance),\r\n * this object thus holds state specific to a particular TrouterConnection.\r\n */\r\nexport class RegistrationEnforcer implements IManagerConsumer {\r\n    constructor(\r\n        private wrapped: IManagerConsumer,\r\n        private shouldConnectionDependOnRegistration: () => boolean,\r\n        private shouldHoldBackEvents: () => boolean\r\n    ) {\r\n    }\r\n\r\n    private isRegistered = false;\r\n\r\n    private heldBackEvents: Array<HeldBackEvent> = [];\r\n\r\n    onDownstreamRequest(connection: TrouterConnection, request: ITrouterRequest, response: ITrouterResponse): void {\r\n        this.passIfRegisteredOrNotNeeded('onDownstreamRequest', connection, request, response);\r\n    }\r\n\r\n    onConnected(connection: TrouterConnection): void {\r\n        this.passIfRegisteredOrNotNeeded('onConnected', connection);\r\n    }\r\n\r\n    onRegistered(connection: TrouterConnection): void {\r\n        this.isRegistered = true;\r\n        this.wrapped.onRegistered(connection);\r\n        this.fireHeldBackEvents();\r\n    }\r\n\r\n    onUnregistered(connection: TrouterConnection): void {\r\n        this.isRegistered = false;\r\n        this.wrapped.onUnregistered(connection);\r\n        if (connection.getState() === State.Connected && this.shouldConnectionDependOnRegistration()) {\r\n            connection.forceReconnectDueToNoRegistration();\r\n        }\r\n    }\r\n\r\n    onReconnecting(connection: TrouterConnection): void {\r\n        this.wrapped.onReconnecting(connection);\r\n    }\r\n\r\n    onReconnectIsRequired(connection: TrouterConnection, useConnectParamsFromCache: boolean, reason: ReconnectReason): void {\r\n        this.wrapped.onReconnectIsRequired(connection, useConnectParamsFromCache, reason);\r\n    }\r\n\r\n    onDisconnected(connection: TrouterConnection): void {\r\n        this.isRegistered = false;\r\n        this.dropHeldBackEvents();\r\n        this.wrapped.onDisconnected(connection);\r\n    }\r\n\r\n    onTerminalError(connection: TrouterConnection): void {\r\n        this.wrapped.onTerminalError(connection);\r\n    }\r\n\r\n    onConnectionParametersUpdated(connectParams: Record<string, unknown>): void {\r\n        this.wrapped.onConnectionParametersUpdated(connectParams);\r\n    }\r\n\r\n    onTrouterMessageLost(flowTags: IMessageLossIndicator[]): void {\r\n        this.passIfRegisteredOrNotNeeded('onTrouterMessageLost', flowTags);\r\n    }\r\n\r\n    onUserActivityStateAccepted(cv: string): void {\r\n        this.passIfRegisteredOrNotNeeded('onUserActivityStateAccepted', cv);\r\n    }\r\n\r\n    onAudiencesSetResolved(audienceSubscriptionsResponse: IAudienceSubscriptionsResponse, cv: string): void {\r\n        this.passIfRegisteredOrNotNeeded('onAudiencesSetResolved', audienceSubscriptionsResponse, cv);\r\n    }\r\n\r\n    getState(): TrouterState {\r\n        return this.wrapped.getState();\r\n    }\r\n\r\n    private holdBackEvent<T extends HeldBackEventKind>(\r\n        kind: T,\r\n        ...args: Parameters<RegistrationEnforcer[T]>\r\n    ) {\r\n        this.heldBackEvents.push({ kind, args });\r\n    }\r\n\r\n    private passIfRegisteredOrNotNeeded<T extends HeldBackEventKind>(kind: T, ...args: Parameters<RegistrationEnforcer[T]>) {\r\n        const connectionDependsOnRegistration = this.shouldConnectionDependOnRegistration();\r\n        const holdBackEvents = this.shouldHoldBackEvents();\r\n        // replay existing events if we previously needed registration but now don't, or if we should not hold back events anymore\r\n        if (!connectionDependsOnRegistration || !holdBackEvents) {\r\n            this.fireHeldBackEvents(\r\n                connectionDependsOnRegistration ?\r\n                    e => e.kind !== 'onConnected' :\r\n                    undefined\r\n            );\r\n        }\r\n\r\n        if (this.isRegistered || !connectionDependsOnRegistration || (holdBackEvents === false && kind !== 'onConnected')) {\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-explicit-any\r\n            (this.wrapped[kind] as any)(...args);\r\n        } else {\r\n            this.holdBackEvent(kind, ...args);\r\n        }\r\n    }\r\n\r\n    private fireHeldBackEvents(filter?: (e: HeldBackEvent) => boolean){\r\n        for (const event of this.heldBackEvents) {\r\n            if (filter !== undefined && !filter(event)) {\r\n                continue;\r\n            }\r\n\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-explicit-any\r\n            (this.wrapped[event.kind] as any)(...event.args);\r\n        }\r\n        \r\n        if (filter === undefined) {\r\n            this.heldBackEvents = [];\r\n        } else {\r\n            // keep everything that wasn't fired\r\n            this.heldBackEvents = this.heldBackEvents.filter(e => !filter(e));\r\n        }\r\n    }\r\n\r\n    private dropHeldBackEvents() {\r\n        this.heldBackEvents = [];\r\n    }\r\n}\r\n\r\n/**\r\n * Wrapper for debugging and tests, can be used to compare\r\n * the original and filtered events, by creating e.g.\r\n * ```\r\n * new LoggingManagerConsumer(\r\n *   new RegistrationEnforcer(\r\n *     new LoggingManagerConsumer(this, 'inner'),\r\n *     true\r\n *   ),\r\n * 'outer')\r\n * ```\r\n * where the outer one will log all the calls from TrouterConnection,\r\n * and the inner one will only log the calls that go through (with the\r\n * resulting order/delay/etc.)\r\n */\r\nexport class LoggingManagerConsumer implements IManagerConsumer {\r\n    constructor(\r\n        private wrapped: IManagerConsumer,\r\n        private prefix: string,\r\n        private logger?: LogProvider,\r\n        private onEventAction?: (name: string, jsonArgs: string) => void\r\n    ) {\r\n    }\r\n\r\n    private onEvent(name: string, jsonArgs: string) {\r\n        if (this.onEventAction !== undefined) {\r\n            this.onEventAction(name, jsonArgs);\r\n        } else {\r\n            (this.logger ?? console).log(`${this.prefix} TracingEnforcer: ${name}(${jsonArgs})`);    \r\n        }\r\n    }\r\n\r\n    onDownstreamRequest(connection: TrouterConnection, request: ITrouterRequest, response: ITrouterResponse): void {\r\n        this.onEvent('onDownstreamRequest', JSON.stringify({ request, response }));\r\n        this.wrapped.onDownstreamRequest(connection, request, response);\r\n    }\r\n\r\n    onConnected(connection: TrouterConnection): void {\r\n        this.onEvent('onConnected', connection.getState().toString());\r\n        this.wrapped.onConnected(connection);\r\n    }\r\n\r\n    onRegistered(connection: TrouterConnection): void {\r\n        this.onEvent('onRegistered', connection.getState().toString());\r\n        this.wrapped.onRegistered(connection);\r\n    }\r\n\r\n    onUnregistered(connection: TrouterConnection): void {\r\n        this.onEvent('onUnregistered', connection.getState().toString());\r\n        this.wrapped.onUnregistered(connection);\r\n    }\r\n\r\n    onReconnecting(connection: TrouterConnection): void {\r\n        this.onEvent('onReconnecting', connection.getState().toString());\r\n        this.wrapped.onReconnecting(connection);\r\n    }\r\n\r\n    onReconnectIsRequired(connection: TrouterConnection, useConnectParamsFromCache: boolean, reason: ReconnectReason): void {\r\n        this.onEvent('onReconnectIsRequired', JSON.stringify({ connection: connection.getState().toString(), useConnectParamsFromCache, reason }));\r\n        this.wrapped.onReconnectIsRequired(connection, useConnectParamsFromCache, reason);\r\n    }\r\n\r\n    onDisconnected(connection: TrouterConnection): void {\r\n        this.onEvent('onDisconnected', connection.getState().toString());\r\n        this.wrapped.onDisconnected(connection);\r\n    }\r\n\r\n    onTerminalError(connection: TrouterConnection): void {\r\n        this.onEvent('onTerminalError', JSON.stringify({ connection }));\r\n        this.wrapped.onTerminalError(connection);\r\n    }\r\n\r\n    onConnectionParametersUpdated(connectParams: Record<string, unknown>): void {\r\n        this.onEvent('onConnectionParametersUpdated', JSON.stringify({ connectParams }));\r\n        this.wrapped.onConnectionParametersUpdated(connectParams);\r\n    }\r\n\r\n    onTrouterMessageLost(flowTags: IMessageLossIndicator[]): void {\r\n        this.onEvent('onTrouterMessageLost', JSON.stringify({ flowTags }));\r\n        this.wrapped.onTrouterMessageLost(flowTags);\r\n    }\r\n\r\n    onUserActivityStateAccepted(cv: string): void {\r\n        this.onEvent('onUserActivityStateAccepted', JSON.stringify({ cv }));\r\n        this.wrapped.onUserActivityStateAccepted(cv);\r\n    }\r\n\r\n    onAudiencesSetResolved(audienceSubscriptionsResponse: IAudienceSubscriptionsResponse, cv: string): void {\r\n        this.onEvent('onAudiencesSetResolved', JSON.stringify({ audienceSubscriptionsResponse, cv }));\r\n        this.wrapped.onAudiencesSetResolved(audienceSubscriptionsResponse, cv);\r\n    }\r\n\r\n    getState(): TrouterState {\r\n        return this.wrapped.getState();\r\n    }\r\n}\r\n\r\n// Enforces compile-time type safety of function arguments\r\ntype HeldBackEventKind =\r\n    'onConnected' |\r\n    'onDownstreamRequest' |\r\n    'onTrouterMessageLost' |\r\n    'onUserActivityStateAccepted' |\r\n    'onAudiencesSetResolved';\r\n\r\ntype HeldBackEvent = {\r\n    kind: HeldBackEventKind;\r\n    args: Parameters<IManagerConsumer[HeldBackEventKind]>;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/RegistrationEnforcer.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { LogProvider, TrouterState } from './Interfaces';\r\nimport { TrouterManagerState }  from './InternalInterfaces';\r\nimport { Logger } from './Logger';\r\nimport { ReconnectReason } from './TrouterConnection';\r\n\r\nexport interface IManagerWorker {\r\n    startFirstConnection(): void;\r\n    stopFirstConnection(dontUnregister: boolean): void;\r\n\r\n    startSecondConnection(useConnectParamsFromCache: boolean): void;\r\n    stopSecondConnection(dontUnregister: boolean): void;\r\n    stopSecondConnectionDelayed(): void;\r\n\r\n    forceStopLingeringConnection(): void;\r\n\r\n    switchConnections(): void;\r\n    doesSecondConnectionExist(): boolean;\r\n\r\n    dispatchConnected(): void;\r\n    dispatchDisconnected(): void;\r\n    dispatchTerminalError(): void;\r\n    dispatchRegistrationState(isRegistered: boolean): void;\r\n\r\n    expediteBackoffOnConnections(): void\r\n}\r\n\r\n/**\r\n * State machine for manager\r\n */\r\nexport class TrouterManagerFsm {\r\n    private logger: Logger;\r\n    private state: TrouterManagerState = TrouterManagerState.Unknown;\r\n\r\n    constructor(logFunc: LogProvider, private worker: IManagerWorker) {\r\n        this.logger = new Logger('ManagerFsm', logFunc);\r\n    }\r\n\r\n    public start() {\r\n        if (this.state === TrouterManagerState.Unknown) {\r\n            this.setState(TrouterManagerState.Disconnected);\r\n            this.worker.forceStopLingeringConnection();\r\n            this.worker.startFirstConnection();\r\n        } else {\r\n            // Trouter is already running, but external code calling start()\r\n            // is often triggered by some relevant external event (e.g. computer waking up),\r\n            // so we want to retry immediately to not create unnecessary delays.\r\n            this.logger.info(`start called in state '${TrouterManagerState[this.state]}', expediting pending backoffs, if any`);\r\n            this.worker.expediteBackoffOnConnections();\r\n        }\r\n    }\r\n\r\n    public stop(dontUnregister?: boolean) {\r\n        if (this.state !== TrouterManagerState.Unknown) {\r\n            this.setState(TrouterManagerState.Unknown);\r\n            this.worker.stopFirstConnection(dontUnregister === true);\r\n            this.worker.stopSecondConnection(dontUnregister === true);\r\n        } else {\r\n            this.showIgnored('stop');\r\n        }\r\n    }\r\n\r\n    /** Returns current state */\r\n    public getState(): TrouterState {\r\n        switch (this.state) {\r\n        case TrouterManagerState.Unknown:\r\n        case TrouterManagerState.Connected:\r\n        case TrouterManagerState.Disconnected:\r\n        case TrouterManagerState.Switching:\r\n            return this.state as number as TrouterState;\r\n        case TrouterManagerState.TerminalError:\r\n            return TrouterState.Disconnected;\r\n        }\r\n    }\r\n\r\n    public getInternalState(): TrouterManagerState {\r\n        return this.state;\r\n    }\r\n\r\n    public onConnected(first: boolean) {\r\n        if (this.state === TrouterManagerState.Disconnected && first) {\r\n            if (this.worker.doesSecondConnectionExist()) {\r\n                this.setState(TrouterManagerState.Switching);\r\n            } else {\r\n                this.setState(TrouterManagerState.Connected);\r\n                this.worker.dispatchConnected();\r\n            }\r\n        } else {\r\n            this.showIgnored(`onConnected(${first})`);\r\n        }\r\n    }\r\n\r\n    public onRegistered(first: boolean) {\r\n        if (this.state === TrouterManagerState.Disconnected && !first) {\r\n            this.setState(TrouterManagerState.Connected);\r\n            this.worker.switchConnections();\r\n            this.worker.stopSecondConnection(true);\r\n            this.worker.dispatchConnected();\r\n        } else if (this.state === TrouterManagerState.Switching && !first) {\r\n            this.setState(TrouterManagerState.Connected);\r\n            this.worker.switchConnections();\r\n            this.worker.stopSecondConnectionDelayed();\r\n            this.worker.dispatchConnected();\r\n        } else if(this.state === TrouterManagerState.Disconnected && first) { \r\n            // happens when reconnect prompts connection to the same instance which dispatches disconnect as duplicate (both on old connection)\r\n            // at this point `first` is the new connection\r\n\r\n            this.setState(TrouterManagerState.Connected);\r\n            this.worker.dispatchConnected();\r\n        }\r\n        \r\n        this.worker.dispatchRegistrationState(true);\r\n    }\r\n\r\n    public onUnregistered(first: boolean) {\r\n        if (first) {\r\n            this.worker.dispatchRegistrationState(false);\r\n        }\r\n    }\r\n\r\n    public onReconnecting(first: boolean) {\r\n        if ((this.state === TrouterManagerState.Connected || this.state === TrouterManagerState.Switching) && first) {\r\n            this.setState(TrouterManagerState.Disconnected);\r\n            this.worker.dispatchDisconnected();\r\n        } else {\r\n            this.showIgnored(`onReconnecting(${first})`);\r\n        }\r\n    }\r\n\r\n    public onReconnectionRequired(first: boolean, useConnectParamsFromCache: boolean, reason: ReconnectReason) {\r\n        if (this.state === TrouterManagerState.Connected && first) {\r\n            this.setState(TrouterManagerState.Switching);\r\n            this.worker.startSecondConnection(useConnectParamsFromCache);\r\n        } else if (this.state === TrouterManagerState.Disconnected && first) {\r\n            this.worker.startSecondConnection(useConnectParamsFromCache);\r\n        } else if (this.state === TrouterManagerState.Switching && first && reason === ReconnectReason.Configuration) {\r\n            // Intentionally ignoring `trouter.reconnect` events arriving during an in-progress switch (on either connection),\r\n            // only configuration change is handled. This matches the current behavior of the C++ client.\r\n            // Even in the ignored cases, the client should still end up being connected to the right environment eventually.\r\n            this.logger.debug('onReconnectionRequired: switch requested while already in Switching state');\r\n            this.worker.stopSecondConnection(true);\r\n            this.worker.startSecondConnection(useConnectParamsFromCache);\r\n        } else {\r\n            this.showIgnored(`onReconnectionRequired(${first})`);\r\n        }\r\n    }\r\n\r\n    public onDisconnected(first: boolean) {\r\n        if (this.state == TrouterManagerState.Unknown && first) {\r\n            // This is executed after an explicit stop()\r\n            this.worker.dispatchDisconnected();\r\n        } else if (this.state == TrouterManagerState.Switching && first) {\r\n            // The current/old connection got disconnected during a connection switch\r\n            // (the disconnect would result only in onReconnecting() at other times,\r\n            // when automatic reconnects are still enabled)\r\n            this.worker.switchConnections();\r\n            this.worker.stopSecondConnection(false);\r\n            this.setState(TrouterManagerState.Disconnected);\r\n            this.worker.dispatchDisconnected();\r\n        } else {\r\n            this.showIgnored(`onDisconnected(${first})`);\r\n        }\r\n    }\r\n\r\n    public onTerminalError() {\r\n        this.setState(TrouterManagerState.TerminalError);\r\n        this.worker.dispatchTerminalError();\r\n    }\r\n\r\n    private showIgnored(event: string) {\r\n        this.logger.info(`Ignoring event '${event}' in state '${TrouterManagerState[this.state]}'`);\r\n    }\r\n\r\n    private setState(state: TrouterManagerState) {\r\n        this.logger.info(`Switching from state '${TrouterManagerState[this.state]}' to state '${TrouterManagerState[state]}'`);\r\n        if (this.state === state) {\r\n            this.logger.error(`Attempt to switch to the current state '${TrouterManagerState[state]}'`);\r\n\r\n            return;\r\n        }\r\n        this.state = state;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/TrouterManagerFsm.ts","/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n\r\nimport { CLIENT_VERSION } from './Constants';\r\nimport {\r\n    AuthTokenProvider,\r\n    Client, ConnectionInfo, IConnectionInfo,\r\n    ITrouterServiceBase, ITrouterServiceConfig, Listener, LogProvider, MessageHandler,\r\n    Request, Response, SkypeTokenProvider, StateChangedListener,\r\n    TokenRequest,\r\n    TrouterConnectionListener, TrouterRequestBody, TrouterState, TrouterTelemetrySettings,\r\n    UserActivityState,\r\n    IAudienceSubscription, IAudienceSubscriptionModel, IAudienceSubscriptionsResponse\r\n} from './Interfaces';\r\nimport { ITrouterOptions, ServerState } from './InternalInterfaces';\r\nimport { Logger } from './Logger';\r\nimport { MessageHandlerRegistry } from './MessageHandler';\r\nimport { addCacheAsBackupTo } from './SkypeTokenProviderWithCache';\r\nimport { TrouterManager } from './TrouterManager';\r\nimport { TrouterUrlPromise } from './TrouterUrlPromise';\r\n\r\nexport { MessageHandler, TrouterState, UserActivityState, IAudienceSubscription, IAudienceSubscriptionModel };\r\n\r\ninterface IEcsConfig {\r\n    TrouterConnectionUrl?: string;\r\n    TelemetryEnabled?: boolean;\r\n    ClientTelemetryEventEnabled: {\r\n        trouter_js_client_connected?: boolean;\r\n        trouter_js_client_disconnected?: boolean;\r\n        trouter_js_client_error?: boolean;\r\n        trouter_js_client_progress?: boolean;\r\n        trouter_js_client_response?: boolean;\r\n        logHealthCheckError?: boolean;\r\n        logSendPingError?: boolean;\r\n        numberOfStepsToMaintain?: number;\r\n        sendProgressTimeoutSecs?: number;\r\n    };\r\n}\r\n\r\nfunction populateTelemetryOptions(startingCfg: TrouterTelemetrySettings, ecsCfg?: IEcsConfig): TrouterTelemetrySettings {\r\n    if (!ecsCfg) {\r\n        return startingCfg;\r\n    }\r\n\r\n    let res = {\r\n        ...startingCfg,\r\n        ...{\r\n            enabled: ecsCfg.TelemetryEnabled\r\n        }\r\n    };\r\n\r\n    if (ecsCfg.ClientTelemetryEventEnabled !== undefined) {\r\n        res = {\r\n            ...res,\r\n            ...ecsCfg.ClientTelemetryEventEnabled\r\n        };\r\n    }\r\n\r\n    return <TrouterTelemetrySettings>res;\r\n}\r\n\r\nfunction populateTrouterOptions(cfg: ITrouterServiceConfig, logger: Logger, ecsCfg?: IEcsConfig): ITrouterOptions {\r\n    const rewriteUrlForProxyCallback = (url: string) => {\r\n        if (cfg.proxyUrlRewrite) {\r\n            logger.info('Using rewritten URL for proxy');\r\n\r\n            return cfg.proxyUrlRewrite(url);\r\n        } else {\r\n            return url;\r\n        }\r\n    };\r\n\r\n    return {\r\n        clientInfo: {\r\n            ua: cfg.trouterSettings.productName,\r\n            v: cfg.trouterSettings.version\r\n        },\r\n        ioOptions: {\r\n            // uncomment for manual testing\r\n            // transports: ['xhr-polling'],\r\n            // 'connect timeout': XXX, 10000 by default in socket.io code\r\n            ackTimeoutMs: 5000,\r\n            rewriteUrlForProxy: rewriteUrlForProxyCallback\r\n        },\r\n        clientCorrelationID: cfg.trouterSettings.sessionId,\r\n        environment: cfg.trouterSettings.environment,\r\n        telemetrySettings: populateTelemetryOptions(cfg.telemetryConfig.settings, ecsCfg),\r\n        eventLogger: cfg.telemetryConfig.eventLogger,\r\n        endpointId: cfg.trouterSettings.registrationId,\r\n        // keeping existing behavior of || - using default value when there's empty string\r\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\r\n        trouterUrl: (ecsCfg?.TrouterConnectionUrl) || cfg.trouterSettings.trouterServiceUrl,\r\n        registration: cfg.trouterSettings.registrarServiceUrl\r\n            ? {\r\n                registrarUrl: cfg.trouterSettings.registrarServiceUrl,\r\n                registrationId: cfg.trouterSettings.registrationId ?? '',\r\n                pnhAppId: cfg.trouterSettings.pnhAppId ?? '',\r\n                platform: cfg.trouterSettings.platform ?? '',\r\n                pnhTemplateKey: cfg.trouterSettings.pnhTemplate ?? '',\r\n                platformUIVersion: cfg.trouterSettings.platformUIVersion ?? '',\r\n                // keeping existing behavior of || - using default value when there's empty string\r\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\r\n                productContext: cfg.trouterSettings.pnhProductContext || undefined,\r\n                context: cfg.trouterSettings.pnhContext ?? '',\r\n                registrarTtlSec: (cfg.trouterSettings.maxRegistrationTimeInMs ?? 0) / 1000\r\n            }\r\n            : undefined,\r\n        connectionDependsOnRegistration:\r\n            cfg.trouterSettings.registrarServiceUrl === undefined ?\r\n                (() => false) :\r\n                (cfg.trouterSettings.connectionDependsOnRegistration ?? (() => false)),\r\n        delayEventsUntilRegistered: cfg.trouterSettings.delayEventsUntilRegistered ?? (() => false),\r\n\r\n        timeoutOptions: {\r\n            // keeping existing behavior of || - using default value when there's 0\r\n            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\r\n            connectionTimeoutMs: cfg.trouterSettings.trouterConnectTimeoutInMs || 30000,\r\n            fetchTimeoutMs: 10000,\r\n            pingTimeoutMs: 40000,\r\n            pongTimeoutMs: 5000,\r\n            /** Followup WI to remove hardcoded value: https://domoreexp.visualstudio.com/MSTeams/_workitems/edit/2307271 */\r\n            maxBackoffMs: cfg.trouterSettings.productName === 'TeamsCDL' ? 300000 : 30000,\r\n            requestTimeoutMs: 5000,\r\n            userActivityResponseTimeoutMs: 10000,\r\n            ...cfg.trouterSettings.timeoutOptions\r\n        },\r\n        incallTimeoutOptions: {\r\n            connectionTimeoutMs: 10000,\r\n            fetchTimeoutMs: 5000,\r\n            pingTimeoutMs: 5000,\r\n            pongTimeoutMs: 2000,\r\n            maxBackoffMs: cfg.trouterSettings.productName === 'TeamsCDL' ? 300000 : 10000,\r\n            requestTimeoutMs: 5000,\r\n            userActivityResponseTimeoutMs: 10000,\r\n            ...cfg.trouterSettings.incallTimeoutOptions\r\n        },\r\n        incallModeTimeoutMs: cfg.trouterSettings.incallModeTimeoutMs ?? 0,\r\n        lingeringConnectionDelayMs: 60000,\r\n        // keeping existing behavior of || - using default value when there's 0\r\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\r\n        userActivitySecondResendDelayMs: cfg.trouterSettings.userActivitySecondResendDelayMs || 10000,\r\n        duplicateDisconnectThresholdMs: 10000,\r\n        connectionCache: cfg.connectionCache,\r\n        // eslint-disable-next-line @typescript-eslint/unbound-method\r\n        registrationStateCallback: cfg.registrationStateCallbackForAcsDoNotUse,\r\n        rewriteUrlForProxy: rewriteUrlForProxyCallback,\r\n        retryLimitOnTokenFetch: cfg.trouterSettings.retryLimitOnTokenFetch,\r\n        extraConnectionHeaders: cfg.trouterSettings.extraConnectionHeaders,\r\n        expediteBackoffOnStartMinimumDelayMs: 10000,\r\n\r\n        // JSON.stringify() override for dumping options to log as JSON in TrouterManager\r\n        toJSON: function (this: ITrouterOptions) {\r\n            return {\r\n                ...this,\r\n\r\n                // If cache is set to some object of the host app, do not try to serialize it.\r\n                // It could contain circular references and JSON.stringify() would fully fail.\r\n                connectionCache: this.connectionCache ? {} : this.connectionCache\r\n            };\r\n        }\r\n    };\r\n}\r\n\r\nexport type TelemetryEvent = {\r\n    type: string;\r\n    registrationId: string;\r\n    connectionId?: string;\r\n    connectedClientId?: string;\r\n};\r\n\r\ninterface IWrappedStateChangedListener extends TrouterConnectionListener {\r\n    (state: TrouterState, info?: IConnectionInfo): void;\r\n    wrappedCallback: StateChangedListener;\r\n}\r\n\r\n/**\r\n * TrouterService implementation class\r\n */\r\nexport class TrouterService implements ITrouterServiceBase, Client, Listener {\r\n    private logger: Logger;\r\n    private trouterServer?: TrouterManager;\r\n    private listeners: { [path: string]: Listener };\r\n    private connectionInfo: ConnectionInfo | null;\r\n    private trouterCfg?: ITrouterServiceConfig;\r\n    private ecsCfg?: IEcsConfig;\r\n    private pendingActivityState?: [UserActivityState, string | undefined];\r\n\r\n\r\n    // Legacy fields\r\n    private trouterUrlPromise: TrouterUrlPromise;\r\n    private stateChangedListeners: (TrouterConnectionListener | IWrappedStateChangedListener)[] = [];\r\n    private messageHandlers: MessageHandlerRegistry;\r\n\r\n    public constructor(private logProvider: LogProvider) {\r\n        this.logger = new Logger('Trouter', logProvider);\r\n        this.trouterUrlPromise = new TrouterUrlPromise(logProvider);\r\n        this.messageHandlers = new MessageHandlerRegistry(logProvider);\r\n        this.listeners = {};\r\n        this.connectionInfo = null;\r\n        this.logger.info(`Created TrouterService version ${CLIENT_VERSION}`);\r\n    }\r\n\r\n    public start(cfg: ITrouterServiceConfig): void {\r\n        this.logger.info('Start');\r\n        if (!cfg.skypeTokenProvider && !cfg.authTokenProvider) {\r\n            throw new Error('no token provider has been configured, either skypeTokenProvider or authTokenProvider must be populated');\r\n        }\r\n\r\n        if (cfg.skypeTokenProvider && !cfg.trouterSettings.disableInternalSkypeTokenCache) {\r\n            cfg.skypeTokenProvider = addCacheAsBackupTo(cfg.skypeTokenProvider);\r\n        }\r\n\r\n        this.trouterCfg = cfg;\r\n        const options = populateTrouterOptions(cfg, this.logger, this.ecsCfg);\r\n\r\n        if ((<ITrouterServiceConfig & UndocumentedSettings>cfg).internalEnableV4cProtocol === false) {\r\n            options.forceV4aProtocol = true;\r\n        }\r\n\r\n        const authTokenProvider = authTokenProviderProtector(this.logger, cfg.authTokenProvider ?? skypeTokenAdapter(cfg.skypeTokenProvider));\r\n\r\n        if (this.trouterServer === undefined) {\r\n            this.trouterServer = new TrouterManager(\r\n                this.logProvider,\r\n                options,\r\n                authTokenProvider,\r\n                cfg.authTokenProvider === undefined,\r\n                this);\r\n        }\r\n\r\n        if (this.pendingActivityState !== undefined) {\r\n            this.trouterServer.setUserActivityState(this.pendingActivityState[0], this.pendingActivityState[1]);\r\n            this.pendingActivityState = undefined;\r\n        }\r\n\r\n        this.trouterServer.start();\r\n    }\r\n\r\n    public stop(dontUnregister?: boolean): void {\r\n        this.logger.info('close connection');\r\n        this.trouterUrlPromise.rejectUrl(new Error('TrouterService is stopped'));\r\n\r\n        if (this.trouterServer !== undefined) {\r\n            this.trouterServer.stop(dontUnregister);\r\n        }\r\n    }\r\n\r\n    public async setEcsConfig(fullEcsData: { [section: string]: unknown }): Promise<void> {\r\n        return new Promise<void>((resolve) => {\r\n            const ecsSection = 'TrouterJScriptClient';\r\n            this.ecsCfg = <IEcsConfig>(fullEcsData[ecsSection]);\r\n            this.logger.info(`Setting ECS configuration to ${JSON.stringify(this.ecsCfg)}`);\r\n            if (this.trouterServer !== undefined && this.trouterCfg !== undefined) {\r\n                const options = populateTrouterOptions(this.trouterCfg, this.logger, this.ecsCfg);\r\n                this.trouterServer.configure(options);\r\n            }\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Notifies trouter that network is restored - trouter will try to restore connection immediately\r\n     */\r\n    public checkConnection(disconnectDetected?: boolean): void {\r\n        if (this.trouterServer !== undefined) {\r\n            this.trouterServer.checkConnection(disconnectDetected ?? false);\r\n        }\r\n    }\r\n\r\n    public async resendRegistration(): Promise<void> {\r\n        if (!this.trouterServer) {\r\n            throw new Error('resendRegistration called too early');\r\n        }\r\n\r\n        return this.trouterServer.resendRegistration();\r\n    }\r\n\r\n\r\n    // Listeners\r\n\r\n    public registerListener(listener: Listener, path: string): boolean {\r\n        if (path === '' || !path.startsWith('/') || path.includes('?') || path.includes('#')) {\r\n            this.logger.error(`Listener path '${path}' is not valid`);\r\n\r\n            return false;\r\n        }\r\n        if (this.listeners[path]) {\r\n            this.logger.error(`Another listener is already registered for path '${path}'`);\r\n\r\n            return false;\r\n        }\r\n        this.listeners[path] = listener;\r\n        this.logger.debug(`Listener for path '${path}' registered`);\r\n        if (this.connectionInfo) {\r\n            listener.onTrouterConnected(this.connectionInfo.baseEndpointUrl + path, this.connectionInfo);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public unregisterListener(listener: Listener): boolean {\r\n        const paths: string[] = [];\r\n        for (const path of Object.keys(this.listeners)) {\r\n            if (this.listeners[path] === listener) {\r\n                paths.push(path);\r\n            }\r\n        }\r\n        if (paths.length === 0) {\r\n            return false;\r\n        }\r\n        for (const path of paths) {\r\n            delete this.listeners[path];\r\n        }\r\n        this.logger.debug(`Listener for path(s) '${paths.join('\\', \\'')}' unregistered`);\r\n\r\n        return true;\r\n    }\r\n\r\n    public onTrouterConnected(endpointUrl: string, connectionInfo: ConnectionInfo): void {\r\n        this.logger.debug('Trouter is now connected');\r\n        for (const path of Object.keys(this.listeners)) {\r\n            try {\r\n                this.listeners[path].onTrouterConnected(connectionInfo.baseEndpointUrl + path, connectionInfo);\r\n            } catch (e) {\r\n                this.logger.error(`Listener '${path}' threw an exception from onTrouterConnected(): ${e}`);\r\n            }\r\n        }\r\n        this.connectionInfo = connectionInfo;\r\n\r\n        this.trouterUrlPromise.resolveUrl(endpointUrl);\r\n        this.notifyStateChanged(TrouterState.Connected, {\r\n            url: endpointUrl,\r\n            getRemainingTtlInSec: () => connectionInfo.connectionTtlSec\r\n        });\r\n    }\r\n\r\n    public onTrouterDisconnected(): void {\r\n        this.logger.debug('Trouter is now disconnected');\r\n        this.connectionInfo = null;\r\n        for (const path of Object.keys(this.listeners)) {\r\n            const listener = this.listeners[path];\r\n            if (listener.onTrouterDisconnected) {\r\n                try {\r\n                    listener.onTrouterDisconnected();\r\n                } catch (e) {\r\n                    this.logger.error(`Listener '${path}' threw an exception from onTrouterDisconnected(): ${e}`);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.notifyStateChanged(TrouterState.Disconnected);\r\n    }\r\n\r\n    public onTrouterRequest(request: Request, response: Response): void {\r\n        let bestPath = '';\r\n        for (const path of Object.keys(this.listeners)) {\r\n            if (request.path.startsWith(path) && path.length > bestPath.length) {\r\n                bestPath = path;\r\n            }\r\n        }\r\n        if (bestPath !== '') {\r\n            try {\r\n                this.listeners[bestPath].onTrouterRequest(request, response);\r\n            } catch (e) {\r\n                this.logger.error(`Listener '${bestPath}' threw an exception from onTrouterRequest(): ${e}`);\r\n                response.status = 500;\r\n                response.headers = { 'Trouter-Responder': 'ClientLib' };\r\n                response.send();\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.tryMessageHandlers(request, response)) {\r\n            return;\r\n        }\r\n\r\n        response.status = 404;\r\n        response.headers = { 'Trouter-Responder': 'ClientLib' };\r\n        response.send();\r\n    }\r\n\r\n    public onTrouterMessageLoss(flowTags: string[]): boolean {\r\n        this.logger.info(`onTrouterMessageLoss called with tags [${flowTags}]`);\r\n\r\n        let messageLossProcessed = true;\r\n        for (const path of Object.keys(this.listeners)) {\r\n            const listener = this.listeners[path];\r\n            if (listener.onTrouterMessageLoss) {\r\n                try {\r\n                    messageLossProcessed = listener.onTrouterMessageLoss(flowTags) && messageLossProcessed;\r\n\r\n                    if (messageLossProcessed === undefined) {\r\n                        this.logger.error(`Listener '${path}' did not return a boolean value from onTrouterMessageLoss()`);\r\n                        messageLossProcessed = false;\r\n                    }\r\n                } catch (e) {\r\n                    this.logger.error(`Listener '${path}' threw an exception from onTrouterMessageLoss(): ${e}`);\r\n                    messageLossProcessed = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return messageLossProcessed;\r\n    }\r\n\r\n    public onTrouterUserActivityStateAccepted(cv: string): void {\r\n        this.logger.debug(`onTrouterUserActivityStateAccepted cv: ${cv}`);\r\n        for (const path of Object.keys(this.listeners)) {\r\n            const listener = this.listeners[path];\r\n            if (listener.onTrouterUserActivityStateAccepted) {\r\n                try {\r\n                    listener.onTrouterUserActivityStateAccepted(cv);\r\n                } catch (e) {\r\n                    this.logger.error(`Listener '${path}' threw an exception from onTrouterUserActivityStateAccepted(): ${e}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    onAudiencesSetResolved(audienceSubscriptionsResponse: IAudienceSubscriptionsResponse, cv: string): void {\r\n        this.logger.debug(`onAudiencesSetResolved cv: ${cv}`);\r\n        for (const path of Object.keys(this.listeners)) {\r\n            const listener = this.listeners[path];\r\n            if (listener.onAudiencesSetResolved) {\r\n                try {\r\n                    listener.onAudiencesSetResolved(audienceSubscriptionsResponse, cv);\r\n                } catch (e) {\r\n                    this.logger.error(`Listener '${path}' threw an exception from onAudienceSubscribed(): ${e}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public setUserActivityState(state: UserActivityState, correlationVector?: string): void {\r\n        if (state !== UserActivityState.Active && state !== UserActivityState.Inactive) {\r\n            throw new Error(`setUserActivityState called with unsupported value ${state}`);\r\n        }\r\n        this.logger.info(`setUserActivityState called with value ${UserActivityState[state]}`);\r\n\r\n        if (this.trouterServer && this.state() !== TrouterState.Unknown) {\r\n            this.trouterServer.setUserActivityState(state, correlationVector);\r\n        } else {\r\n            this.pendingActivityState = [state, correlationVector];\r\n            this.logger.warn('setUserActivityState called before start() or after stop()');\r\n        }\r\n    }\r\n\r\n    public setAudienceSubscriptions(audienceSubscriptionModel: IAudienceSubscriptionModel, correlationVector?: string): Promise<IAudienceSubscriptionsResponse> {\r\n        if (audienceSubscriptionModel.audienceSubscriptions.length > 1) {\r\n            throw new Error(\"Only singular audience subscription is supported\");\r\n        }\r\n\r\n        if (this.trouterServer && this.state() !== TrouterState.Unknown) {\r\n            return this.trouterServer.setAudienceSubscriptionsAsync(audienceSubscriptionModel, 15000, correlationVector);\r\n        }\r\n\r\n        throw new Error('audience subscribe called before start() or after stop()');\r\n    }\r\n\r\n    // Legacy API\r\n\r\n    public state(): TrouterState {\r\n        if (this.trouterServer !== undefined) {\r\n            return this.trouterServer.getState();\r\n        }\r\n\r\n        return TrouterState.Unknown;\r\n    }\r\n\r\n    public isInTerminalState(): boolean {\r\n        if (this.trouterServer !== undefined) {\r\n            return this.trouterServer.isInTerminalState();\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public reportStateInfo(): string {\r\n        if (this.trouterServer === undefined) {\r\n            return \"\";\r\n        }\r\n        return this.trouterServer.reportStateInfo();\r\n    }\r\n\r\n    public getServerState(): ServerState | undefined {\r\n        if (this.trouterServer !== undefined) {\r\n            return this.trouterServer.getServerState();\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    public getTrouterUrlAsync(): Promise<string> {\r\n        if (this.trouterServer !== undefined) {\r\n            return this.trouterUrlPromise.getPromise();\r\n        } else {\r\n            return Promise.reject(new Error('TrouterService has not been started'));\r\n        }\r\n    }\r\n\r\n    public onStateChanged(callback: StateChangedListener | undefined): void {\r\n        this.logger.info('onStateChanged called');\r\n        if (callback === undefined) {\r\n            this.stateChangedListeners = this.stateChangedListeners.filter(\r\n                (listener) => ((<IWrappedStateChangedListener>listener).wrappedCallback === undefined));\r\n        } else {\r\n            this.offStateChanged(callback);\r\n            const wrapper = (state: TrouterState, info?: IConnectionInfo) => {\r\n                callback(state, info ? info.url : '');\r\n            };\r\n            (<IWrappedStateChangedListener>wrapper).wrappedCallback = callback;\r\n            this.stateChangedListeners.push(wrapper);\r\n        }\r\n    }\r\n\r\n    public offStateChanged(callback: StateChangedListener): boolean {\r\n        this.logger.info('offStateChanged called');\r\n        const sizeBeforeRemoval = this.stateChangedListeners.length;\r\n        this.stateChangedListeners = this.stateChangedListeners.filter(\r\n            (listener) => ((<IWrappedStateChangedListener>listener).wrappedCallback !== callback));\r\n\r\n        return (sizeBeforeRemoval > this.stateChangedListeners.length);\r\n    }\r\n\r\n    public addCallback(callback: TrouterConnectionListener): void {\r\n        this.logger.info('addListener called');\r\n        const index = this.stateChangedListeners.indexOf(callback, 0);\r\n        if (index === -1 && callback !== undefined) {\r\n            this.stateChangedListeners.push(callback);\r\n        }\r\n    }\r\n\r\n    public removeCallback(callback: TrouterConnectionListener): boolean {\r\n        this.logger.info('removeListener called');\r\n        const index = this.stateChangedListeners.indexOf(callback, 0);\r\n        if (index > -1) {\r\n            this.stateChangedListeners.splice(index, 1);\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public registerMessageHandler(handler: MessageHandler) {\r\n        this.logger.info('registerMessageHandler is called');\r\n        this.messageHandlers.register(handler);\r\n    }\r\n\r\n    public clearMessageHandlers(): void {\r\n        this.logger.info('clearMessageHandlers is called');\r\n        this.messageHandlers.clear();\r\n    }\r\n\r\n    private notifyStateChanged(state: TrouterState, info?: IConnectionInfo): void {\r\n        this.logger.info(`notifyStateChanged called, will forward to ${this.stateChangedListeners.length} listeners`);\r\n        this.stateChangedListeners.forEach(callback => {\r\n            try {\r\n                callback(state, info);\r\n            } catch (error) {\r\n                this.logger.error(`Error in callback ${error}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    private tryMessageHandlers(request: Request, response: Response): boolean {\r\n        if (!this.messageHandlers.active()) {\r\n\r\n            return false;\r\n        }\r\n\r\n        let body: TrouterRequestBody | undefined;\r\n        let eventId: number | null = null;\r\n\r\n        try {\r\n            body = <TrouterRequestBody>JSON.parse(request.body);\r\n            eventId = (body && (body.evt || body.eventId)) || null;\r\n            // eslint-disable-next-line no-empty\r\n        } catch (e) { }\r\n\r\n        const message = {\r\n            eventId: eventId,\r\n            url: (this.connectionInfo ? this.connectionInfo.baseEndpointUrl : '') + request.path,\r\n            body: body,\r\n            rawBody: request.body,\r\n            headers: request.headers\r\n        };\r\n\r\n        const result = this.messageHandlers.handleMessage(message);\r\n        if (!result.isHandled) {\r\n\r\n            return false;\r\n        }\r\n\r\n        response.status = result.resultCode;\r\n        if (result.responseHeaders) {\r\n            response.headers = result.responseHeaders;\r\n        }\r\n        if (result.responseBody) {\r\n            response.body = result.responseBody;\r\n        }\r\n        response.send();\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nexport function createTrouterService(logger: LogProvider): ITrouterServiceBase {\r\n    return new TrouterService(logger);\r\n}\r\n\r\nexport function getTrouterServiceVersion(): string {\r\n    return CLIENT_VERSION;\r\n}\r\n\r\nexport function replaceTrouterUrlBase(existingUrl: string, newBase: string): string {\r\n    const schemaSepPos = existingUrl.indexOf('://');\r\n    if (schemaSepPos >= 0) {\r\n        const pathSepPos = existingUrl.indexOf('/', schemaSepPos + 3);\r\n        if (pathSepPos >= 0) {\r\n            return newBase + existingUrl.substr(pathSepPos);\r\n        }\r\n    }\r\n\r\n    return '';\r\n}\r\n\r\nfunction skypeTokenAdapter(provider: SkypeTokenProvider): AuthTokenProvider {\r\n    return async (req: TokenRequest) => ({ token: await provider(req.needFresh), tokenType: 'skype' });\r\n}\r\n\r\nfunction authTokenProviderProtector(logger: Logger, provider: AuthTokenProvider): AuthTokenProvider {\r\n    let previousToken: string | undefined;\r\n\r\n    return async (req: TokenRequest) => {\r\n        const requestTime = new Date();\r\n        const timerId = setInterval(() => {\r\n            const delay = Math.round((Date.now() - requestTime.getTime()) / 60000);\r\n            logger.warn(`Note: Trouter auth token request promise from ${requestTime.toISOString()} has not been resolved for ${delay} minutes. The client is blocked from operating properly`);\r\n        }, 5 * 60000);\r\n\r\n        try {\r\n            const rsp = await provider(req);\r\n\r\n            if (req.needFresh && rsp.token === previousToken) {\r\n                logger.error('API violation: Trouter auth token provider got a request with needRefresh=true, but returned the same token as last time anyway. Please fix the host app');\r\n            }\r\n\r\n            previousToken = rsp.token;\r\n            return rsp;\r\n        }\r\n        finally {\r\n            clearInterval(timerId);\r\n        }\r\n    };\r\n}\r\n\r\ntype UndocumentedSettings = {\r\n    internalEnableV4cProtocol?: boolean\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib_temp/TsTrouter.ts","module.exports = __WEBPACK_EXTERNAL_MODULE_21__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@skype/tsregistrar\"\n// module id = 21\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PACKAGE_VERSION = exports.CONFIG_API_VERSION = exports.EudbCountries = exports.CloudPrefix = exports.CloudType = exports.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES = void 0;\nexports.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES = 3;\n// Gov cloud types\nvar CloudType;\n(function (CloudType) {\n    CloudType[\"Public\"] = \"Public\";\n    CloudType[\"GccHigh\"] = \"GCC High\";\n    CloudType[\"Dod\"] = \"DoD\";\n})(CloudType || (exports.CloudType = CloudType = {}));\nvar CloudPrefix;\n(function (CloudPrefix) {\n    CloudPrefix[\"OrgId\"] = \"orgid\";\n    CloudPrefix[\"Acs\"] = \"acs\";\n    CloudPrefix[\"Spool\"] = \"spool\";\n    CloudPrefix[\"GccHigh\"] = \"gcch\";\n    CloudPrefix[\"GccHighAcs\"] = \"gcch-acs\";\n    CloudPrefix[\"Dod\"] = \"dod\";\n    CloudPrefix[\"DodAcs\"] = \"dod-acs\";\n})(CloudPrefix || (exports.CloudPrefix = CloudPrefix = {}));\nexports.EudbCountries = [\"europe\", \"france\", \"germany\", \"norway\", \"switzerland\", \"sweden\"];\nexports.CONFIG_API_VERSION = \"2024-09-01\";\nexports.PACKAGE_VERSION = \"1.0.0-beta.29\";\n","\"use strict\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isEudbLocation = exports.parseTokenCredential = exports.base64decode = exports.toTelemetrySender = exports.toLogProvider = exports.toMessageHandler = void 0;\nexports.generateUuid = generateUuid;\nconst uuid_1 = require(\"uuid\");\nconst core_util_1 = require(\"@azure/core-util\");\nconst constants_1 = require(\"./constants\");\nconst eventIds = new Map([\n    [\"chatMessageReceived\", 200],\n    [\"typingIndicatorReceived\", 245],\n    [\"readReceiptReceived\", 246],\n    [\"chatMessageEdited\", 247],\n    [\"chatMessageDeleted\", 248],\n    [\"chatThreadCreated\", 257],\n    [\"chatThreadPropertiesUpdated\", 258],\n    [\"chatThreadDeleted\", 259],\n    [\"participantsAdded\", 260],\n    [\"participantsRemoved\", 261],\n]);\nconst publicTeamsUserPrefix = \"8:orgid:\";\nconst dodTeamsUserPrefix = \"8:dod:\";\nconst gcchTeamsUserPrefix = \"8:gcch:\";\nconst teamsVisitorUserPrefix = \"8:teamsvisitor:\";\nconst phoneNumberPrefix = \"4:\";\nconst acsUserPrefix = \"8:acs:\";\nconst acsGcchUserPrefix = \"8:gcch-acs:\";\nconst acsDodUserPrefix = \"8:dod-acs:\";\nconst spoolUserPrefix = \"8:spool:\";\nconst toMessageHandler = (event, listener, resourceEndpoint, gatewayApiVersion) => {\n    const eventId = eventIds.get(event);\n    return {\n        handleMessage(message) {\n            let genericPayload = null;\n            if (message === null || message === void 0 ? void 0 : message.rawBody) {\n                genericPayload = JSON.parse(message.rawBody);\n            }\n            if (genericPayload === null || genericPayload.eventId !== eventId) {\n                return undefined;\n            }\n            const eventPayload = toEventPayload(event, genericPayload, resourceEndpoint, gatewayApiVersion);\n            if (eventPayload === null) {\n                return undefined;\n            }\n            listener(eventPayload);\n            return { isHandled: true, resultCode: 200 };\n        },\n    };\n};\nexports.toMessageHandler = toMessageHandler;\nconst toEventPayload = (event, genericPayload, resourceEndpoint, gatewayApiVersion) => {\n    if (event === \"chatMessageReceived\") {\n        const payload = genericPayload;\n        const eventPayload = {\n            threadId: payload.groupId,\n            sender: constructIdentifierKindFromMri(payload.senderId),\n            senderDisplayName: payload.senderDisplayName,\n            recipient: constructIdentifierKindFromMri(payload.recipientMri),\n            id: payload.messageId,\n            createdOn: new Date(payload.originalArrivalTime),\n            version: payload.version,\n            type: payload.messageType,\n            message: payload.messageBody,\n            metadata: parseJsonString(payload.acsChatMessageMetadata) || {},\n            attachments: transformEndpoint(parseJsonString(payload.attachments) || [], resourceEndpoint, gatewayApiVersion),\n        };\n        return eventPayload;\n    }\n    if (event === \"chatMessageEdited\") {\n        const payload = genericPayload;\n        const eventPayload = {\n            threadId: payload.groupId,\n            sender: constructIdentifierKindFromMri(payload.senderId),\n            senderDisplayName: payload.senderDisplayName,\n            recipient: constructIdentifierKindFromMri(payload.recipientMri),\n            id: payload.messageId,\n            createdOn: new Date(payload.originalArrivalTime),\n            version: payload.version,\n            message: payload.messageBody,\n            editedOn: new Date(payload.edittime),\n            type: payload.messageType,\n            metadata: parseJsonString(payload.acsChatMessageMetadata) || {},\n            attachments: transformEndpoint(parseJsonString(payload.attachments) || [], resourceEndpoint, gatewayApiVersion),\n        };\n        return eventPayload;\n    }\n    if (event === \"chatMessageDeleted\") {\n        const payload = genericPayload;\n        const eventPayload = {\n            threadId: payload.groupId,\n            sender: constructIdentifierKindFromMri(payload.senderId),\n            senderDisplayName: payload.senderDisplayName,\n            recipient: constructIdentifierKindFromMri(payload.recipientMri),\n            id: payload.messageId,\n            createdOn: new Date(payload.originalArrivalTime),\n            version: payload.version,\n            deletedOn: new Date(payload.deletetime),\n            type: payload.messageType,\n        };\n        return eventPayload;\n    }\n    if (event === \"typingIndicatorReceived\") {\n        const payload = genericPayload;\n        const eventPayload = {\n            threadId: payload.groupId,\n            sender: constructIdentifierKindFromMri(payload.senderId),\n            senderDisplayName: payload.senderDisplayName,\n            recipient: constructIdentifierKindFromMri(payload.recipientMri),\n            version: payload.version,\n            receivedOn: new Date(payload.originalArrivalTime),\n        };\n        return eventPayload;\n    }\n    if (event === \"readReceiptReceived\") {\n        const payload = genericPayload;\n        const readReceiptMessageBody = JSON.parse(payload.messageBody);\n        const consumptionHorizon = readReceiptMessageBody.consumptionhorizon.split(\";\");\n        const eventPayload = {\n            threadId: payload.groupId,\n            sender: constructIdentifierKindFromMri(payload.senderId),\n            senderDisplayName: \"\",\n            recipient: constructIdentifierKindFromMri(payload.recipientMri),\n            chatMessageId: payload.messageId,\n            readOn: new Date(+consumptionHorizon[1]),\n        };\n        return eventPayload;\n    }\n    if (event === \"chatThreadCreated\") {\n        const payload = genericPayload;\n        const createdByPayload = JSON.parse(unescape(payload.createdBy));\n        const membersPayload = JSON.parse(unescape(payload.members));\n        const propertiesPayload = JSON.parse(unescape(payload.properties));\n        const createdBy = {\n            id: constructIdentifierKindFromMri(createdByPayload.participantId),\n            displayName: createdByPayload.displayName,\n        };\n        const chatParticipants = membersPayload.map((m) => {\n            return {\n                id: constructIdentifierKindFromMri(m.participantId),\n                displayName: m.displayName,\n            };\n        });\n        const eventPayload = {\n            threadId: payload.threadId,\n            createdOn: new Date(payload.createTime),\n            createdBy: createdBy,\n            version: payload.version,\n            participants: chatParticipants,\n            properties: propertiesPayload,\n        };\n        return eventPayload;\n    }\n    if (event === \"chatThreadPropertiesUpdated\") {\n        const payload = genericPayload;\n        const updatedByPayload = JSON.parse(unescape(payload.editedBy));\n        const propertiesPayload = JSON.parse(unescape(payload.properties));\n        const updatedBy = {\n            id: constructIdentifierKindFromMri(updatedByPayload.participantId),\n            displayName: updatedByPayload.displayName,\n        };\n        const eventPayload = {\n            threadId: payload.threadId,\n            updatedOn: new Date(payload.editTime),\n            updatedBy: updatedBy,\n            version: payload.version,\n            properties: propertiesPayload,\n        };\n        return eventPayload;\n    }\n    if (event === \"chatThreadDeleted\") {\n        const payload = genericPayload;\n        const deletedByPayload = JSON.parse(unescape(payload.deletedBy));\n        const deletedBy = {\n            id: constructIdentifierKindFromMri(deletedByPayload.participantId),\n            displayName: deletedByPayload.displayName,\n        };\n        const eventPayload = {\n            threadId: payload.threadId,\n            deletedOn: new Date(payload.deleteTime),\n            deletedBy: deletedBy,\n            version: payload.version,\n        };\n        return eventPayload;\n    }\n    if (event === \"participantsAdded\") {\n        const payload = genericPayload;\n        const addedByPayload = JSON.parse(unescape(payload.addedBy));\n        const participantsAddedPayload = JSON.parse(unescape(payload.participantsAdded));\n        const addedBy = {\n            id: constructIdentifierKindFromMri(addedByPayload.participantId),\n            displayName: addedByPayload.displayName,\n        };\n        const chatParticipants = participantsAddedPayload.map((m) => {\n            return {\n                id: constructIdentifierKindFromMri(m.participantId),\n                displayName: m.displayName,\n                shareHistoryTime: new Date(m.shareHistoryTime),\n            };\n        });\n        const eventPayload = {\n            threadId: payload.threadId,\n            addedOn: new Date(payload.time),\n            addedBy: addedBy,\n            version: payload.version,\n            participantsAdded: chatParticipants,\n        };\n        return eventPayload;\n    }\n    if (event === \"participantsRemoved\") {\n        const payload = genericPayload;\n        const removedByPayload = JSON.parse(unescape(payload.removedBy));\n        const participantsRemovedPayload = JSON.parse(unescape(payload.participantsRemoved));\n        const removedBy = {\n            id: constructIdentifierKindFromMri(removedByPayload.participantId),\n            displayName: removedByPayload.displayName,\n        };\n        const chatParticipants = participantsRemovedPayload.map((m) => {\n            return {\n                id: constructIdentifierKindFromMri(m.participantId),\n                displayName: m.displayName,\n                shareHistoryTime: new Date(m.shareHistoryTime),\n            };\n        });\n        const eventPayload = {\n            threadId: payload.threadId,\n            removedOn: new Date(payload.time),\n            removedBy: removedBy,\n            version: payload.version,\n            participantsRemoved: chatParticipants,\n        };\n        return eventPayload;\n    }\n    return null;\n};\nconst toLogProvider = (logger) => {\n    return {\n        log: (...message) => logger.info(message),\n        warn: (...message) => logger.warning(message),\n        error: (...message) => logger.error(message),\n        debug: (...message) => logger.verbose(message),\n        info: (...message) => logger.verbose(message),\n    };\n};\nexports.toLogProvider = toLogProvider;\nconst toTelemetrySender = (logger) => {\n    return {\n        logEvent: (clientEvent) => logger.info(clientEvent),\n    };\n};\nexports.toTelemetrySender = toTelemetrySender;\nconst constructIdentifierKindFromMri = (mri) => {\n    if (mri.startsWith(publicTeamsUserPrefix)) {\n        return {\n            kind: \"microsoftTeamsUser\",\n            rawId: mri,\n            microsoftTeamsUserId: mri.substring(publicTeamsUserPrefix.length),\n            isAnonymous: false,\n            cloud: \"public\",\n        };\n    }\n    else if (mri.startsWith(dodTeamsUserPrefix)) {\n        return {\n            kind: \"microsoftTeamsUser\",\n            rawId: mri,\n            microsoftTeamsUserId: mri.substring(dodTeamsUserPrefix.length),\n            isAnonymous: false,\n            cloud: \"dod\",\n        };\n    }\n    else if (mri.startsWith(gcchTeamsUserPrefix)) {\n        return {\n            kind: \"microsoftTeamsUser\",\n            rawId: mri,\n            microsoftTeamsUserId: mri.substring(gcchTeamsUserPrefix.length),\n            isAnonymous: false,\n            cloud: \"gcch\",\n        };\n    }\n    else if (mri.startsWith(teamsVisitorUserPrefix)) {\n        return {\n            kind: \"microsoftTeamsUser\",\n            rawId: mri,\n            microsoftTeamsUserId: mri.substring(teamsVisitorUserPrefix.length),\n            isAnonymous: true,\n        };\n    }\n    else if (mri.startsWith(phoneNumberPrefix)) {\n        return {\n            kind: \"phoneNumber\",\n            rawId: mri,\n            phoneNumber: mri.substring(phoneNumberPrefix.length),\n        };\n    }\n    else if (mri.startsWith(acsUserPrefix) ||\n        mri.startsWith(acsGcchUserPrefix) ||\n        mri.startsWith(acsDodUserPrefix) ||\n        mri.startsWith(spoolUserPrefix)) {\n        return { kind: \"communicationUser\", communicationUserId: mri };\n    }\n    else {\n        return { kind: \"unknown\", id: mri };\n    }\n};\nconst parseJsonString = (str) => {\n    if (str === undefined ||\n        str === null ||\n        str === \"\" ||\n        str === \"null\" ||\n        str === \"{}\" ||\n        str === \"[]\") {\n        return undefined;\n    }\n    return JSON.parse(str);\n};\nconst createMediaUrlString = (urlString, resourceEndpoint, gatewayApiVersion) => {\n    let url;\n    try {\n        url = new URL(urlString);\n        if (url.protocol === \"http:\" || url.protocol === \"https:\") {\n            // If its already a full url, substitute the origin\n            url = new URL(url.pathname, resourceEndpoint);\n        }\n    }\n    catch (_) {\n        // urlString is a likely a relative URL, so create a new one with the resourceEndpoint as base\n        try {\n            url = new URL(urlString, resourceEndpoint);\n        }\n        catch (_) {\n            // If we get here, then the urlString passed in is likely incorrect, so just pass it along\n            // As there's nothing we can do at this point.\n            return urlString;\n        }\n    }\n    // Append api-version query and return string\n    url.searchParams.set(\"api-version\", gatewayApiVersion);\n    return url.toString();\n};\nconst isValidURL = (str) => {\n    let url;\n    try {\n        url = new URL(str);\n    }\n    catch (_) {\n        return false;\n    }\n    return url.protocol === \"http:\" || url.protocol === \"https:\";\n};\nconst transformEndpoint = (attachments, resourceEndpoint, gatewayApiVersion) => {\n    if (resourceEndpoint === undefined ||\n        resourceEndpoint === null ||\n        resourceEndpoint === \"\" ||\n        !isValidURL(resourceEndpoint)) {\n        return attachments;\n    }\n    attachments\n        .filter((e) => e.attachmentType.toLowerCase() === \"image\".toLowerCase())\n        .map((attachment) => {\n        if (attachment.previewUrl) {\n            attachment.previewUrl = createMediaUrlString(attachment.previewUrl, resourceEndpoint, gatewayApiVersion);\n        }\n        if (attachment.url) {\n            attachment.url = createMediaUrlString(attachment.url, resourceEndpoint, gatewayApiVersion);\n        }\n    });\n    return attachments;\n};\nconst base64decode = (encodedString) => !core_util_1.isNodeLike ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\nexports.base64decode = base64decode;\nconst parseJWT = (token) => {\n    let [, payload] = token === null || token === void 0 ? void 0 : token.split(\".\");\n    if (payload === undefined) {\n        throw new Error(\"Invalid token\");\n    }\n    payload = payload.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    return JSON.parse(decodeURIComponent(escape((0, exports.base64decode)(payload))));\n};\nconst parseTokenCredential = (credential) => __awaiter(void 0, void 0, void 0, function* () {\n    const accessToken = yield credential.getToken();\n    const jwtToken = accessToken === null || accessToken === void 0 ? void 0 : accessToken.token;\n    const parsedJwtToken = parseJWT(jwtToken);\n    const identityMri = parsedJwtToken.skypeid;\n    const acsResourceId = parsedJwtToken.resourceId;\n    const cloudType = getCloudTypeFromSkypeId(identityMri);\n    const resourceLocation = parsedJwtToken.resourceLocation || \"\";\n    return { jwtToken, acsResourceId, identityMri, cloudType, resourceLocation };\n});\nexports.parseTokenCredential = parseTokenCredential;\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n * @internal\n */\nfunction generateUuid() {\n    return (0, uuid_1.v4)();\n}\nconst isEudbLocation = (location) => !!location && !!constants_1.EudbCountries.find((euLocation) => euLocation === location);\nexports.isEudbLocation = isEudbLocation;\nfunction getCloudTypeFromSkypeId(skypeId) {\n    const cloudPrefix = skypeId.substring(0, skypeId.indexOf(\":\"));\n    switch (cloudPrefix) {\n        case constants_1.CloudPrefix.OrgId:\n        case constants_1.CloudPrefix.Acs:\n        case constants_1.CloudPrefix.Spool: {\n            return constants_1.CloudType.Public;\n        }\n        case constants_1.CloudPrefix.GccHigh:\n        case constants_1.CloudPrefix.GccHighAcs: {\n            return constants_1.CloudType.GccHigh;\n        }\n        case constants_1.CloudPrefix.Dod:\n        case constants_1.CloudPrefix.DodAcs: {\n            return constants_1.CloudType.Dod;\n        }\n        default: {\n            return constants_1.CloudType.Public;\n        }\n    }\n}\n","\"use strict\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RealTimeNotificationConfiguration = exports.TrouterConfigClient = void 0;\nconst coreClient = __importStar(require(\"@azure/core-client\")); // External library import\nconst core_rest_pipeline_1 = require(\"@azure/core-rest-pipeline\"); // Grouped imports from the same module\nconst constants_1 = require(\"./constants\");\nclass TrouterConfigClient extends coreClient.ServiceClient {\n    constructor(endpoint, options) {\n        // Initializing default values for options\n        if (!options) {\n            options = {};\n        }\n        const packageDetails = `azsdk-js-communication-signaling/${constants_1.PACKAGE_VERSION}`;\n        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix\n            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`\n            : `${packageDetails}`;\n        const clientOptions = Object.assign(Object.assign({}, options), { userAgentOptions: {\n                userAgentPrefix,\n            }, additionalPolicies: options.additionalPolicies });\n        super(clientOptions);\n        this.apiVersion = constants_1.CONFIG_API_VERSION;\n        this.endpoint = endpoint;\n        this.httpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();\n    }\n    fetchServiceUrls(credential) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const token = (yield credential.getToken()).token;\n                const request = (0, core_rest_pipeline_1.createPipelineRequest)({\n                    url: `${this.endpoint}/chat/config/realTimeNotifications?api-version=${this.apiVersion}`,\n                    method: \"GET\",\n                    headers: (0, core_rest_pipeline_1.createHttpHeaders)({\n                        Authorization: `Bearer ${token}`,\n                    }),\n                });\n                const response = yield this.pipeline.sendRequest(this.httpClient, request);\n                if (response.status !== 200 || !response.bodyAsText) {\n                    throw new Error(`Failed to fetch service URLs. Status: ${response.status}, Body: ${response.bodyAsText || \"No response body\"}`);\n                }\n                const data = JSON.parse(response.bodyAsText);\n                // Ensure all necessary data fields are present\n                if (!data.trouterServiceUrl || !data.registrarServiceUrl || !data.cloudType) {\n                    throw new Error(\"One or more required fields are missing in the response data\");\n                }\n                return new RealTimeNotificationConfiguration(data.trouterServiceUrl, data.registrarServiceUrl, data.cloudType);\n            }\n            catch (error) {\n                throw new Error(`Error fetching real-time notification configuration from Chat Gateway: ${error.message}`);\n            }\n        });\n    }\n}\nexports.TrouterConfigClient = TrouterConfigClient;\nclass RealTimeNotificationConfiguration {\n    constructor(trouterServiceUrl, registrarServiceUrl, cloudType) {\n        this.trouterServiceUrl = trouterServiceUrl;\n        this.registrarServiceUrl = registrarServiceUrl;\n        this.cloudType = cloudType;\n    }\n}\nexports.RealTimeNotificationConfiguration = RealTimeNotificationConfiguration;\n","\"use strict\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultTelemetrySettings = exports.createSettings = void 0;\nconst TrouterUtils_1 = require(\"./TrouterUtils\");\nconst TrouterConfigClient_1 = require(\"./TrouterConfigClient\");\nconst defaultSettings = {\n    version: \"1.0.0\", // SignalingClient version, required for trouter connection\n    registrationId: \"\", // Required for trouter connection\n    sessionId: \"\", // Required for trouter connection\n    pnhAppId: \"AcsWeb\",\n    pnhTemplate: \"AcsWeb_Chat_1.8\",\n    platform: \"SPOOL\",\n    platformUIVersion: \"0.0.0\",\n    environment: \"\", // TBD\n    productName: \"acs-chat-web\",\n    trouterServiceUrl: \"\",\n    registrarServiceUrl: \"\",\n    registrarRefreshTimeoutInMs: 350000,\n    timeoutOptions: {\n        connectionTimeoutMs: 20000,\n        fetchTimeoutMs: 10000,\n        pingTimeoutMs: 40000,\n        pongTimeoutMs: 5000,\n        maxBackoffMs: 50000,\n        requestTimeoutMs: 5000,\n    },\n    maxRegistrationTimeInMs: 7200000,\n};\n// Main function to create settings based on environment\nconst createSettings = (credential, options) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a;\n    const endpoint = options === null || options === void 0 ? void 0 : options.resourceEndpoint;\n    // Throw an error if resourceEndpoint is null or undefined\n    if (endpoint === undefined) {\n        throw new Error(\"'endpoint' cannot be null\");\n    }\n    // Initialize the settings by cloning the default ones\n    const settings = Object.assign({}, defaultSettings);\n    settings.registrationId = (0, TrouterUtils_1.generateUuid)(); // Generate unique IDs\n    settings.sessionId = (0, TrouterUtils_1.generateUuid)();\n    // Fetch the real time configuration from the service\n    const trouterConfigClient = new TrouterConfigClient_1.TrouterConfigClient(endpoint, options);\n    const realTimeNotificationConfiguration = yield trouterConfigClient.fetchServiceUrls(credential);\n    // Append suffix to trouterServiceUrl and registrarServiceUrl\n    settings.trouterServiceUrl = `${realTimeNotificationConfiguration.trouterServiceUrl}/v4/a`;\n    settings.registrarServiceUrl = `${realTimeNotificationConfiguration.registrarServiceUrl}/v3/registrations`;\n    // Customize settings if the environment is INT\n    if (realTimeNotificationConfiguration.cloudType === \"int\") {\n        settings.pnhAppId = \"cns-e2e-test\";\n        settings.pnhTemplate = \"cns-e2e-test:1.8\";\n    }\n    settings.maxRegistrationTimeInMs =\n        (_a = options === null || options === void 0 ? void 0 : options.registrationTimeInMs) !== null && _a !== void 0 ? _a : defaultSettings.maxRegistrationTimeInMs;\n    return settings;\n});\nexports.createSettings = createSettings;\nexports.defaultTelemetrySettings = {\n    // TBD Can we hook up OpenTelemetry?\n    enabled: false,\n};\n","\"use strict\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommunicationSignalingClient = exports.ConnectionState = void 0;\nconst tstrouter_1 = require(\"@skype/tstrouter\");\nconst TrouterUtils_1 = require(\"./TrouterUtils\");\nconst TrouterSettings_1 = require(\"./TrouterSettings\");\nconst constants_1 = require(\"./constants\");\nvar ConnectionState;\n(function (ConnectionState) {\n    ConnectionState[ConnectionState[\"Unknown\"] = 0] = \"Unknown\";\n    ConnectionState[ConnectionState[\"Connected\"] = 2] = \"Connected\";\n    ConnectionState[ConnectionState[\"Disconnected\"] = 3] = \"Disconnected\";\n    ConnectionState[ConnectionState[\"Switching\"] = 9] = \"Switching\";\n})(ConnectionState || (exports.ConnectionState = ConnectionState = {}));\nclass CommunicationSignalingClient {\n    constructor(credential, logger, options) {\n        this.credential = credential;\n        this.logger = logger;\n        this.options = options;\n        this.stateChangedListener = null;\n        this.tokenFetchRetries = 0;\n        this.trouter = (0, tstrouter_1.createTrouterService)((0, TrouterUtils_1.toLogProvider)(logger));\n    }\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            this.resourceEndpoint = (_a = this.options) === null || _a === void 0 ? void 0 : _a.resourceEndpoint;\n            if (this.resourceEndpoint === undefined) {\n                throw new Error(\"'endpoint' cannot be null\");\n            }\n            this.gatewayApiVersion = ((_b = this.options) === null || _b === void 0 ? void 0 : _b.gatewayApiVersion) || \"2024-03-07\";\n            if (this.config === undefined) {\n                this.config = {\n                    trouterSettings: yield (0, TrouterSettings_1.createSettings)(this.credential, this.options),\n                    skypeTokenProvider: (forceRefresh) => __awaiter(this, void 0, void 0, function* () {\n                        if (forceRefresh) {\n                            this.tokenFetchRetries += 1;\n                            if (this.tokenFetchRetries > constants_1.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES) {\n                                yield this.stop(true);\n                                throw new Error(`Access token is expired and failed to fetch a valid one after ${constants_1.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES} retries`);\n                            }\n                        }\n                        else {\n                            this.tokenFetchRetries = 0;\n                        }\n                        return Promise.resolve((yield this.credential.getToken()).token);\n                    }),\n                    telemetryConfig: {\n                        eventLogger: (0, TrouterUtils_1.toTelemetrySender)(this.logger),\n                        settings: TrouterSettings_1.defaultTelemetrySettings,\n                    },\n                };\n            }\n            this.trouter.start(this.config);\n            this.trouter.setUserActivityState(tstrouter_1.UserActivityState.Active);\n        });\n    }\n    stop(isTokenExpired) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.trouter.offStateChanged(this.stateChangedListener);\n            this.trouter.clearMessageHandlers();\n            this.trouter.stop(isTokenExpired !== null && isTokenExpired !== void 0 ? isTokenExpired : this.tokenFetchRetries > constants_1.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES);\n        });\n    }\n    on(event, listener) {\n        if (event === \"connectionChanged\") {\n            this.trouter.offStateChanged(this.stateChangedListener);\n            this.stateChangedListener = (state, _url) => listener(state);\n            this.trouter.onStateChanged(this.stateChangedListener);\n            return;\n        }\n        this.trouter.registerMessageHandler((0, TrouterUtils_1.toMessageHandler)(event, listener, this.resourceEndpoint, this.gatewayApiVersion));\n    }\n}\nexports.CommunicationSignalingClient = CommunicationSignalingClient;\n","\"use strict\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./SignalingClient\"), exports);\n"],"names":["root","factory","module","this","moduleId","installedModules","exports","i","l","call","__webpack_require__","m","modules","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","request","timeoutMs","fetchPromise","resolve","reject","fetch","then","response","timeoutId","clearTimeout","catch","error","setTimeout","url","race","timeoutPromise","obj","stringify","Timespan","toJson","fetchWithTimeout","start","Date","now","reset","logProvider","tokenProvider","options","__extends","b","extendStatics","setPrototypeOf","__proto__","constructor","String","create","__","__assign","assign","t","arguments","length","apply","__awaiter","thisArg","_arguments","P","generator","Promise","step","next","e","result","done","adopt","fulfilled","rejected","__generator","body","v","op","f","g","_","y","label","ops","pop","trys","push","sent","verb","throw","return","Symbol","iterator","createRegistrarClient","RegistrarClient","SUPPORTED_TOKEN_TYPES","message","_this","Error","logger","maxBackoffInMs","initialDelay","backoffCount","id","ExponentialDelay","idCounter","delay","taskName","timerHandle","calculateNextBackoffMs","info","backoffMs","cancelFunc","cancel","debug","Math","random","backoff","pow","fudge","round","min","DEFAULT_MAX_RETRIES_FOR_GET_TOKEN","DEFAULT_MAX_BACKOFF_TIME_IN_MS","backoffs","maxBackOffTime","maxRetryDelayMs","maxRetriesForGetToken","proxyUrlRewrite","setTelemetryLogger","eventLogger","register","client","transports","_a","performRegistration","cachedRegistrationParams","unregister","unregisterRequest","registrarUrl","registrationId","method","mode","headers","extraRegistrationHeaders","accept","callRegistrar","cancelPendingRequests","keys","forEach","resendRegistration","eventName","registerRequest","payload","clientDescription","nodeId","startBackoff","initialRetryDelayMs","stopBackoff","getToken","claimsChallenge","retryCount","token","error_1","stringfiedError","err","cancelError_1","needFresh","supportedTokenTypes","wwwAuthenticateHeader","purpose","JSON","warn","_b","_c","cachedToken","stopwatch","req","_d","_e","error_2","canceledError_1","details","_f","_g","error_3","_h","setTokenHeader","clone","requestTimeoutMs","status","statusText","sendTelemetryEvent","ok","json","delete","tokenType","toLowerCase","set","usingLegacyTokenApi","properties","result_code","begin_timestamp","startTime","elapsed","duration","logEvent","clientEvent","require","__WEBPACK_EXTERNAL_MODULE_21__","Logger","USER_AUTHENTICATE_EVENT_NAME","FAILED_MESSAGE_ACK","UNHANDLED_MESSAGE_ACK","HANDLED_MESSAGE_ACK","CLIENT_VERSION","constants","TROUTER_INIT","TROUTER_READY_EVENT","TROUTER_READY_TIMEOUT","TROUTER_TOKEN_REQUEST","TROUTER_TOKEN_GET_SUCCEEDED","TROUTER_TOKEN_GET_FAILED","TROUTER_RECONNECTING","RENEWAL","NEW_CONNECTION","ENDPOINT_REGISTRATION_FAILED","TrouterState","UserActivityState","expirationTsInSec","getTime","ttlInSec","origin","pathname","CorrelationVector","calculateExpireTsInSec","calculateTtlInSec","correlationVector","base","createCorrelationVectorBase","extension","extend","increase","endChars","chars","charAt","floor","TrouterManagerState","UserActivityEventReason","ServerState","connectionId","connectedClientId","domId","unsecureUrl","c2cUrlBase","expirationTsSec","getRemainingTtlInSec","reconnectParams","safeToString","scae","toString","protocol","fallbackReason","kind","args","replace","reconnectUrl","serviceUrl","parseInt","reason","host","endsWith","redirectHost","substring","redirectUrlIfPresent","ensureNumber","reconnectParamsWithoutUrls","adaptUrl","isV4ConnectEvent","usedProtocolAfterFallback","usedProtocol","TrouterFsm","State","RegistrationState","logfunc","worker","incallModeEnabled","protocolSelector","state","Initial","autoReconnect","registrationState","getState","isActive","Allocating","Connected","Handshaking","Connecting","RetrievingToken","AnonymousConnecting","WebsocketAuthenticating","isConnecting","setState","showIgnored","stop","dontUnregister","isTerminalError","isIncallMode","exitIncallMode","resetTokenBackoff","cancelPendingRegistrationRequests","stopConnectionTimer","stopPingTimer","clearSentEventTimers","stopRegistrationTimer","stopSocketIo","sendDisconnectTelemetryEvent","Registered","Registering","RegisteringButResendPending","Unregistering","TerminalError","dispatchTerminalError","dispatchDisconnected","sendUnregisterRequest","onTokenReceived","startConnectionTimer","connectV4c","sendAllocateRequest","checkConnection","disconnectDetected","onPingInterval","onAllocationSucceed","dispatchUnregistered","startSocketIo","onAllocationFailed","unauthorized","cleanUpAndInitiateReconnect","allowCachedToken","onV4cException","onConnectingTimeout","onConnecting","onSocketConnect","sendV4cAuthenticationEvent","onConnectingFailed","onSocketDisconnect","disconnectReason","toTelemetryString","countDisconnectBeforeConnectionEstablishment","onTerminalError","claims","onTrouterConnected","sendUserActivityState","startPingTimer","dispatchConnected","shouldSkipRegistration","RegistrationDisabled","dispatchRegistered","sendRegisterRequest","onReconnectRequired","useConnectParamsFromCache","eventArgs","target","dispatchReconnectIsRequired","disableAutoReconnect","onDownstreamRequest","switchToIncallModeIfEnabled","dispatchDownstreamRequest","onTrouterMessageLost","messageLossIndicators","dispatchTrouterMessageLost","sendPingRequest","onPingResponseTimeout","onMissedResponse","onPingResponse","onRegistrationFailed","Retrying","startRegistrationRetryTimer","onRetryRegistration","onRegistrationSucceeded","startRegistrationTimer","onRegistrationNearExpiry","onUnregistrationDone","onResendRegistration","onIncallModeTimer","onSetNewUserActivityState","Modified","onActivityStateResponseTimeout","forceReconnect","onResponseHandlerName","event","enterIncallMode","restartIncallModeTimer","dispatchReconnecting","migrationHeader","Authorization","stack","TrouterConnection","ReconnectReason","io","cv","ua","hr","ackTimeoutMs","rewriteUrlForProxy","cvHeader","requestJson","cvCounter","parse","startTS","safeJsonNumber","safeJsonString","shortUrl","safeJsonRecord","replied","timedout","receivedCv","updateCvHeader","on","targetCallback","dataCallback","incrementCorrelationVector","defaultValue","jsonRecord","responseData","sendResponse","writeHead","write","chunk","end","timeoutTimerId","manager","initialUserActivityState","audienceSubscriptionState","WEBSOCKET_TRANSPORT_NAME","XHR_POLLING_TRANSPORT_NAME","AUDIENCE_SUBSCRIPTION_RESULT_ERROR","AUDIENCE_SUBSCRIPTION_RESULT_UNSUBSCRIBED","AUDIENCE_SUBSCRIPTION_RESULT_TIMEOUT","AUDIENCE_SUBSCRIPTION_RESULT_BAD_REQUEST","AUDIENCE_SUBSCRIPTION_STATE_QUERY_PARAM_REGEX","inIncallMode","connectionAttempt","isNavigatorOnline","onNavigatorOnlineStatusUpdateBound","onNavigatorOnlineStatusUpdate","bind","connectingErrorsInRow","unauthorizedErrorCount","pendingSentEventTimers","lastDisconnectReason","UNKNOWN_TRANSPORT","connectingErrorsThreshold","pendingAudienceSubscription","timeoutOptions","tokenBackoff","ExponentialBackoff","maxBackoffMs","clientID","window","location","hostname","clientInfo","safeString","connectionTracker","ConnectionTracker","getServerState","endpointId","clientCorrelationID","environment","applyConnectionTrackerOptions","incallModeTimeoutMs","fsm","useIncallMode","registration","fetchTimeoutMs","retryLimitOnTokenFetch","extraConnectionHeaders","registrarClient","registrarOptions","userActivityState","externalConnectParams","navigator","addEventListener","onLine","removeEventListener","close","configure","trouterUrl","urlChanged","Configuration","sendTelemetry","ClientEventName","CheckConnection","disableRegistrationsAndAutoReconnect","allocateResult","surl","connectionExpireTimestampInSecs","useCache","retryCounter","trackStart","tokenRequest","trackEnd","msg","trackError","canRetryTokenFetchRequest","requestFunction","connectionTimeoutMs","connectionTimeoutId","transportTypeName","pingTimeoutMs","pingTimerId","setInterval","clearPingResponseTimer","clearInterval","hasCustomRegistrationTtl","registrarTtlSec","getRegistrationTtl","ttl","isTtlReduced","registrationTimerId","timeForReregistrationSec","registrationRetryDelaySec","buildSocketIoUrlParams","userActivitySnapshot","audienceSubscriptionSnapshot","signatureData","connectparams","urlParams","tc","encodeURI","timeout","auth","epid","userActivity","encodeURIComponent","appendConnectedClientIds","buildQuery","ioOptions","Unknown","increaseCvAndGetEventObject","audienceSubscriptionStateSnapshot","reconnect","requestHeaders","headersFromToken","query","socketio","socket","connect","attachSocketIoHandlers","removeAllListeners","disconnect","errorStackToJson","onConnected","onRegistered","onUnregistered","ResponseData","onReconnecting","onReconnectIsRequired","onDisconnected","resetReconnectParamsOnErrorThreshold","sendProcessedDroppedIndicators","processedMessageLossEvent","droppedIndicators","sendDownstreamEvent","trackNewConnection","rp","expiration","se","connectParams","appendCorrelationIds","appendEndpointId","startTimestamp","responseStatusCode","responseSkypetokenDeprecated","allocateRequest","responseClaimsChallenge","contentType","startsWith","responseObj","onAllocationResponse","errorMessage","testNominalUrlConnectivity","trackProgress","search","check","cor_id","testRequest","Accept","text","pingResponseTimerId","emit","pongTimeoutMs","inputUrl","websocketUrl","buildV4cUrlParams","setUserActivityState","userActivityObject","changed","toEventJSON","onUserActivityStateAccepted","connected","sendUserActivityStateMultiple","setAudienceSubscriptionsAsync","timeoutInMs","setAudienceSubscriptionsInternalAsync","setAudienceSubscriptionsLongpollInternalAsync","previousAudienceSubscriptionState","setAudienceSubscriptionsPromise","setAudienceSubscriptionsUnsafeAsync","audienceSubscriptionEvent","buildAudienceSubscriptionsTimeoutResponse","hasTimedOut","onAudienceSubscriptionResult","onAudiencesSetResolved","previousSubscriptionState","currentResponse","currentAudienceResponse","subscribesToDifferentAudience","synthResponses","audiences","handleAudienceUnsubscribeLongpoll","audienceSetResolve","responses","clearAudienceSubscriptionStateQueryParam","find","r","audienceId","audienceSubscriptionModel","audienceSubscriptions","mapToSyntheticAudienceSubscriptionResponses","synthState","synthResponseStatus","map","audSub","responseStatus","expediteBackoff","expediteIfPending","appId","pnhAppId","aesKey","languageId","platform","templateKey","pnhTemplateKey","platformUIVersion","productContext","TROUTER","context","path","registrationTtl","Registration","span","errorMessageToString","Unregistration","clearSentEventTimer","Number","key","clearIncallModeTimerId","incallModeTimerId","incallTimeoutOptions","setMaxBackoffMs","serverClosed","trackDisconnected","props","clearConnectedInfo","forceReconnectDueToNoRegistration","onSocketConnecting","onSocketConnectFailed","rawReason","getSessionLength","DisconnectReason","fromRawReason","sessionLengthMs","duplicateDisconnectThresholdMs","onSocketReconnect","onSocketReconnectFailed","fromSocketIoEventData","onSocketReconnecting","onSocketError","errorObject","safeToStringOrType","onSocketMessage","chainIdLogText","chainId","urlPath","trackRequest","sendResponseError","v4cArgs","populateAndCacheReconnectParams","populateConnectionStateFields","connectedUrl","trackConnected","isNewUrl","onTrouterReconnect","ServerInitiated","onTrouterMessageLoss","onConnectionParametersUpdated","ccid","curlb","indexOf","pos","substr","increasePingResponseCount","components","join","isParamsOnly","includes","params","slice","sep","str","cd","latencyMS","send","sentTS","trackResponse","errorMsg","remaining","activityEvent","activityEventObject","timeoutReached","userActivitySecondResendDelayMs","registerSentEventTimer","userActivityResponseTimeoutMs","responseCallback","timerId","timerDescription","allocationTtl","isLower","mergeSettings","telemetrySettings","enable","disable","currentCounter","retryLimit","MessageHandlerRegistry","messageHandlers","handler","some","item","clear","active","handleMessage","resultCode","isHandled","safeExecuteHandle","messageHandler","exception","provider","forceRefresh","addCacheAsBackupTo","TrouterManager","AudienceSubscriptionState","UserActivityObject","getStateString","Active","Inactive","toEventObject","logFunc","listener","tokenTypeProtocolSelector","forceV4aProtocol","TrouterManagerFsm","baseEndpointUrl","processedMessageLoss","firstConnection","secondConnection","isInTerminalState","getInternalState","reportStateInfo","managerState","firstState","secondState","startFirstConnection","configuredTrouterManager","connection","getConnectionCache","connectionCache","startSecondConnection","stopFirstConnection","storedFirstConnection","stopSecondConnection","stopSecondConnectionDelayed","lingeringConnectionDelayMs","forceStopLingeringConnection","switchConnections","tmp","doesSecondConnectionExist","ss","connectionInfo","newEndpointUrl","clientId","connectionTtlSec","onTrouterDisconnected","dispatchRegistrationState","isRegistered","registrationStateCallback","expediteBackoffOnConnections","lastExpediteBackoffCallAt","expediteBackoffOnStartMinimumDelayMs","rsp","onTrouterRequest","onReconnectionRequired","onTrouterUserActivityStateAccepted","audienceSubscriptionsResponse","connectionParameters","setConnectionCache","indicators","filter","di","tag","etag","duplicates","messageLossProcessed","onGetTrouterConnectionCache","serialized","parsed","content","onSetTrouterConnectionCache","RegistrationEnforcer","connectionDependsOnRegistration","delayEventsUntilRegistered","TrouterUrlPromise","getPromise","pendingPromise","pendingPromiseResolveRef","pendingPromiseRejectRef","resolveUrl","resolveCallback","rejectUrl","rejectCallback","resetUrl","global","version","j","sockets","uri","util","parseUri","document","domain","port","uuri","uniqueUri","secure","merge","Socket","of","re","parts","exec","addition","chunkQuery","part","qs","split","kv","load","fn","readyState","pageLoaded","element","capture","attachEvent","xdomain","hasCORS","concat","defer","webkit","additional","deep","lastseen","seen","depth","prop","mixin","ctor","ctor2","inherit","isArray","Array","intersect","arr","arr2","longest","shortest","ret","toArray","enu","a","withCredentials","test","userAgent","EventEmitter","$events","addListener","once","self","removeListener","list","splice","listeners","parent","nativeJSON","parser","packets","reasons","advice","encodePacket","packet","type","endpoint","ack","data","adv","ev","ackId","encoded","encodePayload","decoded","decodePacket","match","regexp","pieces","opts","decodePayload","sessid","connectErrorCallback","isOpened","Transport","onData","clearCloseTimeout","connecting","reconnecting","setCloseTimeout","msgs","onPacket","setHeartbeatTimeout","onHeartbeat","onConnect","closeTimeout","onDisconnect","clearTimeouts","reopenTimeout","heartbeat","onOpen","onClose","prepareUrl","scheme","resource","ready","clearEventHandlers","Infinity","open","namespaces","buffer","doBuffer","disconnected","isXDomain","disconnectSync","SocketNamespace","publish","nsp","$emit","handshake","onError","getElementsByTagName","script","createElement","src","insertAt","parentNode","insertBefore","complete","removeChild","xhr","setRequestHeader","onreadystatechange","empty","responseText","getTransport","override","transport","xdomainCheck","sessionid","onHandshakeComplete","sid","connectTimeoutTimer","remainingTransports","tryNextTransport","heartbeatTimeout","heartbeatTimeoutTimer","setBuffer","wasConnecting","wasConnected","reconnectionAttempts","reconnectionTimer","maybeReconnect","reconnectionDelay","redoTransports","tryMultiple","maxAttempts","limit","flags","ackPackets","acks","namespace","lastArg","Flag","websocket","WS","MozWebSocket","WebSocket","onopen","onmessage","onclose","onerror","XHR","post","ackTimeoutTimer","onload","sendXHR","XDomainRequest","stateChange","usesXDomReq","socketProtocol","isXProtocol","XHRPolling","abort","Function","eval","webpackPolyfill","deprecate","paths","children","Properties","TrackerStep","stepName","operation","delta","ts","numberOfPingReplies","connectedTimestamp","transportType","connectionNumber","enabled","numberOfStepsToMaintain","logHealthCheckError","sendProgressTimeoutSecs","logSendPingError","trouter_js_client_connected","trouter_js_client_disconnected","trouter_js_client_error","trouter_js_client_progress","trouter_js_client_response","trouter_js_client_request","trouter_js_client_registration","trouter_js_client_unregistration","trouter_js_client_check_connection","steps","totalStepCount","beginTimestamp","eventLogSettings","connectedInfo","telemetrySender","sendProgress","Progress","cancelProgressTimer","progressTimeout","resetProgressSendTimer","timeoutSecs","setConnectedInfo","copyProperties","dest","source","eventProperties","progress","eventVersion","serverState","ttlInSecs","exc","createStep","addStep","progressHint","subOperation","totalSteps","connectionDuration","stepCount","connectionEstablishmentMs_Total","sessionLengthMS","Disconnected","hasError","requestID","httpMethod","bodyLength","requestTimeStamp","header","Request","responseTimestamp","responseCode","responseLength","Response","settings","max","k","newProgressTimeout","parsedReason","arg","waitStart","expectedWait","tolerance","actualWait","minimumWaitMs","gapDetectionSettings","backoffId","ms","previousCompleteTime","callback","shouldReset","backoffWaitStart","__spreadArray","to","from","pack","ar","LoggingManagerConsumer","wrapped","shouldConnectionDependOnRegistration","shouldHoldBackEvents","heldBackEvents","passIfRegisteredOrNotNeeded","fireHeldBackEvents","dropHeldBackEvents","flowTags","holdBackEvent","holdBackEvents","prefix","onEventAction","onEvent","jsonArgs","console","log","Switching","first","startingCfg","ecsCfg","TelemetryEnabled","ClientTelemetryEventEnabled","res","cfg","_j","_k","rewriteUrlForProxyCallback","trouterSettings","productName","sessionId","populateTelemetryOptions","telemetryConfig","TrouterConnectionUrl","trouterServiceUrl","registrarServiceUrl","pnhTemplate","pnhProductContext","pnhContext","maxRegistrationTimeInMs","trouterConnectTimeoutInMs","registrationStateCallbackForAcsDoNotUse","toJSON","existingUrl","newBase","schemaSepPos","pathSepPos","requestTime","toISOString","previousToken","replaceTrouterUrlBase","getTrouterServiceVersion","createTrouterService","TrouterService","stateChangedListeners","trouterUrlPromise","skypeTokenProvider","authTokenProvider","disableInternalSkypeTokenCache","trouterCfg","populateTrouterOptions","internalEnableV4cProtocol","authTokenProviderProtector","skypeTokenAdapter","trouterServer","pendingActivityState","setEcsConfig","fullEcsData","registerListener","unregisterListener","endpointUrl","notifyStateChanged","bestPath","tryMessageHandlers","setAudienceSubscriptions","getTrouterUrlAsync","onStateChanged","wrappedCallback","offStateChanged","wrapper","sizeBeforeRemoval","addCallback","removeCallback","index","registerMessageHandler","clearMessageHandlers","eventId","evt","rawBody","responseHeaders","responseBody","core_util_1","uuid_1","constants_1","coreClient","require$$0","core_rest_pipeline_1","TrouterUtils_1","tstrouter_1","TrouterSettings_1"],"mappings":"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"}